<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>test_code</title>
    <url>/posts/726c1a57/</url>
    <content><![CDATA[<h2 id="三维dp"><a class="markdownIt-Anchor" href="#三维dp"></a> 三维dp</h2>
<h3 id="dqwdwq"><a class="markdownIt-Anchor" href="#dqwdwq"></a> dqwdwq</h3>
<p><mark>dwqd</mark><br />
<img data-src="http://hz-picbed-xxh.oss-cn-hangzhou.aliyuncs.com/img-bed/3-1Q113131610L7.gif" alt="顾客购物程序的类图" /></p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msubsup><mo>∑</mo><mi>x</mi><mrow><mi>s</mi><mi>d</mi></mrow></msubsup><mfrac><mrow><mfrac><mi>a</mi><mi>b</mi></mfrac><mo>+</mo><mi>a</mi></mrow><mi>α</mi></mfrac></mrow><annotation encoding="application/x-tex">\sum_{x}^{sd}{\frac{a}{b}+{a}\over{\alpha}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.37988em;vertical-align:-0.345em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9890079999999999em;"><span style="top:-2.40029em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">x</span></span></span></span><span style="top:-3.2029em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">s</span><span class="mord mathdefault mtight">d</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.29971000000000003em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.03488em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.0037em;">α</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.5508em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mopen nulldelimiter sizing reset-size3 size6"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.6915428571428572em;"><span style="top:-2.656em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">b</span></span></span></span><span style="top:-3.2255000000000003em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line mtight" style="border-bottom-width:0.049em;"></span></span><span style="top:-3.384em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">a</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.344em;"><span></span></span></span></span></span><span class="mclose nulldelimiter sizing reset-size3 size6"></span></span><span class="mbin mtight">+</span><span class="mord mtight"><span class="mord mathdefault mtight">a</span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p>
<a id="more"></a>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mo>∗</mo><msup><mi>b</mi><mn>2</mn></msup><mspace width="1em"/><mo stretchy="false">(</mo><mi>b</mi><mi>ω</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">a*b^2 \quad (b \omega)
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.46528em;vertical-align:0em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.1141079999999999em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:1em;"></span><span class="mopen">(</span><span class="mord mathdefault">b</span><span class="mord mathdefault" style="margin-right:0.03588em;">ω</span><span class="mclose">)</span></span></span></span></span></p>
<p><code>dwqdnjk</code><br />
<code>test for ms code</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @Descripttion: 111 https://leetcode.com/discuss/interview-question/1488563/microsoft-on-campus-2021-india</span></span><br><span class="line"><span class="comment"> * @version: </span></span><br><span class="line"><span class="comment"> * @Author: xxh</span></span><br><span class="line"><span class="comment"> * @Date: 2022-01-23</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;dp;</span><br><span class="line"><span class="type">int</span> dd[<span class="number">100</span>][<span class="number">2</span>][<span class="number">200</span>]=&#123;<span class="number">-1</span>&#125; ;<span class="comment">//pos - -x/y - value</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; h,<span class="type">int</span> pos,<span class="type">int</span> rx,<span class="type">int</span> ry,<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pos&gt;=n) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(dp[pos][<span class="built_in">abs</span>(rx-ry)]!=<span class="number">-1</span>)<span class="keyword">return</span> dp[pos][<span class="built_in">abs</span>(rx-ry)];</span><br><span class="line">    <span class="type">int</span> v1=<span class="number">0</span>,v2=<span class="number">0</span>,v3=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(rx&gt;=h[pos])v1 = <span class="number">1</span>+<span class="built_in">dfs</span>(h,pos+<span class="number">1</span>,rx-h[pos],ry,n);</span><br><span class="line">    <span class="keyword">if</span>(ry&gt;=h[pos]) v2 = <span class="number">1</span>+<span class="built_in">dfs</span>(h,pos+<span class="number">1</span>,rx,ry-h[pos],n);</span><br><span class="line">    v3=<span class="built_in">dfs</span>(h,pos+<span class="number">1</span>,rx,ry,n);</span><br><span class="line">    dp[pos][<span class="built_in">abs</span>(rx-ry)] = <span class="built_in">max</span>(v1,<span class="built_in">max</span>(v2,v3));</span><br><span class="line">    <span class="keyword">return</span> dp[pos][<span class="built_in">abs</span>(rx-ry)];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">f</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; h,<span class="type">int</span> pos,<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    dd[<span class="number">0</span>][<span class="number">0</span>][x]=dd[<span class="number">0</span>][<span class="number">1</span>][y]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = x;j&gt;=h[i<span class="number">-1</span>];j--) <span class="comment">//x</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k=y;k&gt;=<span class="number">0</span>;k--)&#123; <span class="comment">//y</span></span><br><span class="line">                <span class="keyword">if</span>(dd[i<span class="number">-1</span>][<span class="number">1</span>][k]!=<span class="number">-1</span>&amp;&amp;dd[i<span class="number">-1</span>][<span class="number">0</span>][j]!=<span class="number">-1</span>) &#123;</span><br><span class="line">                    dd[i][<span class="number">0</span>][j-h[i<span class="number">-1</span>]]= <span class="built_in">max</span>(dd[i<span class="number">-1</span>][<span class="number">1</span>][k]+dd[i<span class="number">-1</span>][<span class="number">0</span>][j]+<span class="number">1</span>,dd[i][<span class="number">0</span>][j-h[i<span class="number">-1</span>]]);</span><br><span class="line">                    cout&lt;&lt;i&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;j&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;dd[i][<span class="number">0</span>][j-h[i<span class="number">-1</span>]]&lt;&lt;endl;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = y;j&gt;=h[i<span class="number">-1</span>];j--)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k=x;k&gt;=<span class="number">0</span>;k--)&#123;</span><br><span class="line">                <span class="keyword">if</span>(dd[i<span class="number">-1</span>][<span class="number">0</span>][k]!=<span class="number">-1</span>&amp;&amp;dd[i<span class="number">-1</span>][<span class="number">1</span>][j]!=<span class="number">-1</span>) dd[i][<span class="number">1</span>][j-h[i<span class="number">-1</span>]] = <span class="built_in">max</span>(dd[i<span class="number">-1</span>][<span class="number">0</span>][k]+dd[i<span class="number">-1</span>][<span class="number">1</span>][j]+<span class="number">1</span>,dd[i][<span class="number">1</span>][j-h[i<span class="number">-1</span>]]);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mx =<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;<span class="number">100</span>;i++)&#123;</span><br><span class="line">        <span class="comment">//cout&lt;&lt;dd[n-1][0][i];</span></span><br><span class="line">        mx = <span class="built_in">max</span>(mx,dd[n<span class="number">-1</span>][<span class="number">0</span>][i]);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="type">int</span> my = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;<span class="number">100</span>;i++)&#123;</span><br><span class="line">        <span class="comment">//cout&lt;&lt;dd[n-1][1][i];</span></span><br><span class="line">        my = <span class="built_in">max</span>(my,dd[n<span class="number">-1</span>][<span class="number">1</span>][i]);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>(mx,my);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;h=&#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">4</span>&#125;;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">8</span>,y=<span class="number">9</span>;</span><br><span class="line">    <span class="type">int</span> n = h.<span class="built_in">size</span>();</span><br><span class="line">    dp.<span class="built_in">resize</span>(n,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="built_in">max</span>(x,y)+<span class="number">1</span>,<span class="number">-1</span>));</span><br><span class="line">    <span class="built_in">memset</span>(dd,<span class="number">0xff</span>,<span class="built_in">sizeof</span>(dd));</span><br><span class="line">    cout&lt;&lt;<span class="built_in">f</span>(h,<span class="number">0</span>,x,y,n);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>test</category>
        <category>面试题</category>
        <category>MS</category>
      </categories>
      <tags>
        <tag>test</tag>
        <tag>dp</tag>
        <tag>ms面试题</tag>
      </tags>
  </entry>
  <entry>
    <title>cpp博客汇总</title>
    <url>/posts/26f80d45/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">
  <script id="hbeData" type="hbeData" data-hmacdigest="48d4c2071a98261b91bf0f24d970df9a5ee3e1bc9449d012e30537c624463818">8c5eb7d299eb8204d1aa11d5321f1970e0702a4fa338dd1cc8a5f32ab3a638a5dfe317204ae956e092fc50bb1621e8ea08b755118da87b6340cee979b850f15388d6b14e6dbb75303be94c0ae2e6ad26eb3a75cba0265537fed2ef182633562904235b0284ffd7da53a6cf40d6b9c9fdc57a1e72ccf74d82d900b007763c0fa11de3777c888133a80ebcf422c34dfceae367d70f6a29a85a916cf04b3ed2f82eeb30bbe9fa60970f3db4e55dcb8b5662</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-blink">
      <input class="hbe hbe-input-field hbe-input-field-blink" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-blink" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-blink" data-content="您好, 这里需要密码.">您好, 这里需要密码.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>cpp</category>
        <category>cpp资源</category>
      </categories>
      <tags>
        <tag>cpp资源</tag>
      </tags>
  </entry>
  <entry>
    <title>cpp中指定默认参数的位置</title>
    <url>/posts/27cf2ee3/</url>
    <content><![CDATA[<p>wu</p>
]]></content>
      <categories>
        <category>cpp</category>
        <category>cpp语法</category>
      </categories>
      <tags>
        <tag>cpp语法</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo setups</title>
    <url>/posts/b763a0b1/</url>
    <content><![CDATA[<h3 id="centos-关闭selinux及防火墙"><a class="markdownIt-Anchor" href="#centos-关闭selinux及防火墙"></a> centos 关闭SELINUX及防火墙</h3>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$ </span><span class="language-bash">setenforce 0</span></span><br><span class="line"><span class="meta">$ </span><span class="language-bash">sed -i <span class="string">&#x27;s/SELINUX=enforcing/SELINUX=disabled/&#x27;</span> /etc/selinux/config</span></span><br><span class="line"><span class="meta">$ </span><span class="language-bash">systemctl <span class="built_in">disable</span> firewalld &amp;&amp; systemctl stop firewalld</span></span><br></pre></td></tr></table></figure>
<h3 id="创建tags-caterories"><a class="markdownIt-Anchor" href="#创建tags-caterories"></a> 创建tags、caterories</h3>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$ </span><span class="language-bash">hexo new page <span class="string">&quot;tags&quot;</span></span></span><br></pre></td></tr></table></figure>
<p>修改source/tags/index.md</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">tags</span></span><br><span class="line"><span class="attr">date:</span> <span class="number">2017-07-10 16:36:26</span></span><br><span class="line"><span class="attr">type:</span> <span class="string">&quot;tags&quot;</span></span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></table></figure>
<p>修改themes/next/_config.yml</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">menu:</span></span><br><span class="line"><span class="attr">home:</span> <span class="string">/</span></span><br><span class="line"><span class="attr">archives:</span> <span class="string">/archives/</span></span><br><span class="line"><span class="attr">categories:</span> <span class="string">/categories/</span></span><br><span class="line"><span class="attr">tags:</span> <span class="string">/tags/</span></span><br></pre></td></tr></table></figure>
<p>tags 不存在多级,cat可以多级</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">categories:</span><br><span class="line">- [Sports, Baseball]</span><br><span class="line">- Baseball</span><br><span class="line">tags:</span><br><span class="line">- Injury</span><br><span class="line">- Fight</span><br><span class="line">- Shocking</span><br></pre></td></tr></table></figure>
<p>使用katex</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$ </span><span class="language-bash">npm un hexo-renderer-marked</span></span><br><span class="line"><span class="meta">$ </span><span class="language-bash">npm i hexo-renderer-markdown-it-plus</span></span><br></pre></td></tr></table></figure>
<h3 id="修改自定义样式"><a class="markdownIt-Anchor" href="#修改自定义样式"></a> 修改自定义样式</h3>
<p><code>css/_common/outline/footer/index.styl</code></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.footer-inner</span> &gt; <span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">padding-left</span>: <span class="number">8px</span>;</span><br><span class="line">  <span class="attribute">padding-right</span>: <span class="number">8px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="博客加密"><a class="markdownIt-Anchor" href="#博客加密"></a> 博客加密</h3>
<p><a href="https://github.com/D0n9X1n/hexo-blog-encrypt/blob/master/ReadMe.zh.md">https://github.com/D0n9X1n/hexo-blog-encrypt/blob/master/ReadMe.zh.md</a></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$ </span><span class="language-bash">npm install --save hexo-blog-encrypt</span></span><br></pre></td></tr></table></figure>
<h4 id="对博文加密"><a class="markdownIt-Anchor" href="#对博文加密"></a> 对博文加密</h4>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">Hello</span> <span class="string">World</span></span><br><span class="line"><span class="attr">tags:</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">作为日记加密</span></span><br><span class="line"><span class="attr">date:</span> <span class="number">2016-03-30 21:12:21</span></span><br><span class="line"><span class="attr">password:</span> <span class="string">mikemessi</span></span><br><span class="line"><span class="attr">abstract:</span> <span class="string">有东西被加密了,</span> <span class="string">请输入密码查看.</span></span><br><span class="line"><span class="attr">message:</span> <span class="string">您好,</span> <span class="string">这里需要密码.</span></span><br><span class="line"><span class="attr">wrong_pass_message:</span> <span class="string">抱歉,</span> <span class="string">这个密码看着不太对,</span> <span class="string">请再试试.</span></span><br><span class="line"><span class="attr">wrong_hash_message:</span> <span class="string">抱歉,</span> <span class="string">这个文章不能被校验,</span> <span class="string">不过您还是能看看解密后的内容.</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="meta"></span></span><br></pre></td></tr></table></figure>
<h4 id="对tag加密"><a class="markdownIt-Anchor" href="#对tag加密"></a> 对tag加密</h4>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># Security</span></span><br><span class="line"><span class="attr">encrypt:</span> <span class="comment"># hexo-blog-encrypt</span></span><br><span class="line">  <span class="attr">abstract:</span> <span class="string">有东西被加密了,</span> <span class="string">请输入密码查看.</span></span><br><span class="line">  <span class="attr">message:</span> <span class="string">您好,</span> <span class="string">这里需要密码.</span></span><br><span class="line">  <span class="attr">tags:</span></span><br><span class="line">  <span class="bullet">-</span> &#123;<span class="attr">name:</span> <span class="string">tagName</span>, <span class="attr">password:</span> <span class="string">密码A</span>&#125;</span><br><span class="line">  <span class="bullet">-</span> &#123;<span class="attr">name:</span> <span class="string">tagName</span>, <span class="attr">password:</span> <span class="string">密码B</span>&#125;</span><br><span class="line">  <span class="attr">wrong_pass_message:</span> <span class="string">抱歉,</span> <span class="string">这个密码看着不太对,</span> <span class="string">请再试试.</span></span><br><span class="line">  <span class="attr">wrong_hash_message:</span> <span class="string">抱歉,</span> <span class="string">这个文章不能被校验,</span> <span class="string">不过您还是能看看解密后的内容.</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><a href="https://theme-next.js.org/docs/theme-settings/">https://theme-next.js.org/docs/theme-settings/</a></p>
<p><code>zhumeng2021.2\node_modules\hexo-theme-next\layout\_macro\sidebar.njk</code> 对sidebar修改</p>
<p><code>zhumeng2021.2\node_modules\hexo-theme-next\layout\_partials\post\post-related.njk</code>对related修改</p>
<p><code>C:\Users\42273\Desktop\hexo_blog\zhumeng2021.2\.deploy_git\js\schemes\muse.js</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (event.<span class="property">target</span>.<span class="title function_">matches</span>(<span class="string">&#x27;img.medium-zoom-image&#x27;</span>)) &#123;<span class="comment">// 删去clickingBlankPart||</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">hideSidebar</span>();</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>
<hr />
<p>TODO:</p>
<ol>
<li>
<h4 id="configuring-favicon"><a class="markdownIt-Anchor" href="#configuring-favicon"></a> Configuring Favicon</h4>
</li>
</ol>
]]></content>
      <categories>
        <category>环境搭建</category>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>cpp中的const</title>
    <url>/posts/4bf79020/</url>
    <content><![CDATA[<h2 id="cpp中的const更像是编译阶段的define"><a class="markdownIt-Anchor" href="#cpp中的const更像是编译阶段的define"></a> cpp中的<code>const</code>更像是编译阶段的<code>#define</code></h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> m = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> n = m;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在C语言中，编译器会先在m的内存中取出数据赋值给n；</p>
<p>在cpp中，编译器直接将10赋值给n，没有读取内存的操作。</p>
</blockquote>
<p><code>#define</code>是在预处理阶段替换，常量是在编译阶段替换。提高了程序执行的效率，缺点是不能反映内存变化。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> n =<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span>* p = (<span class="type">int</span>*)&amp;n;</span><br><span class="line">(*p) = <span class="number">100</span>;</span><br><span class="line">cout&lt;&lt;n&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;(*p)&lt;&lt;endl;</span><br><span class="line"><span class="comment">//输出为10 100</span></span><br></pre></td></tr></table></figure>
<p>将代码放到<code>.c</code>文件中，以C语言的方式编译，运行结果为<code>99</code>。再将代码放到<code>.cpp</code>文件中，以C<ins>的方式编译，运行结果就变成了<code>10</code>。这种差异正是由于C和C</ins>对 const 的处理方式不同造成的。</p>
<h2 id="cpp中全局const变量可见范围是当前文件"><a class="markdownIt-Anchor" href="#cpp中全局const变量可见范围是当前文件"></a> cpp中全局const变量可见范围是当前文件</h2>
<p>c语言中：<mark>全局变量的作用域是当前文件，但是在其他文件中也是可见的，使用<code>extern</code>声明后就可以使用</mark></p>
<p>cpp语言中：<mark>const变量的作用域是当前文件，在其他文件中不可见</mark></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="comment">//const int n = 10;</span></span><br><span class="line"><span class="comment">//int n = 10;</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">func</span><span class="params">()</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    func();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;main: %d\n&quot;</span>, n);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> n; </span><br><span class="line"><span class="type">void</span> <span class="title function_">func</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;module: %d\n&quot;</span>, n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>若为<code>int n=10;</code>无论cpp还是c语言均编译通过</p>
<p>若为<code>const int n=10;</code>，cpp编译失败（因为对其他文件不可见），c语言编译通过。</p>
</blockquote>
<h3 id="将const变量放入头文件中"><a class="markdownIt-Anchor" href="#将const变量放入头文件中"></a> 将const变量放入头文件中</h3>
<p><mark>由于 C++ 中全局 const 变量的可见范围仅限于当前源文件，所以可以将它放在头文件中，这样即使头文件被包含多次也不会出错</mark></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//module.h</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> n = <span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//module.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;module.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;module: %d\n&quot;</span>, n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//main.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;module.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">func</span>();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;main: %d\n&quot;</span>, n);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$ </span><span class="language-bash">g++ main.cpp module.cpp -o main &amp;&amp; main</span></span><br><span class="line"></span><br><span class="line">module: 10</span><br><span class="line">main: 10</span><br></pre></td></tr></table></figure>
<p>C和C<ins>中全局 const 变量的作用域相同，都是当前文件，不同的是它们的可见范围：C语言中 const 全局变量的可见范围是整个程序，在其他文件中使用 extern 声明后就可以使用；而C</ins>中 const 全局变量的可见范围仅限于当前文件，在其他文件中不可见，所以它可以定义在头文件中，多次引入后也不会出错。</p>
]]></content>
      <categories>
        <category>cpp</category>
        <category>cpp语法</category>
      </categories>
      <tags>
        <tag>cpp语法</tag>
      </tags>
  </entry>
  <entry>
    <title>decltype关键字</title>
    <url>/posts/6d46b940/</url>
    <content><![CDATA[<h3 id="decltype关键字"><a class="markdownIt-Anchor" href="#decltype关键字"></a> decltype关键字</h3>
<p><mark>decltype</mark>被称作类型说明符，作用是选择并返回操作数的数据类型。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// sum类型就是函数f返回的类型</span></span><br><span class="line"><span class="keyword">decltype</span>(<span class="built_in">f</span>()) sum = x;</span><br></pre></td></tr></table></figure>
<p>解决难以拼写的类型名，有以下两个方案：</p>
<ol>
<li>使用类型别名技术</li>
<li>使用auto和decltype</li>
</ol>
<h3 id="工作原理"><a class="markdownIt-Anchor" href="#工作原理"></a> 工作原理</h3>
<p><mark>decltype</mark>不会计算表达式的值，编译器分析表达式并得到它的类型。</p>
<p>函数调用也算一种表达式，因此不必担心在使用deltype时执行了函数。</p>
<h3 id="decltype变量"><a class="markdownIt-Anchor" href="#decltype变量"></a> decltype+变量</h3>
<p>根据表达式的定义，单独使用一个变量，相当于一个最简单的表达式。</p>
]]></content>
      <categories>
        <category>cpp</category>
        <category>cpp语法</category>
      </categories>
      <tags>
        <tag>cpp语法</tag>
      </tags>
  </entry>
  <entry>
    <title>Lambda表达式</title>
    <url>/posts/e9ee750c/</url>
    <content><![CDATA[<h3 id="声明lambda表达式"><a class="markdownIt-Anchor" href="#声明lambda表达式"></a> 声明Lambda表达式</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">[capture list] (params list) <span class="keyword">mutable</span> exception-&gt; <span class="keyword">return</span> type &#123; function body &#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>capture list： 捕获外部变量的列表</li>
<li>params list：形参列表</li>
<li>mutable指示符：是否可以修改捕获的变量</li>
<li>exception：异常设定</li>
<li>return type：返回类型</li>
<li>function body：函数体</li>
</ol>
<h4 id="格式1"><a class="markdownIt-Anchor" href="#格式1"></a> 格式1</h4>
<p>声明了const类型的表达式，函数中不能修改捕获列表中的值（引用传递除外）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">[capture list] (params list) -&gt; <span class="keyword">return</span> type &#123; function body &#125;</span><br></pre></td></tr></table></figure>
<h4 id="格式2"><a class="markdownIt-Anchor" href="#格式2"></a> 格式2</h4>
<p>省略了返回值的类型，编译器自动推断，若：</p>
<ol>
<li>
<p>含有return，则类型由return决定</p>
</li>
<li>
<p>不含有return，类型为void</p>
</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">[capture list] (params list)  &#123; function body &#125;</span><br></pre></td></tr></table></figure>
<h4 id="格式3"><a class="markdownIt-Anchor" href="#格式3"></a> 格式3</h4>
<p>无参数函数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">[capture list] &#123; function body &#125;</span><br></pre></td></tr></table></figure>
<h3 id="捕获外部变量"><a class="markdownIt-Anchor" href="#捕获外部变量"></a> 捕获外部变量</h3>
<table>
<thead>
<tr>
<th>捕获形式</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>[]</td>
<td>不捕获任何外部变量</td>
</tr>
<tr>
<td>[变量名…]</td>
<td>默认以值形式捕获多个指定外部变量，如果引用捕获，需要显式声明<code>&amp;</code>说明符</td>
</tr>
<tr>
<td>[this]</td>
<td>值形式捕获this指针</td>
</tr>
<tr>
<td>[=]</td>
<td>值形式捕获外部所有变量</td>
</tr>
<tr>
<td>[&amp;]</td>
<td>引用方式捕获外部所有变量</td>
</tr>
<tr>
<td>[=,&amp;x]</td>
<td>变量x用引用方式捕获，其余变量以传值形式捕获</td>
</tr>
<tr>
<td>[&amp;,x]</td>
<td>变量x以传值方式捕获，其余变量以引用形式捕获</td>
</tr>
</tbody>
</table>
<h3 id="lambda表达式的参数"><a class="markdownIt-Anchor" href="#lambda表达式的参数"></a> Lambda表达式的参数</h3>
<ol>
<li>参数列表中不能用默认参数</li>
<li>不支持可变长度的参数</li>
<li>所有参数必须有参数名</li>
</ol>
<h3 id="lambda表达式的类型"><a class="markdownIt-Anchor" href="#lambda表达式的类型"></a> Lambda表达式的类型</h3>
<p>Lambda 函数是一个依赖于实现的函数对象类型,这个类型的名字只有编译器知道. 如果用户想把 lambda 函数做为一个参数来传递, 那么形参的类型必须是模板类型或者必须能创建一个 <mark>std::function</mark> 类似的对象去捕获 lambda 函数.使用 auto 关键字可以帮助存储 Lambda 函数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> my_lambda_func = [&amp;](<span class="type">int</span> x) &#123; <span class="comment">/* ... */</span> &#125;;</span><br><span class="line"><span class="keyword">auto</span> my_onheap_lambda_func = <span class="keyword">new</span> <span class="built_in">auto</span>([=](<span class="type">int</span> x) &#123; <span class="comment">/* ... */</span> &#125;);</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">double</span> <span class="title">eval</span><span class="params">(std::function&lt;<span class="type">double</span>(<span class="type">double</span>)&gt; f,<span class="type">double</span> x=<span class="number">2.0</span>)</span></span>&#123;<span class="keyword">return</span> <span class="built_in">f</span>(x);&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	std::function&lt;<span class="type">double</span>(<span class="type">double</span>)&gt; f0 = [](<span class="type">double</span> x)&#123;<span class="keyword">return</span> <span class="number">1</span>;&#125;;</span><br><span class="line">    <span class="keyword">auto</span> f1 = [](<span class="type">double</span> x)&#123;<span class="keyword">return</span> x;&#125;;</span><br><span class="line">    <span class="keyword">decltype</span>(f0) fa[<span class="number">3</span>]=&#123;f0,f1,[](<span class="type">double</span> x)&#123;<span class="keyword">return</span> x*x;&#125;&#125;;</span><br><span class="line">    std::vector&lt;std::function&lt;<span class="type">double</span>(<span class="type">double</span>)&gt; &gt; fv = &#123;f0,f1&#125;;</span><br><span class="line">    fv.<span class="built_in">push_back</span>([](<span class="type">double</span> x)&#123;<span class="keyword">return</span> x*x;&#125;);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;fv.<span class="built_in">size</span>();i++) std::cout&lt;&lt;fv[i](<span class="number">2.0</span>)&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一个没有指定任何捕获的 lambda 函数,可以显式转换成一个具有相同声明形式函数指针.所以,像下面这样做是合法的:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> a_lambda_func = [](<span class="type">int</span> x) &#123; <span class="comment">/* ... */</span> &#125;;</span><br><span class="line"><span class="built_in">void</span> (*func_ptr)(<span class="type">int</span>) = a_lambda_func;</span><br><span class="line"><span class="built_in">func_ptr</span>(<span class="number">4</span>); <span class="comment">// calls the lambda</span></span><br></pre></td></tr></table></figure>
<p>但是<mark>带捕获的lambda是不能够作为函数指针进行参数传递</mark>。</p>
<h3 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h3>
<p><a href="https://www.cnblogs.com/DswCnblog/p/5629165.html">https://www.cnblogs.com/DswCnblog/p/5629165.html</a></p>
<p><a href="https://www.cnblogs.com/jimodetiantang/p/9016826.html">https://www.cnblogs.com/jimodetiantang/p/9016826.html</a></p>
<p>关于捕获和不捕获的lambda转换汇编代码分析</p>
<p><a href="https://blog.csdn.net/qq_36419971/article/details/117396419">https://blog.csdn.net/qq_36419971/article/details/117396419</a></p>
]]></content>
      <categories>
        <category>cpp</category>
        <category>cpp语法</category>
      </categories>
      <tags>
        <tag>cpp语法</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树基础详解</title>
    <url>/posts/99d9a14f/</url>
    <content><![CDATA[<p>删除树中的节点时，删除过程将按照后序遍历的顺序进行。 也就是说，当你删除一个节点时，你将首先删除它的左节点和它的右边的节点，然后再删除节点本身。另外，后序在数学表达中被广泛使用。 编写程序来解析后缀表示法更为容易。</p>
<p><img data-src="http://hz-picbed-xxh.oss-cn-hangzhou.aliyuncs.com/img-bed/mathematical_expression.png" alt="img" /></p>
<p>可以使用中序遍历轻松找出原始表达式。 但是程序处理这个表达式时并不容易，因为你必须检查操作的优先级。</p>
<p>如果你想对这棵树进行后序遍历，使用栈来处理表达式会变得更加容易。 每遇到一个操作符，就可以从栈中弹出栈顶的两个元素，计算并将结果返回到栈中。</p>
<h2 id="遍历"><a class="markdownIt-Anchor" href="#遍历"></a> 遍历</h2>
<h3 id="x序遍历"><a class="markdownIt-Anchor" href="#x序遍历"></a> X序遍历</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">preorder</span><span class="params">(TreeNode* cur,vector&lt;<span class="type">int</span>&gt;&amp; res)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(cur==<span class="literal">nullptr</span>)<span class="keyword">return</span>;</span><br><span class="line">    res.<span class="built_in">push_back</span>(cur-&gt;val); <span class="comment">//不同位置表示不同序的遍历</span></span><br><span class="line">    <span class="built_in">preorder</span>(cur-&gt;left,res);</span><br><span class="line">    <span class="built_in">preorder</span>(cur-&gt;right,res);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="层次遍历"><a class="markdownIt-Anchor" href="#层次遍历"></a> 层次遍历</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">levelOrder</span>(TreeNode* root) &#123;</span><br><span class="line">    vector&lt;TreeNode*&gt;q; vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;res; q.<span class="built_in">push_back</span>(root); <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(cnt&lt;q.<span class="built_in">size</span>())&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt;tmp;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=cnt;i&lt;q.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(q[i]!=<span class="literal">nullptr</span>)tmp.<span class="built_in">push_back</span>(q[i]-&gt;val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(tmp.<span class="built_in">size</span>())res.<span class="built_in">push_back</span>(tmp);</span><br><span class="line">        <span class="type">int</span> bound = q.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(cnt;cnt&lt;bound;cnt++)<span class="keyword">if</span>(q[cnt]!=<span class="literal">nullptr</span>)q.<span class="built_in">push_back</span>(q[cnt]-&gt;left),q.<span class="built_in">push_back</span>(q[cnt]-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="自顶向下"><a class="markdownIt-Anchor" href="#自顶向下"></a> 自顶向下</h3>
<p>“自顶向下” 意味着在每个递归层级，我们将首先访问节点来计算一些值，并在递归调用函数时将这些值传递到子节点。 所以 “自顶向下” 的解决方案可以被认为是一种前序遍历。 具体来说，递归函数 top_down(root, params) 的原理是这样的：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> specific value <span class="keyword">for</span> null node</span><br><span class="line">update the answer <span class="keyword">if</span> needed                      <span class="comment">// answer &lt;-- params</span></span><br><span class="line">left_ans = <span class="built_in">top_down</span>(root.left, left_params)		<span class="comment">// left_params &lt;-- root.val, params</span></span><br><span class="line">right_ans = <span class="built_in">top_down</span>(root.right, right_params)	<span class="comment">// right_params &lt;-- root.val, params</span></span><br><span class="line"><span class="keyword">return</span> the answer <span class="keyword">if</span> needed                      <span class="comment">// answer &lt;-- left_ans, right_ans</span></span><br></pre></td></tr></table></figure>
<h3 id="自底向上"><a class="markdownIt-Anchor" href="#自底向上"></a> 自底向上</h3>
<p>“自底向上” 是另一种递归方法。 在每个递归层次上，我们首先对所有子节点递归地调用函数，然后根据返回值和根节点本身的值得到答案。 这个过程可以看作是后序遍历的一种。 通常， “自底向上” 的递归函数 bottom_up(root) 为如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> specific value <span class="keyword">for</span> null node</span><br><span class="line">left_ans = <span class="built_in">bottom_up</span>(root.left)			<span class="comment">// call function recursively for left child</span></span><br><span class="line">right_ans = <span class="built_in">bottom_up</span>(root.right)		<span class="comment">// call function recursively for right child</span></span><br><span class="line"><span class="keyword">return</span> answers                           <span class="comment">// answer &lt;-- left_ans, right_ans, root.val</span></span><br></pre></td></tr></table></figure>
<h4 id="求树的最大深度"><a class="markdownIt-Anchor" href="#求树的最大深度"></a> 求树的最大深度</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> answer=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">topDown</span><span class="params">(TreeNode* cur,<span class="type">int</span> level)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(cur==<span class="literal">nullptr</span>)<span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">topDown</span>(cur-&gt;left,level+<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">topDown</span>(cur-&gt;right,level+<span class="number">1</span>);</span><br><span class="line">    answer = <span class="built_in">max</span>(answer,level);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bottomUp</span><span class="params">(TreeNode* cur)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(cur==<span class="literal">nullptr</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>(<span class="built_in">bottomUp</span>(cur-&gt;left),<span class="built_in">bottomUp</span>(cur-&gt;right))+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
        <category>基础算法</category>
        <category>二叉树</category>
      </categories>
      <tags>
        <tag>基础算法</tag>
        <tag>encryptalg</tag>
      </tags>
  </entry>
  <entry>
    <title>unordered_map set自定义对象的hash</title>
    <url>/posts/f17b9616/</url>
    <content><![CDATA[<p><code>unordered_map/set</code>使用hash进行存储，因此存储自定义对象前，必须：</p>
<ol>
<li><code>hash</code>告知此容器如何生成hash值，</li>
<li><code>equal_to</code>告知容器当出现hash冲突时，如何区分hash值相同的不同对象。</li>
</ol>
<p><strong>具体有4种方案</strong>：</p>
<ol>
<li>定义两个函数对象ObjectHash，以及ObjectCmp，分别实现对Object进行hash，以及比较两个对象是否相同。</li>
<li>定义两个普通的函数，实现hash以及对象比较，与<mark>1</mark>不同的是普通函数在构建<code>unordered_map/set</code>时，需要decltype来减少声明它的类型（或手动指定，<code>std::function &lt;size_t(const Object&amp;)&gt;</code>说明hash类型，<code>std::function &lt;bool(const Object&amp;, const Object&amp;)&gt;</code>说明比较cmp类型</li>
<li>定义两个lambda表达式（仿函数），与2类似</li>
<li>对Object对象进行模板特化定制</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"># unordered_set的声明</span><br><span class="line"><span class="keyword">template</span>&lt;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Key</span>, <span class="comment">//类型</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Hash</span> = std::hash&lt;Key&gt;,</span><br><span class="line">    <span class="keyword">class</span> KeyEqual = std::equal_to&lt;Key&gt;,</span><br><span class="line">    <span class="keyword">class</span> Allocator = std::allocator&lt;Key&gt;</span><br><span class="line">&gt; <span class="keyword">class</span> unordered_set;</span><br><span class="line"></span><br><span class="line">#unordered_map的声明</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">Key</span>, <span class="comment">//key的类型</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Ty</span>, <span class="comment">//val的类型</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Hash</span> = std::hash&lt;Key&gt;,</span><br><span class="line">    <span class="keyword">class</span> Pred = std::equal_to&lt;Key&gt;,</span><br><span class="line">    <span class="keyword">class</span> Alloc = std::allocator&lt;std::pair&lt;<span class="type">const</span> Key, Ty&gt; &gt; &gt;</span><br><span class="line">    <span class="keyword">class</span> unordered_map;</span><br><span class="line">&gt; <span class="keyword">class</span> <span class="title class_">unordered_map</span></span><br></pre></td></tr></table></figure>
<h3 id="示例"><a class="markdownIt-Anchor" href="#示例"></a> 示例</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"># 自定义<span class="keyword">struct</span>的类型</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Object</span>&#123;</span><br><span class="line">    string name;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="定义两个函数对象"><a class="markdownIt-Anchor" href="#定义两个函数对象"></a> 定义两个函数对象</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ObjectHash</span>&#123;</span><br><span class="line">	<span class="function"><span class="type">size_t</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> Object&amp; rhs)</span><span class="type">const</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">hash</span>&lt;string&gt;()(rhs.name) ^ <span class="built_in">hash</span>&lt;<span class="type">int</span>&gt;()(rhs.val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ObjectCmp</span>&#123;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> Object&amp; lhs,<span class="type">const</span> Object&amp; rhs)</span><span class="type">const</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> lhs.name == rhs.name &amp;&amp; lhs.val ==rhs.val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">unordered_set&lt;Object,ObjectHash,ObjectCmp&gt; objects;</span><br></pre></td></tr></table></figure>
<h4 id="定义两个普通函数重写hash和cmp"><a class="markdownIt-Anchor" href="#定义两个普通函数重写hash和cmp"></a> 定义两个普通函数，重写hash和cmp</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">ObjectHash</span><span class="params">(<span class="type">const</span> Object&amp; rhs)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">hash</span>&lt;string&gt;()(rhs.name) ^ <span class="built_in">hash</span>&lt;<span class="type">int</span>&gt;()(rhs.val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ObjectCmp</span><span class="params">(<span class="type">const</span> Object&amp; lhs, <span class="type">const</span> Record&amp; rhs)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> lhs.name == rhs.name &amp;&amp; lhs.val == rhs.val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">unordered_set&lt;Object , <span class="title">decltype</span><span class="params">(&amp;ObjectHash)</span>, <span class="title">decltype</span><span class="params">(&amp;ObjectCmp)</span>&gt; <span class="title">objects</span><span class="params">(<span class="number">0</span>,ObjectHash,ObjectCmp)</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="使用lambda函数"><a class="markdownIt-Anchor" href="#使用lambda函数"></a> 使用lambda函数</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> ObjectHash = [](<span class="type">const</span> Object&amp; rhs)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">hash</span>&lt;string&gt;(rhs.name) ^ <span class="built_in">hash</span>&lt;<span class="type">int</span>&gt;()(rhs.val);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> ObjectCmp = [](<span class="type">const</span> Object&amp; lhs, <span class="type">const</span> Object&amp; rhs)&#123;</span><br><span class="line">    <span class="keyword">return</span> lhs.name==rhs.name &amp;&amp; lhs.val==rhs.val;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">unordered_set&lt;Object, <span class="keyword">decltype</span>(&amp;ObjectHash),<span class="keyword">decltype</span>(&amp;ObjectCmp)&gt;<span class="built_in">object</span>(<span class="number">0</span>,ObjectHash,ObjectCmp);</span><br></pre></td></tr></table></figure>
<h4 id="模板定制重写"><a class="markdownIt-Anchor" href="#模板定制重写"></a> 模板定制重写</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//注意namespace ，必要时可以指定namespace std&#123;&#125;</span></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">hash</span>&lt;Object&gt;&#123;</span><br><span class="line">    <span class="function"><span class="type">size_t</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> Object&amp; rhs)</span><span class="type">const</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">hash</span>&lt;string&gt;()(rhs.name) ^ <span class="built_in">hash</span>&lt;<span class="type">int</span>&gt;()(rhs.val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">equal_to</span>&lt;Object&gt;&#123;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> Object&amp; lhs,<span class="type">const</span> Object&amp; rhs)</span><span class="type">const</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> lhs.name == rhs.name &amp;&amp; lhs.val == rhs.val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">unordered_set&lt;Object&gt; objects;</span><br></pre></td></tr></table></figure>
<h3 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h3>
<p><a href="https://blog.csdn.net/lpstudy/article/details/54345050">https://blog.csdn.net/lpstudy/article/details/54345050</a></p>
<p><a href="https://blog.csdn.net/y109y/article/details/82669620">https://blog.csdn.net/y109y/article/details/82669620</a></p>
]]></content>
      <categories>
        <category>cpp</category>
        <category>cpp语法</category>
      </categories>
      <tags>
        <tag>cpp语法</tag>
      </tags>
  </entry>
  <entry>
    <title>常用stl算法总结</title>
    <url>/posts/603c8f61/</url>
    <content><![CDATA[<h2 id="容器"><a class="markdownIt-Anchor" href="#容器"></a> 容器</h2>
<h3 id="vector"><a class="markdownIt-Anchor" href="#vector"></a> vector</h3>
<h4 id="基本操作"><a class="markdownIt-Anchor" href="#基本操作"></a> 基本操作</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">push_back</span><span class="params">()</span></span>;<span class="function"><span class="type">void</span>  <span class="title">emplace_back</span><span class="params">()</span></span>; <span class="comment">//尾端插入</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pop_back</span><span class="params">()</span></span>; <span class="comment">//尾端弹出</span></span><br><span class="line"><span class="function">iterator <span class="title">front</span><span class="params">()</span></span>; <span class="function">iterator <span class="title">back</span><span class="params">()</span></span>;<span class="comment">//返回首尾迭代器</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span> <span class="comment">//清空</span></span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="comment">//判空</span></span></span><br><span class="line"><span class="function">iterator <span class="title">erase</span><span class="params">(itereator loc)</span></span>;<span class="comment">//删除loc所指的元素，返回下一元素的迭代器</span></span><br><span class="line"><span class="function">iterator <span class="title">erase</span><span class="params">(iterator start,iterator end)</span></span>;删除[start,end)之间的元素，返回end元素的迭代器</span><br><span class="line"><span class="function">iterator <span class="title">insert</span><span class="params">(iterator loc,val)</span></span>;<span class="comment">//在loc位置插入一个value元素，并且返回其迭代器，原loc及以后的元素后移</span></span><br><span class="line"><span class="comment">//vector&lt;int&gt;::iterator it=q.insert(q.begin()+2,num);</span></span><br></pre></td></tr></table></figure>
<h4 id="一维初始化"><a class="markdownIt-Anchor" href="#一维初始化"></a> 一维初始化</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;T&gt; v1 <span class="comment">//空的vector，执行默认初始化</span></span><br><span class="line"><span class="function">vector&lt;T&gt; <span class="title">v2</span><span class="params">(v1)</span> <span class="comment">//v2包含有v1所有元素的副本</span></span></span><br><span class="line"><span class="function">vector&lt;T&gt; <span class="title">v2</span><span class="params">(v1.begin(),v1.end())</span><span class="comment">//包含指定范围的数据</span></span></span><br><span class="line"><span class="function">vector&lt;T&gt; v2</span>=v1 <span class="comment">//等价于上条语句</span></span><br><span class="line"><span class="function">vector&lt;T&gt; <span class="title">v3</span><span class="params">(n,val)</span> <span class="comment">//包含了n个重复元素，每个元素的值都是val</span></span></span><br><span class="line"><span class="function">vector&lt;T&gt; <span class="title">v4</span><span class="params">(n)</span> <span class="comment">//包含n个默认初始化的对象 </span></span></span><br><span class="line"><span class="function">vector&lt;T&gt; v4</span>&#123;a,b,c...&#125; <span class="comment">//包含了初始值个数的元素，并被初始化</span></span><br><span class="line">vector&lt;T&gt; v5=&#123;a,b,c...&#125; <span class="comment">//等价于上条语句</span></span><br></pre></td></tr></table></figure>
<h4 id="二维数组初始化"><a class="markdownIt-Anchor" href="#二维数组初始化"></a> 二维数组初始化</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">vec</span>(row, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; (col,<span class="number">1</span>));</span><br></pre></td></tr></table></figure>
<h3 id="list"><a class="markdownIt-Anchor" href="#list"></a> List</h3>
<h4 id="初始化"><a class="markdownIt-Anchor" href="#初始化"></a> 初始化</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">list&lt;<span class="type">int</span>&gt;<span class="built_in">a</span>(<span class="number">10</span>,<span class="number">1</span>)<span class="comment">//10大小初始值1</span></span><br><span class="line">list&lt;<span class="type">int</span>&gt;<span class="built_in">a</span>(n,n+<span class="number">5</span>)<span class="comment">//使用数组初始化</span></span><br></pre></td></tr></table></figure>
<h4 id="基本操作-2"><a class="markdownIt-Anchor" href="#基本操作-2"></a> 基本操作</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">list.<span class="built_in">resize</span>()<span class="comment">//改变大小</span></span><br><span class="line">list.<span class="built_in">push_front</span>();</span><br><span class="line">list.<span class="built_in">push_back</span>()</span><br><span class="line">list.<span class="built_in">insert</span>(&amp;it,val);</span><br><span class="line">list.<span class="built_in">insert</span>(&amp;it,<span class="type">int</span> n,val)<span class="comment">//&amp;it位置插入n个val</span></span><br><span class="line">list.<span class="built_in">insert</span>(&amp;it,begin,last)<span class="comment">//&amp;it位置插入begin~end</span></span><br><span class="line">list.<span class="built_in">pop_front</span>()</span><br><span class="line">list.<span class="built_in">pop_back</span>()</span><br><span class="line">list.<span class="built_in">erase</span>(&amp;it)</span><br><span class="line">list.<span class="built_in">erase</span>(begin,end)</span><br><span class="line">list.<span class="built_in">clear</span>()<span class="comment">//清空</span></span><br><span class="line"></span><br><span class="line">list.<span class="built_in">assign</span>(<span class="type">int</span> nSize,val)<span class="comment">//类似数组初始化</span></span><br><span class="line"><span class="built_in">swap</span>(list&amp;,list&amp;)<span class="comment">//交换</span></span><br><span class="line">list.<span class="built_in">merge</span>();<span class="comment">//合并，默认升序</span></span><br><span class="line">list.<span class="built_in">splice</span>(&amp;it,list&amp;) <span class="comment">//&amp;it位置接入list</span></span><br><span class="line">list.<span class="built_in">unique</span>()<span class="comment">//去重</span></span><br><span class="line">list.<span class="built_in">sort</span>()</span><br><span class="line">list.<span class="built_in">remove_if</span>()<span class="comment">//条件去重</span></span><br><span class="line">list.<span class="built_in">reverse</span>()</span><br></pre></td></tr></table></figure>
<h3 id="stack"><a class="markdownIt-Anchor" href="#stack"></a> stack</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span>	栈为空返回<span class="literal">true</span>,否则返回<span class="literal">false</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">()</span>	删除栈顶元素，即出栈</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">const</span> TYPE &amp;val)</span>	将新元素val进栈，使其成为栈顶元素</span></span><br><span class="line"><span class="function"><span class="title">top</span><span class="params">()</span> 查看当前栈顶元素</span></span><br><span class="line"><span class="function"><span class="title">size</span><span class="params">()</span> 返回元素数目</span></span><br></pre></td></tr></table></figure>
<h3 id="queue"><a class="markdownIt-Anchor" href="#queue"></a> queue</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span>	队列为空返回<span class="literal">true</span>,否则返回<span class="literal">false</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">()</span>	删除队列头元素，即出栈</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">const</span> TYPE &amp;val)</span>	将新元素val进队尾</span></span><br><span class="line"><span class="function"><span class="title">top</span><span class="params">()</span> 查看当前栈顶元素</span></span><br><span class="line"><span class="function"><span class="title">size</span><span class="params">()</span> 返回元素数目</span></span><br></pre></td></tr></table></figure>
<h3 id="deque"><a class="markdownIt-Anchor" href="#deque"></a> deque</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">assign</span>()	设置双向队列的值</span><br><span class="line"><span class="built_in">at</span>()	返回指定的元素</span><br><span class="line"><span class="built_in">back</span>()	返回最后一个元素</span><br><span class="line"><span class="built_in">begin</span>()	返回指向第一个元素的迭代器</span><br><span class="line"><span class="built_in">clear</span>()	删除所有元素</span><br><span class="line"><span class="built_in">empty</span>()	返回真如果双向队列为空</span><br><span class="line"><span class="built_in">end</span>()	返回指向尾部的迭代器</span><br><span class="line"><span class="built_in">erase</span>()	删除一个元素</span><br><span class="line"><span class="built_in">front</span>()	返回第一个元素</span><br><span class="line"><span class="built_in">get_allocator</span>()	返回双向队列的配置器</span><br><span class="line"><span class="built_in">insert</span>()	插入一个元素到双向队列中</span><br><span class="line"><span class="built_in">max_size</span>()	返回双向队列能容纳的最大元素个数</span><br><span class="line"><span class="built_in">pop_back</span>()	删除尾部的元素</span><br><span class="line"><span class="built_in">pop_front</span>()	删除头部的元素</span><br><span class="line"><span class="built_in">push_back</span>()	在尾部加入一个元素</span><br><span class="line"><span class="built_in">push_front</span>()	在头部加入一个元素</span><br><span class="line"><span class="built_in">rbegin</span>()	返回指向尾部的逆向迭代器</span><br><span class="line"><span class="built_in">rend</span>()	返回指向头部的逆向迭代器</span><br><span class="line"><span class="built_in">resize</span>()	改变双向队列的大小</span><br><span class="line"><span class="built_in">size</span>()	返回双向队列中元素的个数</span><br><span class="line"><span class="built_in">swap</span>()	和另一个双向队列交换元素</span><br></pre></td></tr></table></figure>
<h3 id="优先队列-重定义"><a class="markdownIt-Anchor" href="#优先队列-重定义"></a> 优先队列-重定义</h3>
<ol>
<li>自定义类型重载，使用仿函数中的比较函数</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">    <span class="type">int</span> x, y;</span><br><span class="line">    <span class="built_in">Node</span>( <span class="type">int</span> a= <span class="number">0</span>, <span class="type">int</span> b= <span class="number">0</span> ):</span><br><span class="line">        <span class="built_in">x</span>(a), <span class="built_in">y</span>(b) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>&gt;( Node a, Node b )&#123;<span class="comment">//返回true，a的优先级大于b</span></span><br><span class="line">    <span class="comment">//x大的排在队前部；x相同时，y大的排在队前部</span></span><br><span class="line">    <span class="keyword">if</span>( a.x== b.x ) <span class="keyword">return</span> a.y&gt; b.y;</span><br><span class="line">    <span class="keyword">return</span> a.x&gt; b.x; </span><br><span class="line">&#125;</span><br><span class="line">priority_queue&lt;Node,vector&lt;Node&gt;,greater&lt;Node&gt; &gt; q;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ol start="2">
<li>自定义函数对象()</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">cmp</span>&#123;</span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(NODE n1,NODE n2)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> n1.val&gt;n2.val; <span class="comment">//小根堆 </span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">priority_queue&lt;NODE,vector&lt;NODE&gt;,cmp&gt;q;</span><br></pre></td></tr></table></figure>
<h3 id="set"><a class="markdownIt-Anchor" href="#set"></a> Set</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">begin</span>()：返回指向第一个元素的迭代器</span><br><span class="line"><span class="built_in">clear</span>()：清除所有元素</span><br><span class="line"><span class="built_in">count</span>()：返回某个值元素的个数</span><br><span class="line"><span class="built_in">empty</span>()：如果集合为空，返回<span class="function"><span class="literal">true</span></span></span><br><span class="line"><span class="function"><span class="title">end</span><span class="params">()</span>：返回指向最后一个元素的迭代器</span></span><br><span class="line"><span class="function"><span class="title">equal_range</span><span class="params">()</span>：返回集合中与给定值相等的上下限的两个迭代器</span></span><br><span class="line"><span class="function"><span class="title">erase</span><span class="params">()</span>：删除集合中的元素</span></span><br><span class="line"><span class="function"><span class="title">find</span><span class="params">()</span>：返回一个指向被查找到元素的迭代器</span></span><br><span class="line"><span class="function"><span class="title">get_allocator</span><span class="params">()</span>：返回集合的分配器</span></span><br><span class="line"><span class="function"><span class="title">insert</span><span class="params">()</span>：在集合中插入元素</span></span><br><span class="line"><span class="function"><span class="title">lower_bound</span><span class="params">()</span>：返回指向大于（或等于）某值的第一个元素的迭代器</span></span><br><span class="line"><span class="function"><span class="title">key_comp</span><span class="params">()</span>：返回一个用于元素间值比较的函数</span></span><br><span class="line"><span class="function"><span class="title">max_size</span><span class="params">()</span>：返回集合能容纳的元素的最大限值</span></span><br><span class="line"><span class="function"><span class="title">rbegin</span><span class="params">()</span>：返回指向集合中最后一个元素的反向迭代器</span></span><br><span class="line"><span class="function"><span class="title">rend</span><span class="params">()</span>：返回指向集合中第一个元素的反向迭代器</span></span><br><span class="line"><span class="function"><span class="title">size</span><span class="params">()</span>：集合中元素的数目</span></span><br><span class="line"><span class="function"><span class="title">swap</span><span class="params">()</span>：交换两个集合变量</span></span><br><span class="line"><span class="function"><span class="title">upper_bound</span><span class="params">()</span>：返回大于某个值元素的迭代器</span></span><br><span class="line"><span class="function"><span class="title">value_comp</span><span class="params">()</span>：返回一个用于比较元素间的值的函数</span></span><br></pre></td></tr></table></figure>
<h3 id="map"><a class="markdownIt-Anchor" href="#map"></a> Map</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">map.<span class="built_in">size</span>()/<span class="built_in">clear</span>()/<span class="built_in">empty</span>()</span><br><span class="line"><span class="function">iterator <span class="title">lower_bound</span><span class="params">(key)</span><span class="comment">//返回指向键值&gt;=key的第一个元素upper_bound 键值&gt;key</span></span></span><br><span class="line"><span class="function">map.<span class="title">key_comp</span><span class="params">()</span><span class="comment">//返回比较key大小</span></span></span><br><span class="line"><span class="function">map.<span class="title">value_comp</span><span class="params">()</span><span class="comment">//返回比较value大小</span></span></span><br><span class="line"><span class="function">itearator <span class="title">find</span><span class="params">(key)</span><span class="comment">//返回键值为key的迭代器，未找到则返回end()</span></span></span><br><span class="line"><span class="function">pair&lt;itaratoe,<span class="type">bool</span>&gt; <span class="title">insert</span><span class="params">(pair&lt;key,value&gt;)</span>插入键值对，返回pair&lt;迭代器，成功与否&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="stl内置算法"><a class="markdownIt-Anchor" href="#stl内置算法"></a> STL内置算法</h2>
<h3 id="fill"><a class="markdownIt-Anchor" href="#fill"></a> fill</h3>
<h4 id="给一维数组赋值"><a class="markdownIt-Anchor" href="#给一维数组赋值"></a> 给一维数组赋值</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> f[MAXN];</span><br><span class="line"><span class="built_in">fill</span>(f,f+MAXN,num);</span><br></pre></td></tr></table></figure>
<h4 id="给二维数组赋值"><a class="markdownIt-Anchor" href="#给二维数组赋值"></a> 给二维数组赋值</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> f[MAXN][MAXN];</span><br><span class="line"><span class="built_in">fill</span>(f[<span class="number">0</span>],f[<span class="number">0</span>]+MAXN*MAXN,num);</span><br></pre></td></tr></table></figure>
<h3 id=""><a class="markdownIt-Anchor" href="#"></a> </h3>
]]></content>
      <categories>
        <category>算法</category>
        <category>基础算法</category>
        <category>stl</category>
      </categories>
      <tags>
        <tag>stl</tag>
      </tags>
  </entry>
  <entry>
    <title>二分算法详解</title>
    <url>/posts/99d9a14f/</url>
    <content><![CDATA[<h3 id="常规二分写法"><a class="markdownIt-Anchor" href="#常规二分写法"></a> 常规二分写法</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(l&lt;=r)&#123;</span><br><span class="line">    <span class="type">int</span> mid = l+ (r-l&gt;&gt;<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(mid = target) <span class="keyword">return</span> mid;</span><br><span class="line">    <span class="keyword">if</span>(mid&lt;target)l = mid+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> r = mid<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br></pre></td></tr></table></figure>
<p>每次搜索的区间是[l,r]，因此l和r均不包含mid</p>
<h3 id="查找target的右边界"><a class="markdownIt-Anchor" href="#查找target的右边界"></a> 查找&lt;=target的右边界</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line">    <span class="type">int</span> mid = l + (r-l&gt;&gt;<span class="number">1</span>)+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(mid&lt;=target) l = mid;</span><br><span class="line">    <span class="keyword">else</span> r = mid<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> l;</span><br></pre></td></tr></table></figure>
<ol>
<li>收缩区间，查找右边界指在&lt;=target的区间中取最大的一个，即&gt;target的区间舍去，<code>r = mid-1</code>，每次搜索的区间是(left,right]</li>
<li>因为<code>mid = l+(r-l&gt;&gt;1)</code>总是落在(l+r)/2的右侧，<code>l=mid</code>可以保证<code>l</code>始终在左区间的右边界上</li>
<li>当终止条件<code>l==r</code>时，r右边的区域为&gt;target，l为&lt;=target的区域的右边界。</li>
</ol>
<h4 id="一个其他版本的查找右侧边界代码"><a class="markdownIt-Anchor" href="#一个其他版本的查找右侧边界代码"></a> 一个其他版本的查找右侧边界代码</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line">    <span class="type">int</span> mid = l+ (r-l&gt;&gt;<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(mid&gt;target) r = mid;</span><br><span class="line">    <span class="keyword">else</span> l = mid+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> l<span class="number">-1</span>;</span><br></pre></td></tr></table></figure>
<p>其实就是<mark>查找 &gt;target的左边界</mark>  版本，返回left-1即<mark>为&lt;=tareget的右边界</mark></p>
<h3 id="查找target的左边界"><a class="markdownIt-Anchor" href="#查找target的左边界"></a> 查找&gt;=target的左边界</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line">    <span class="type">int</span> mid = l+(r-l)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(mid&gt;=target)r = mid;</span><br><span class="line">    <span class="keyword">else</span> l = mid+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> l;</span><br></pre></td></tr></table></figure>
<ol>
<li>收缩区间，查找左边界指在&gt;=target的区间中取最小的一个，即&lt;target的区间舍去，<code>l = mid+1</code>，每次搜索的区间是[left,right)</li>
<li>因为mid = l+(r-l&gt;&gt;1)总是落在(l+r)/2的左侧，<code>r = mid</code>可以保证<code>r</code>始终落在右区间的左边界上</li>
<li>当终止条件<code>l==r</code>时，l左侧的部分全部为&lt;target，r为&lt;=target的区域的右边界</li>
</ol>
<h3 id="题目"><a class="markdownIt-Anchor" href="#题目"></a> 题目</h3>
<h4 id="搜索旋转排序数组"><a class="markdownIt-Anchor" href="#搜索旋转排序数组"></a> <a href="https://leetcode-cn.com/problems/search-in-rotated-sorted-array/">搜索旋转排序数组</a></h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">search</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> l  = <span class="number">0</span>,r = nums.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;=r)&#123;</span><br><span class="line">            <span class="type">int</span> mid = l+(r-l&gt;&gt;<span class="number">1</span>);</span><br><span class="line">            <span class="type">int</span> num = nums[mid],numl = nums[l],numr = nums[r];</span><br><span class="line">            <span class="keyword">if</span>(num==target)<span class="keyword">return</span> mid;</span><br><span class="line">            <span class="keyword">if</span>(numl&lt;=num)&#123; <span class="comment">//左边有序</span></span><br><span class="line">                <span class="keyword">if</span>(target&lt;num &amp;&amp; target&gt;=numl)r = mid<span class="number">-1</span>; <span class="comment">//在左边</span></span><br><span class="line">                <span class="keyword">else</span> l = mid+<span class="number">1</span>; <span class="comment">//在右边</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123; <span class="comment">//右边有序</span></span><br><span class="line">                <span class="keyword">if</span>(target&gt;num &amp;&amp; target&lt;=numr ) l = mid+<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> r = mid<span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="寻找峰值"><a class="markdownIt-Anchor" href="#寻找峰值"></a> <a href="https://leetcode-cn.com/problems/find-peak-element/">寻找峰值</a></h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findPeakElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> l = <span class="number">0</span>,r = nums.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line">            <span class="type">int</span> mid = l + (r-l&gt;&gt;<span class="number">1</span>);</span><br><span class="line">            <span class="type">int</span> prev,next;</span><br><span class="line">            <span class="keyword">if</span>(mid<span class="number">-1</span>&gt;=<span class="number">0</span>)prev = nums[mid<span class="number">-1</span>];<span class="keyword">else</span> prev = INT_MIN;</span><br><span class="line">            <span class="keyword">if</span>(mid+<span class="number">1</span>&lt;=nums.<span class="built_in">size</span>()<span class="number">-1</span>)next = nums[mid+<span class="number">1</span>];<span class="keyword">else</span> next = INT_MIN;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid]&gt;prev&amp;&amp;nums[mid]&gt;next)<span class="keyword">return</span> mid;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid]&gt;=prev) l = mid+<span class="number">1</span>; <span class="keyword">else</span> r = mid<span class="number">-1</span>; <span class="comment">//等号给INT_MIN 上坡必有顶</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="在排序数组中查找元素的第一个和最后一个位置"><a class="markdownIt-Anchor" href="#在排序数组中查找元素的第一个和最后一个位置"></a> <a href="https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/">在排序数组中查找元素的第一个和最后一个位置</a></h4>
<p>lower_bound(start,end,target) 返回&gt;=target的第一个位置地址</p>
<p>upper_bound(start,end,target) 返回&gt;target的第一个位置地址</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">searchRange</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//第一种方法使用双二分法，注意边界</span></span><br><span class="line">        <span class="type">int</span> l = <span class="number">0</span>, r = nums.<span class="built_in">size</span>()<span class="number">-1</span>;<span class="type">int</span> left=<span class="number">-1</span>,right = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;r)&#123; <span class="comment">//&gt;=target的左边界</span></span><br><span class="line">            <span class="type">int</span> mid = l+(r-l&gt;&gt;<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span>(nums[mid]&gt;=target)r = mid;<span class="keyword">else</span> l = mid+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(nums.<span class="built_in">size</span>()&gt;<span class="number">0</span>) <span class="keyword">if</span>( nums[l]!=target)left = <span class="number">-1</span>;<span class="keyword">else</span> left=l;</span><br><span class="line">        l =<span class="number">0</span>;r = nums.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;r)&#123;<span class="comment">//&lt;=target的右边界</span></span><br><span class="line">            <span class="type">int</span> mid = l+(r-l&gt;&gt;<span class="number">1</span>)+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid]&lt;=target)l = mid;<span class="keyword">else</span> r = mid<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(nums.<span class="built_in">size</span>()&gt;<span class="number">0</span> )<span class="keyword">if</span>(nums[l]!=target)right = <span class="number">-1</span>;<span class="keyword">else</span> right=l;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt;res; res.<span class="built_in">push_back</span>(left);res.<span class="built_in">push_back</span>(right);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//第二种方法使用STL，注意边界</span></span><br><span class="line">        left = <span class="built_in">lower_bound</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>(),target)-nums.<span class="built_in">begin</span>();</span><br><span class="line">        right = <span class="built_in">upper_bound</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>(),target)-nums.<span class="built_in">begin</span>()<span class="number">-1</span>;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt;res2;</span><br><span class="line">        <span class="keyword">if</span>(nums.<span class="built_in">size</span>()&gt;<span class="number">0</span> &amp;&amp; left&gt;=<span class="number">0</span> &amp;&amp;left &lt;nums.<span class="built_in">size</span>() &amp;&amp; nums[left]==target)res2.<span class="built_in">push_back</span>(left);<span class="keyword">else</span> res2.<span class="built_in">push_back</span>(<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">if</span>(nums.<span class="built_in">size</span>()&gt;<span class="number">0</span> &amp;&amp; right &gt;=<span class="number">0</span> &amp;&amp; right &lt; nums.<span class="built_in">size</span>() &amp;&amp;nums[right]==target)res2.<span class="built_in">push_back</span>(right);<span class="keyword">else</span> res2.<span class="built_in">push_back</span>(<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">return</span> res2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="找到-k-个最接近的元素"><a class="markdownIt-Anchor" href="#找到-k-个最接近的元素"></a> <a href="https://leetcode-cn.com/problems/find-k-closest-elements/">找到 K 个最接近的元素</a></h4>
<h4 id="方法一二分查找双指针"><a class="markdownIt-Anchor" href="#方法一二分查找双指针"></a> 方法一：二分查找+双指针</h4>
<p>首先找到&lt;=target的右边界，确定pos之后</p>
<p>令left=pos-k,right=pos+k，则我们需要的数字必定在这里面。分成三类讨论</p>
<ol>
<li>left&lt;0 left++</li>
<li>right&gt;=arr.size() right–;</li>
<li>在数组范围内，判断x与arr[left]和arr[right]的距离，left近就right–否则left++</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">findClosestElements</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr, <span class="type">int</span> k, <span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> l = <span class="number">0</span>,r = arr.<span class="built_in">size</span>()<span class="number">-1</span>;<span class="type">int</span> pos;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;r)&#123;<span class="comment">//&lt;=target 的右边界</span></span><br><span class="line">            <span class="type">int</span> mid = l+(r-l&gt;&gt;<span class="number">1</span>)+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(arr[mid]&lt;=x)l=mid;<span class="keyword">else</span> r=mid<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        pos = l;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt;res;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> left = pos-k,right=pos+k;</span><br><span class="line">        <span class="keyword">while</span>(right-left+<span class="number">1</span>&gt;k)&#123;</span><br><span class="line">            <span class="keyword">if</span>(left&lt;<span class="number">0</span>)&#123;left++;<span class="keyword">continue</span>;&#125;</span><br><span class="line">            <span class="keyword">if</span>(right&gt;=arr.<span class="built_in">size</span>())&#123;right--;<span class="keyword">continue</span>;&#125;</span><br><span class="line">            <span class="keyword">if</span>(arr[right]-x&gt;=x-arr[left])right--;<span class="keyword">else</span> left++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=left;i&lt;=right;i++)res.<span class="built_in">push_back</span>(arr[i]);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="方法二排序"><a class="markdownIt-Anchor" href="#方法二排序"></a> 方法二：排序</h4>
<p>将所有的数字和x的差值进行排序，取前k个。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//static int target;</span></span><br><span class="line">    <span class="comment">//static bool cmp(int &amp; a,int &amp; b)&#123;</span></span><br><span class="line">        <span class="comment">//if(abs(a-target)==abs(b-target))return a&lt;b;else return abs(a-target)&lt;abs(b-target);</span></span><br><span class="line">    <span class="comment">//&#125;</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">findClosestElements</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr, <span class="type">int</span> k, <span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(arr.<span class="built_in">begin</span>(),arr.<span class="built_in">end</span>(),[&amp;x](<span class="type">int</span> &amp;a,<span class="type">int</span> &amp;b)-&gt; <span class="type">bool</span>&#123;<span class="keyword">if</span>(<span class="built_in">abs</span>(a-x)==<span class="built_in">abs</span>(b-x))<span class="keyword">return</span> a&lt;b; <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">abs</span>(a-x)&lt;<span class="built_in">abs</span>(b-x);&#125;);     <span class="comment">//函数式编程，省去了引用static变量和初始化的过程</span></span><br><span class="line">        <span class="comment">//this-&gt;target = x;</span></span><br><span class="line">        <span class="comment">//sort(arr.begin(),arr.end(),cmp);</span></span><br><span class="line">        vector&lt;<span class="type">int</span>&gt;res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;k;i++)res.<span class="built_in">emplace_back</span>(arr[i]);</span><br><span class="line">        <span class="built_in">sort</span>(res.<span class="built_in">begin</span>(),res.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//int Solution::target = 0; //类型 所在类：：静态变量名 = 初始化值。</span></span><br></pre></td></tr></table></figure>
<h3 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h3>
<p><a href="https://www.cnblogs.com/kyoner/p/11080078.html">https://www.cnblogs.com/kyoner/p/11080078.html</a></p>
<p>《蓝书》P26</p>
]]></content>
      <categories>
        <category>算法</category>
        <category>基础算法</category>
        <category>二分</category>
      </categories>
      <tags>
        <tag>基础算法</tag>
        <tag>encryptalg</tag>
      </tags>
  </entry>
  <entry>
    <title>并查集模板</title>
    <url>/posts/83a4cde7/</url>
    <content><![CDATA[<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">UF</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> fa[<span class="number">65</span>],rank[<span class="number">65</span>];</span><br><span class="line">    <span class="built_in">UF</span>(<span class="type">int</span> n)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            fa[i]=i;</span><br><span class="line">            rank[i]=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x==fa[x]?x:(fa[x]=<span class="built_in">find</span>(fa[x]));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">uni</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> x=<span class="built_in">find</span>(i),y=<span class="built_in">find</span>(j);</span><br><span class="line">        <span class="keyword">if</span>(rank[x]&lt;=rank[y])fa[x]=y;</span><br><span class="line">        <span class="keyword">else</span> fa[y]=x;</span><br><span class="line">        <span class="keyword">if</span>(rank[x]==rank[y]&amp;&amp;x!=y)rank[y]++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
        <category>基础算法</category>
      </categories>
      <tags>
        <tag>基础算法</tag>
      </tags>
  </entry>
  <entry>
    <title>前缀和、差分与树状数组、线段树基础</title>
    <url>/posts/8f4b279/</url>
    <content><![CDATA[<p>ref：</p>
<p><a href="https://blog.csdn.net/bestsort/article/details/80796531">https://blog.csdn.net/bestsort/article/details/80796531</a></p>
<p><a href="https://www.luogu.com.cn/problem/solution/P3374">https://www.luogu.com.cn/problem/solution/P3374</a></p>
<h3 id="树状数组解决的问题"><a class="markdownIt-Anchor" href="#树状数组解决的问题"></a> 树状数组解决的问题</h3>
<ol>
<li>单点修改，求区间和</li>
<li>区间修改，求区间和</li>
</ol>
<h3 id="前缀和数组"><a class="markdownIt-Anchor" href="#前缀和数组"></a> 前缀和数组</h3>
<p>可以快速求出<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">[</mo><mi>l</mi><mo separator="true">,</mo><mi>r</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[l,r]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mclose">]</span></span></span></span> 范围内的和<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mi>u</mi><mi>m</mi><mo>=</mo><mi>s</mi><mi>u</mi><mi>m</mi><mi>a</mi><mi>r</mi><mi>r</mi><mo stretchy="false">[</mo><mi>r</mi><mo stretchy="false">]</mo><mo>−</mo><mi>s</mi><mi>u</mi><mi>m</mi><mi>a</mi><mi>r</mi><mi>r</mi><mo stretchy="false">[</mo><mi>l</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">sum = sumarr[r]-sumarr[l-1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span></p>
<p>缺点：无法支持单点修改和区间修改，因为每修改一次需要对后续所有的数组元素重新计算。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=nums.<span class="built_in">size</span>();i++)dp[i] = dp[i<span class="number">-1</span>]+nums[i<span class="number">-1</span>];</span><br><span class="line">cout&lt;&lt;dp[r]-dp[l<span class="number">-1</span>]&lt;&lt;endl;</span><br></pre></td></tr></table></figure>
<h4 id="二维矩阵-子矩阵的和"><a class="markdownIt-Anchor" href="#二维矩阵-子矩阵的和"></a> 二维矩阵-子矩阵的和</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,m,q;cin&gt;&gt;n&gt;&gt;m&gt;&gt;q;</span><br><span class="line">    <span class="built_in">fill</span>(f[<span class="number">0</span>],f[<span class="number">0</span>]+<span class="number">1010</span>*<span class="number">1010</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;j++)&#123;</span><br><span class="line">            <span class="type">int</span> num;cin&gt;&gt;num;</span><br><span class="line">            f[i][j] = num+f[i<span class="number">-1</span>][j]+f[i][j<span class="number">-1</span>]-f[i<span class="number">-1</span>][j<span class="number">-1</span>]; cout&lt;&lt;f[i][j]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(q--)&#123;</span><br><span class="line">        <span class="type">int</span> a,b,c,d;cin&gt;&gt;a&gt;&gt;b&gt;&gt;c&gt;&gt;d;</span><br><span class="line">        cout&lt;&lt;f[c][d]-f[a<span class="number">-1</span>][d]-f[c][b<span class="number">-1</span>]+f[a<span class="number">-1</span>][b<span class="number">-1</span>]&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="差分数组"><a class="markdownIt-Anchor" href="#差分数组"></a> 差分数组</h3>
<p>差分为前缀和的逆运算，将当前数组看成前缀和数组，差分数组为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mi>d</mi><mi>j</mi><mi>a</mi><mi>r</mi><mi>r</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo>=</mo><mi>s</mi><mi>u</mi><mi>m</mi><mi>a</mi><mi>r</mi><mi>r</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo>−</mo><mi>s</mi><mi>u</mi><mi>m</mi><mi>a</mi><mi>r</mi><mi>r</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">adjarr[i] = sumarr[i]-sumarr[i-1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault">d</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span>支持单点修改和区间修改，以及最后的一次查询。</p>
<p>缺点：无法支持动态查询</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    <span class="type">int</span> n,m;cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;<span class="built_in">sum</span>(n+<span class="number">1</span>),<span class="built_in">adj</span>(n+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)cin&gt;&gt;sum[i];</span><br><span class="line">    <span class="built_in">adjacent_difference</span>(sum.<span class="built_in">begin</span>(),sum.<span class="built_in">end</span>(),adj.<span class="built_in">begin</span>());<span class="comment">//构造差分数组</span></span><br><span class="line">    <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">        <span class="type">int</span> l,r,c;cin&gt;&gt;l&gt;&gt;r&gt;&gt;c;</span><br><span class="line">        adj[l<span class="number">-1</span>]+=c;adj[r]-=c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> num=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        num = num+ adj[i];</span><br><span class="line">        cout&lt;&lt;num&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="树状数组-stage1"><a class="markdownIt-Anchor" href="#树状数组-stage1"></a> 树状数组-stage1</h3>
<h4 id="lowbit函数"><a class="markdownIt-Anchor" href="#lowbit函数"></a> lowbit函数</h4>
<p>返回x的二进制最低位的1组成的整数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">lowbit</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;<span class="keyword">return</span> x&amp;(-x);&#125;<span class="comment">// 6 = 110 -&gt; 10 = 2</span></span><br></pre></td></tr></table></figure>
<p>树状数组其实就是二叉树化的前缀和数组。每个数组元素<code>x</code>对<code>x+lowbit(x)</code>有贡献，因此每个<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span>控制<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">[</mo><mi>x</mi><mo>−</mo><mi>l</mi><mi>o</mi><mi>w</mi><mi>b</mi><mi>i</mi><mi>t</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>+</mo><mn>1</mn><mo separator="true">,</mo><mi>x</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[x-lowbit(x)+1,x]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord mathdefault">b</span><span class="mord mathdefault">i</span><span class="mord mathdefault">t</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">x</span><span class="mclose">]</span></span></span></span>,易知当<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mo>+</mo><mi>l</mi><mi>o</mi><mi>w</mi><mi>b</mi><mi>i</mi><mi>t</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">x+lowbit(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord mathdefault">b</span><span class="mord mathdefault">i</span><span class="mord mathdefault">t</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span></span></span></span>时类似二叉树的向其父节点追溯，而<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mo>−</mo><mi>l</mi><mi>o</mi><mi>w</mi><mi>b</mi><mi>i</mi><mi>t</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">x-lowbit(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord mathdefault">b</span><span class="mord mathdefault">i</span><span class="mord mathdefault">t</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span></span></span></span>时类似寻找其孩子。</p>
<p><img data-src="http://hz-picbed-xxh.oss-cn-hangzhou.aliyuncs.com/img-bed/20200717113256650.png" alt="img" /></p>
<p><img data-src="http://hz-picbed-xxh.oss-cn-hangzhou.aliyuncs.com/img-bed/20200717113236761.png" alt="img" /></p>
<h4 id="单点更新"><a class="markdownIt-Anchor" href="#单点更新"></a> 单点更新</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">lowadd</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; bit,<span class="type">int</span> pos,<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(pos&lt;bit.<span class="built_in">size</span>())&#123;</span><br><span class="line">        bit[pos]+=k;</span><br><span class="line">        pos+=<span class="built_in">lowbit</span>(pos);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="区间求和"><a class="markdownIt-Anchor" href="#区间求和"></a> 区间求和</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">lowsum</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp; bit,<span class="type">int</span> pos)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(pos&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        sum+=bit[pos];</span><br><span class="line">        pos-=<span class="built_in">lowbit</span>(pos);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
        <category>基础算法</category>
      </categories>
      <tags>
        <tag>基础算法</tag>
      </tags>
  </entry>
  <entry>
    <title>离散化</title>
    <url>/posts/515818b4/</url>
    <content><![CDATA[<h3 id="acwing802-区间和"><a class="markdownIt-Anchor" href="#acwing802-区间和"></a> Acwing802 区间和</h3>
<p><a href="https://www.acwing.com/solution/content/6055/">https://www.acwing.com/solution/content/6055/</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">findpos</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; src,<span class="type">int</span> pos)</span></span>&#123;<span class="comment">//离散化映射</span></span><br><span class="line">    <span class="type">int</span> l=<span class="number">0</span>,r=src.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line">        <span class="type">int</span> mid = l+(r-l&gt;&gt;<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(src[mid]&gt;=pos)r= mid;</span><br><span class="line">        <span class="keyword">else</span> l = mid+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r+<span class="number">1</span>; <span class="comment">//从1开始</span></span><br><span class="line">&#125;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;::<span class="function">iterator <span class="title">my_unique</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp;src)</span></span>&#123; <span class="comment">//手动去重，返回迭代器指针</span></span><br><span class="line">    <span class="type">int</span> j=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;src.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!i  || src[i]!=src[i<span class="number">-1</span>]) src[j++]=src[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> src.<span class="built_in">begin</span>()+j;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="type">int</span> n,m;cin&gt;&gt;n&gt;&gt;m;  <span class="keyword">constexpr</span> <span class="type">int</span> size = <span class="number">300010</span>;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;pos;vector&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt;add;vector&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt;query;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;<span class="built_in">nums</span>(,<span class="number">0</span>),<span class="built_in">sums</span>(size,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="type">int</span> x,c;cin&gt;&gt;x&gt;&gt;c;</span><br><span class="line">        pos.<span class="built_in">push_back</span>(x);</span><br><span class="line">        add.<span class="built_in">push_back</span>(&#123;x,c&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">        <span class="type">int</span> l,r;cin&gt;&gt;l&gt;&gt;r;</span><br><span class="line">        pos.<span class="built_in">push_back</span>(l);pos.<span class="built_in">push_back</span>(r);</span><br><span class="line">        query.<span class="built_in">push_back</span>(&#123;l,r&#125;);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//排序+去重</span></span><br><span class="line">    <span class="built_in">sort</span>(pos.<span class="built_in">begin</span>(),pos.<span class="built_in">end</span>(),<span class="built_in">less</span>&lt;<span class="type">int</span>&gt;());</span><br><span class="line">    pos.<span class="built_in">erase</span>(<span class="built_in">unique</span>(pos.<span class="built_in">begin</span>(),pos.<span class="built_in">end</span>()),pos.<span class="built_in">end</span>());</span><br><span class="line"><span class="comment">//离散化</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i:add)&#123;</span><br><span class="line">        <span class="type">int</span> newpos = <span class="built_in">findpos</span>(pos,i.first);</span><br><span class="line">        nums[newpos]+=i.second;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//处理离散化后的前缀和</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=nums.<span class="built_in">size</span>();i++) <span class="comment">//注意从1开始</span></span><br><span class="line">        sums[i] = sums[i<span class="number">-1</span>]+nums[i];</span><br><span class="line"><span class="comment">//处理查询</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i:query)&#123;</span><br><span class="line">        <span class="type">int</span> l=<span class="built_in">findpos</span>(pos,i.first),r = <span class="built_in">findpos</span>(pos,i.second);</span><br><span class="line">        cout&lt;&lt;sums[r]-sums[l<span class="number">-1</span>]&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
        <category>基础算法</category>
      </categories>
      <tags>
        <tag>基础算法</tag>
      </tags>
  </entry>
  <entry>
    <title>【每日】1020. 飞地的数量</title>
    <url>/posts/48f31485/</url>
    <content><![CDATA[<p><img data-src="http://hz-picbed-xxh.oss-cn-hangzhou.aliyuncs.com/img-bed/image-20220212141050874.png" alt="image-20220212141050874" /></p>
<blockquote>
<p>采用多源dfs的思想，每个通往边界的区域经过dfs后设为0，最后统计1的数量即可，只需要扫描边界处的连通分量即可。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> dir[<span class="number">4</span>][<span class="number">2</span>]=&#123;&#123;<span class="number">-1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">0</span>,<span class="number">-1</span>&#125;&#125;;</span><br><span class="line">    <span class="type">int</span> m,n;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; grid)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(grid[x][y]==<span class="number">0</span>)<span class="keyword">return</span>;</span><br><span class="line">        grid[x][y]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> i:dir)&#123;</span><br><span class="line">            <span class="type">int</span> nextx = x+i[<span class="number">0</span>],nexty = y+i[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span>(nextx&gt;=<span class="number">0</span> &amp;&amp; nexty&gt;=<span class="number">0</span> &amp;&amp; nextx&lt;m &amp;&amp; nexty &lt;n &amp;&amp;grid[nextx][nexty])<span class="built_in">dfs</span>(nextx,nexty,grid);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numEnclaves</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        m = grid.<span class="built_in">size</span>(); n = grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;<span class="built_in">dfs</span>(<span class="number">0</span>,j,grid);<span class="built_in">dfs</span>(m<span class="number">-1</span>,j,grid);&#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;<span class="built_in">dfs</span>(i,<span class="number">0</span>,grid);<span class="built_in">dfs</span>(i,n<span class="number">-1</span>,grid);&#125;</span><br><span class="line">        <span class="type">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> i:grid)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> j:i)<span class="keyword">if</span>(j)cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
        <category>力扣</category>
        <category>每日一题</category>
        <category>dfs</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>【每日】2055.蜡烛之间的盘子</title>
    <url>/posts/f2608f0/</url>
    <content><![CDATA[<p><img data-src="C:%5CUsers%5C42273%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20220308131742743.png" alt="image-20220308131742743" /></p>
<blockquote>
<p>思路一：使用二分查找的思想，记录蜡烛的位置存入cpos[]，然后对每次查询进行左二分和右二分，查找到&gt;=和&lt;=的pos位置 lpos和rpos，sum=cpos[rpos]-cpos[lpos]-(rpos-lpos)</p>
<p>复杂度O(nlogn)</p>
<p>注意特判边界条件和rpos&lt;=lpos的情况</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lbs</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp;a,<span class="type">int</span> pos)</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> l = <span class="number">0</span>,r = a.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line">            <span class="type">int</span> mid = l+(r-l&gt;&gt;<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span>(a[mid]&gt;=pos)r = mid;<span class="keyword">else</span> l= mid+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">rbs</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp;a,<span class="type">int</span> pos)</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> l=<span class="number">0</span>,r=a.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line">            <span class="type">int</span> mid = l+(r-l&gt;&gt;<span class="number">1</span>)+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(a[mid]&lt;=pos)l = mid;<span class="keyword">else</span> r = mid<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">platesBetweenCandles</span><span class="params">(string s, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; queries)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt;cpos; vector&lt;<span class="type">int</span>&gt;ans;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;s.<span class="built_in">size</span>();i++)<span class="keyword">if</span>(s[i]==<span class="string">&#x27;|&#x27;</span>)cpos.<span class="built_in">emplace_back</span>(i);</span><br><span class="line">        <span class="keyword">if</span>(cpos.<span class="built_in">empty</span>())<span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> i:queries)&#123;</span><br><span class="line">            <span class="type">int</span> lpos = <span class="built_in">lbs</span>(cpos,i[<span class="number">0</span>]),rpos = <span class="built_in">rbs</span>(cpos,i[<span class="number">1</span>]); </span><br><span class="line">            <span class="keyword">if</span>(cpos.<span class="built_in">front</span>()&gt;=cpos[rpos] || cpos.<span class="built_in">back</span>()&lt;=cpos[lpos] || rpos&lt;=lpos) ans.<span class="built_in">emplace_back</span>(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="type">int</span> cnt = cpos[rpos]-cpos[lpos] - (rpos - lpos);</span><br><span class="line">                ans.<span class="built_in">emplace_back</span>(cnt);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>思路二：前缀和思想，分别处理三个数组pre记录从0开始的*数量的前缀和。lpos记录&gt;=当前i位置的最小蜡烛位置，需要逆序，且最大值为数组长度-1。rpos记录&lt;=当前i位置的最大蜡烛位置，需要顺序，且最小值为0。</p>
<p>对每个query，sum=pre[rpos[query[1]]]-pre[lpos[query[0]]]</p>
<p>时间复杂度为O(n)</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">platesBetweenCandles</span><span class="params">(string s, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; queries)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt;<span class="built_in">pre</span>(s.<span class="built_in">size</span>(),<span class="number">0</span>),<span class="built_in">lpos</span>(s.<span class="built_in">size</span>(),<span class="number">0</span>),<span class="built_in">rpos</span>(s.<span class="built_in">size</span>(),<span class="number">0</span>); vector&lt;<span class="type">int</span>&gt;ans;<span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;s.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i]==<span class="string">&#x27;*&#x27;</span>)sum++;</span><br><span class="line">            pre[i]=sum;  </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> rp=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;s.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i]==<span class="string">&#x27;|&#x27;</span>)rp = i;</span><br><span class="line">            rpos[i]=rp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> lp=s.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=s.<span class="built_in">size</span>()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i]==<span class="string">&#x27;|&#x27;</span>)lp=i;</span><br><span class="line">            lpos[i]=lp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> i:queries)&#123;ans.<span class="built_in">emplace_back</span>(<span class="built_in">max</span>(<span class="number">0</span>,pre[rpos[i[<span class="number">1</span>]]]-pre[lpos[i[<span class="number">0</span>]]]));&#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
        <category>力扣</category>
        <category>每日一题</category>
        <category>前缀和</category>
        <category>二分</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>【每日】1984. 学生分数的最小差值</title>
    <url>/posts/3e175728/</url>
    <content><![CDATA[<p><img data-src="http://hz-picbed-xxh.oss-cn-hangzhou.aliyuncs.com/img-bed/image-20220211134306054.png" alt="image-20220211134306054" /></p>
<blockquote>
<p>思路：排序后使用滑动窗口的思想，取窗口内最大值和最小值，即i和i+k-1的差值，取最小。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minimumDifference</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(k==<span class="number">1</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="type">int</span> mi = INT_MAX;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i+k<span class="number">-1</span>&lt;nums.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            mi = <span class="built_in">min</span>(mi,nums[i+k<span class="number">-1</span>]-nums[i]);</span><br><span class="line">        </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> mi;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
        <category>力扣</category>
        <category>每日一题</category>
        <category>模拟题</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>【每日】688. 骑士在棋盘上的概率</title>
    <url>/posts/2a64def3/</url>
    <content><![CDATA[<p><img data-src="http://hz-picbed-xxh.oss-cn-hangzhou.aliyuncs.com/img-bed/image-20220217185416173.png" alt="image-20220217185416173" /></p>
<blockquote>
<p>思路：采用bfs策略一定会超时，因为步数&lt;=100，理论上可能的总数有<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>8</mn><mn>100</mn></msup></mrow><annotation encoding="application/x-tex">8^{100}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">8</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">0</span><span class="mord mtight">0</span></span></span></span></span></span></span></span></span></span></span></span>次。因此采用三维dp[row][col][step]代表第step步时（row，col）处的概率。统计总数也可以，但是数字太大，若不模会溢出。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">        <span class="type">int</span> row,col,step;</span><br><span class="line">        <span class="built_in">node</span>(<span class="type">int</span> a,<span class="type">int</span> b,<span class="type">int</span> c)&#123;</span><br><span class="line">            <span class="keyword">this</span>-&gt;row = a;<span class="keyword">this</span>-&gt;col=b;<span class="keyword">this</span>-&gt;step=c;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;node;</span><br><span class="line">    <span class="type">int</span> dir[<span class="number">8</span>][<span class="number">2</span>]=&#123;&#123;<span class="number">1</span>,<span class="number">2</span>&#125;,&#123;<span class="number">2</span>,<span class="number">1</span>&#125;,&#123;<span class="number">-1</span>,<span class="number">2</span>&#125;,&#123;<span class="number">-2</span>,<span class="number">1</span>&#125;,&#123;<span class="number">-1</span>,<span class="number">-2</span>&#125;,&#123;<span class="number">-2</span>,<span class="number">-1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">-2</span>&#125;,&#123;<span class="number">2</span>,<span class="number">-1</span>&#125;&#125;;</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">bfs</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> k, <span class="type">int</span> row, <span class="type">int</span> column)</span></span>&#123;</span><br><span class="line">        <span class="comment">//tle k&gt;=10</span></span><br><span class="line">        <span class="keyword">if</span>(k==<span class="number">0</span>)<span class="keyword">return</span> <span class="number">1.0</span>;</span><br><span class="line">        queue&lt;node&gt;q; <span class="type">int</span> steps=<span class="number">0</span>; <span class="type">double</span> res = <span class="number">1.0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="function">node <span class="title">tmp</span><span class="params">(row,column,<span class="number">0</span>)</span></span>;</span><br><span class="line">        q.<span class="built_in">push</span>(tmp);</span><br><span class="line">        <span class="keyword">while</span>(q.<span class="built_in">empty</span>()==<span class="literal">false</span>&amp;&amp;q.<span class="built_in">front</span>().step!=k)&#123;</span><br><span class="line">            <span class="keyword">auto</span> cur = q.<span class="built_in">front</span>();q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> i : dir)&#123;</span><br><span class="line">                <span class="type">int</span> nextrow = cur.row+i[<span class="number">0</span>];</span><br><span class="line">                <span class="type">int</span> nextcol =cur.col + i[<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span>(nextrow&lt;<span class="number">0</span> || nextcol&lt;<span class="number">0</span> || nextrow&gt;=n|| nextcol&gt;=n) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="function">node <span class="title">tmp</span><span class="params">(nextrow,nextcol,cur.step+<span class="number">1</span>)</span></span>;</span><br><span class="line">                q.<span class="built_in">push</span>(tmp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;q.<span class="built_in">size</span>()&lt;&lt;endl;</span><br><span class="line">        res = q.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;k;i++)res/=<span class="number">8.0</span>;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">double</span> f[<span class="number">26</span>][<span class="number">26</span>][<span class="number">200</span>];</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">dp</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> k, <span class="type">int</span> row, <span class="type">int</span> col)</span></span>&#123;</span><br><span class="line">        <span class="built_in">fill</span>((<span class="type">int</span>*)f,(<span class="type">int</span>*)f+(<span class="number">26</span>*<span class="number">26</span>*<span class="number">200</span>),<span class="number">0.0</span>);<span class="type">int</span> step = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;j++) f[i][j][step]=<span class="number">1.0</span>;</span><br><span class="line">        <span class="keyword">while</span>(step!=k)&#123;</span><br><span class="line">            step++;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">auto</span> d:dir)&#123;</span><br><span class="line">                        <span class="type">int</span> prevrow = i+d[<span class="number">0</span>];</span><br><span class="line">                        <span class="type">int</span> prevcol = j+d[<span class="number">1</span>];</span><br><span class="line">                        <span class="keyword">if</span>(prevrow&lt;<span class="number">0</span> || prevcol&lt;<span class="number">0</span> || prevrow&gt;=n|| prevcol&gt;=n)<span class="keyword">continue</span>;</span><br><span class="line">                        f[i][j][step] +=f[prevrow][prevcol][step<span class="number">-1</span>]/<span class="number">8.0</span>;<span class="comment">//到达该位置的前一位置的所有概率和除以当前的选择概率。</span></span><br><span class="line">                    &#125; </span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f[row][col][k];</span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">knightProbability</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> k, <span class="type">int</span> row, <span class="type">int</span> column)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//bfs(n,k,row,column);</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dp</span>(n,k,row,column);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
        <category>力扣</category>
        <category>每日一题</category>
        <category>dp</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>面试-基础算法</title>
    <url>/posts/627b00bf/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">
  <script id="hbeData" type="hbeData" data-hmacdigest="80c5c82b722b1c0a6494adf0daea1c6340d46849b75b6b19ec49a274c2d6db76">ce77eb60cb392a7d1958e79566e02905423f78e38ab83261c3422aca5caecafe166d1a51bdb1622d72a1bacd2b4432527db979feb41015af2afe3ce1c2093fd73296c72a221bfe13253be96b3f3b9e4000066f12a5fc310fbf33c3c9aa8568f0ac61ccf1483996c85a825116a79f5a04a0743b62f4286c9c9aaad62d2dc224de31787795607b8531312f96e441843dafd7eb06de466ebc3f4e95c7cce07170f2b728aba877790501b23de57085b93a22575c2dcc369df76d7c076412e5f850fd91068bfad857612612a06e8a6b04aff8482bc297bec5d64e5ef7489b30aa4e16be239dc98b2b8adccdfc84a0a050ed4af25c82a9a6751b41cd711ee0f533a9a5e942e8725f55af5f2c5704bb9f630c52d8dfae6cdc1b4306c047a90677cf119362d8b75fcb4403e6cc403355229221bd9738323ff75f5d826d5b7d338a2f1ef70795e7e32b29ce95156b8bced5612d6856565e8b8bee2b8c878a6c1942356f941c70593c6daf0c9aa2a49a161e915226728729e22b4cf7674c58b4597f42c9eae3e527733f13f4fbd0040406e32e1555b44f33cddf1f60d5d5fb867628acdc260909bd6e5787cb3a2fc5f93d582595202595bc11ed6e64ff294daa9baeba910a3fddd8b2e55113796d3ee0456d6810a4cb09a0e462aec282708ce2bde1c67912a8c17d844f57cce3c36f3e1a01fc5c636a55e0134b4b4bc247d761c2942bb416af1f769e7b85b98cdc1ee561fd67fe9453b14d89b1c1bef4d0cd0ed6654461044afde27d2582ca361d785103d2838b70dedb38a8b5196e78f8deb0692d8ca73b497639e46d369877e1a52fdce46e3a3ec7c62e9a165b620392411a798883989052c7e1ad392f63016e2dd4f0d3d8b00b6c259998a44b5df21ce749986b6bff9dbdef7fa58bf50f6f394c6228017b9df0678f6478537642844a526e44735e5ca9b3a3ef7c73fa6c8e0c1a5016303122fb57f279601a2dcb9f84fb5c0e9bc3f454391e5d10d5a9f4ebc5f07845ce0bb730c2eb99afdb106b30067975a7275aba221bc0ea555cf49be25441b808f537a5beb784fdd90b41df6cc1f67039eeb6d46ec0e13329e0601148dc78829df097c65879b2018b1e34c30604bb3267cfbc5518aef39eaae6c5daad894ef8f7f9dac6f488e1f36bfd54f06e83a9dc1c2b457b3fe99c0508f0bce16e5410d352d55e9914f66e603f1d49b142c0efc61fc7892abb9099324e3d7e96fec6e290d4c68befaff348bbe0fc2661971574aa0fe61421cebad4ae722f2c75c4d0869b7f93811b3ece55d5911ded6d86ff38ffbf9099ccd49d2ef4ded8eda536d183e7d3cc8af4f7392e49c29b289350d5fea3cf44f559e2ba6f04bf2fb1eb2c3bda16e1c676eb49c51ce87d6c0b9947a980e893490b0ee9a99486d5f0a769fe102ca99cff017b353567c81d326332c77b6b4f90c51c8f1318d4a796e38168bbc29f342d8edc7b0d8ce5ca1d4f4b43abb1033de4b2c3b6e2af2c3f639043ef37300e6aeaffe26034a67b5e0a171936a2f061d3828243f2ebb2f49557e1d09cf5532200cb547497d22066f17ec2218fb15c6b8ff16c100dab388965425bda354d62d3136b6a818a85f6cbe2d15f606aa38f684212238b63915d90dda8b4080125cb295320454f0e74bcd8ccbef5afefad20b5dce67178ec59d2b84d84d61bf1c3028682d103d9814c0d6e38bbbb473e399276945d47c6430ea196b4fed09139bd68b7d655caba94bb214710129516950a2aac042e00a492a74b91eea9a5a3dcca5fce8a2d335b7bb5cfe9ec835ff811dc9068909bd6a58c34c0c6212709d7b6e327b615eb4b64776fb6a97d47d4dced5e00a3762787f3ab5b001805e153d42afe7635e26ae2a034cfcfe1d5d3a69ab04a9cf8a32abb6559fe02af17d6a6735d2dd512a8979155a5b4ae6ccd09c0299a2b71e586f4476a35f182d9bb04a5a32f469e24ba25f12efcd209416d8e6b97b8ee4bc7a111343dbc30e9b23a9cf2b04527221b67313c9b00595b8b0efb803059855caee48d386721e8c262f86268d1f3676d5009b26907c345e2609fcd2749ee311acaea4509eb7846ced9586eb8fc0bc150877a616cd5840ae3f3ea9c0301e156328626439b750c0a84a5a76bbd887aec489668c4dda1d807c17ec7bb49c1cca79327ff11d6d0e964f402dee8430224fae8861327ba4de89ed2579ac18318e6788043d1dd598c5335406cb94a4bc5e53a8f3926a58630f36c0f0578e5448fe19a5952fe87e3fd183d4f3a9e3b4ec92460072bff204807c4aec10ff3fd66b502b6e48d5ede71853e178c4d7a4756ea16728cdb26879172fc2303df42789c7316d7b13e907ffe497454dcca1c350a00fc357a3a5cdffc50ff86c1e92ed1ee783f1492fdae68b960d355de31eb093ca4c0083caaaa26bb35f4b1682a494976e2ca9dcee73bab3b1c8153d19d8fb22980dcdb9d481466ae8185cccbf53c661d40586107d1b915c0e64d123744c04525efea74678244ac9b4b2e5f3e0930fa2dd1801975d4a03b99b86464ab4f3c1c64f7b7615ee6b3f1af3592ed68d07dfa0376c4e373ab7116e2a133b3dca323217e3b077424897f3afd0e16e3d3639537ec6e61dfdc462643cea007b5e107f652247024626bdd9620175f3b0aec2bd6d79ddda02541ce8ecc9eeb850d33cf91ad7ad55ce0cfc756a6513271fe431c5951063f7a7fcb96a70262df1ef624c25cbec592e6a6b5d2a86733c44d7b86b3851a886152a2c973f27c3cb34bb525024e8758b9d39df193578774302b377c47c901a10899ae89db74714bb42ae4ac15edb6ce75d5f8b0d5debab91d4d31ce0e9d531b7c7677243e0a7b7b54197891dfebab1fbac8ee9cd274e9a234307e227e4d1b2f6f754dbcceb89c6ec9e94409c0fae31cd6ba4098856b88d32319e87a40f9cc072e6bd0a58ec818ee217ed9f88bfc2bfb8e6b6731dc4e7cf5334b88d1f4660a24301a8f3d0e0d960e7f037c42fba34292a9fd5d80cce8c8104268d475f36d6bc7fc7bcc632ef0032076baba5171f77b77f03f0ba1a8f8e852a37c173b39c6b35aa3d89d61b895c0c3f56725467e48a94c51d107e64ee79e4b12d7bd0313125d74835f273a82272d8a31ac8a734737ee569052f6656dc7052b9a9afa828cf1c738a1c51e6e3690bc76216c7e6d2ad5fd0ee3d6a50a29973ab5e51650863d7e7e6dca8387f5269e7a1c4b4780812cca24b06cd95dadf342a777635f0e4ed57565c01d30f91e54992fc0d077288970dfd5a5f24082021c25ecded7a8334f62a0d37cb120098f84bfe7e421e0ebeaf0bcafa98d0fc67ab30a5338aa2b788c0b3933e4fd460352a49efd24b95f907e4e0c61286a3d757d8f62dceb96abb35eb526bfe541703e8c6b548d8a95b0cd84d2b2fdc0c1c93c7d9327a206a4f1cb51709bb900c98c99cea95672a6405d150ab86bfe5d53885275794bc8602d0054aa7130b4e2af263e7ffae91dae94af9331aa9a6d9772e85fa1a83055e4775d5d2a4f8a5a5464a26a36dc9dd151ef200b0d6480c9c1abcccd38725cd6486b1ac01be0cfe0a462e66f2addd6e94b491fe635cb56fcd255cbcfef592d2ccb76778d10ed835ec6559b0011b594fd5daac6404b415ca5576f98cde78ab0160d77598f6769286198e575d3cb0fb8186fa23165570df11173cd402ad07ea4e7f41940cee4ea26c6fb5774fbc5fc092dcc466ee02efc5ffd1c49296827e367b3374e56165119737c691c0c1fe82796f13d44bfff5b8294462fb468d5d39c79c4f81b2fad16102b071819a35c2eeef1055a5a235aa25e8feb5557f3c60b9f751cf9f03df021624401060b2e44c4bc0c91681550091794445c326f40df842cea1fafc24e5c5ab93163abed8b98ec28f4d303c1a0b2c0c93a3a8e293fac89800dc8c6edeaa40e07e067380314fc5d4cceba86827620ee5fc9b56cbb7f65f542f1f65bf7b574e0ed5b7a3eb5e6d0ac374d3b1e9233f6490ef8b12c4d3eb837ce11a0637086dfe119642786be7aa4b14759ed1173b098f03f0212265522c9a69541168eb51d7f06ac08b75c6d1d586b88c47a489ffa530ab99308876431fb849e0a777448aef4c389fbffe6c55112179991ca1a6c1fbf4c75d738d47bb5949cd58b44378267aa58e72d1075e55d0fab51af5e95532a7d492098632adde379a5bbf89cab3c3e5919bdf5739c500b7164ad705b8e96313aca55612ebf522c5582ab3d8fe46032fa296fd6a8ea60f10ad5804d26e3b63f338195419043907297b2472ed03eb5ced08dad5240c5a466b2b22125e017cb3d383ae09523eb91aecb8766bbf07424d5afb9c10a892d4535eff377f3d2987c4d5014fb93f71e4bac39c02ff95065fc27a86fa6a28046159a375f2d3900f21633331d03d099666d92d5dcd753f152f8ede8a902fcd34cbab55de854de18095ce7464e14e70e5228ec704411755a63f555ce7c65a122a08b155baf866bdd7617f3dbd44eefc9032d92d9a1a19732c97e26afe3c48fa929210c8f91b769471bf3d9d14aee48f1d767d97366de8d4729a191344a50c21178965d462db879c9f49c766c81e2275297859fb3b91f8b2dd9aa91c5ee8585adae93a46b675b6a1f15e2ff44a9c41a7b61a49590bf230dd1ac14f9a4d6c4e85b0e0a10b05167891c12ff56a82004ff909df701071cb711a24ce5cb6f7a12f64caade39d2e8130d39df11c8c60af824a0e5290ea9ab3a91ed04052087c8bad081d862ea7b0af1c3ede9c7b7f457a853ec38877832454c49b33dd63efd46e8019555af1db952198a61d374f29f46a8a1f8b9c021359a4770ad24b42913ccc4a7a7c537b155429ece1b9760dd3762f36d67abd0c432ab6a3b031d7d326739a079d46193a584affb9d2a1f0e043d19ee2c0ae758919ca97aa1d69c345716290642538b1d5263dbd441da10acb54156abb1dd31c7d81478c3d1dc1a2527258908ad974c7d71828daa6f595533d6c91b4f086412dcc0f210acc430403f884a0ee4a70a6eda4d0dab07f85ecae735c80963644da076781bf816cc5e41d888626416201c97c8b4d0eb5a3f3dea6c3483f7d67d7337c40ab871ff8b53e2212610f02b3a0fc29fd79e03a4eede27110110eb3a91b0123663ae574d8ad6d83ebc1be3537387f42f1217b2b504ef21148c6d8935e35ab23d2ad4f3fb211c19c412e26f635f084cb3493112eb779f768e44f846cb5ad074eebfe2acd76fa4cae1bdd489c1d3091c1d4b436e379d6a3e937682927cb1f3ca9c0e9cfc1157da014bf5ff5814d1d92ea037f098d9903257e39944c839da79da2907d41b2bf8aa0a30db2875b9918bb8d809f24ff02cadc951d95bbb99116b92220206a856dcc4e0bdb8f2c2f3662d1cab02d4ba475f2e13b9cd73c618c86ba0b69f5af4c1cc6efa2e780eca92301745114008fadc03c01036fc3ff7902bda1c55ae87e13fbad6cf65813abf47c9ae0030d3cc3cddf5d78267ef0ee528f5e8a4082eea8d70ac05b070a43a03b407a7885779110726d1d997c9b348a2a305709ae5cc47d350ca8a5c2219a2d3f72082ae1e663c6a3ee3c475c6573c28b06bb6310f3d105a82670e6eab015f634cf977d129ff4e3ac7f20b623099b55c0a3fed46bb1412efca121422d5938c3bded6eea4a9db9ccdc4efe16bdc79c5e7e2d6608fa87269e0c645935df9962f1acb1e4fdb11796fcd98787c9874b4f356f5a6b948a4326304e235960756ecd9d32382a2ec31d088b6f44a121bdd9f1d7030aa97e51fe6179837bc97dee8b28a328efc16f340bd4db4b0695e1a02fcb111984656581d89a3dc137b146813840358f4d755ee25951fff646d0a193420569cf470b8167a5b83bbd05f5ed803ef0f1ca9c6b9e2e37bef9a1798675c70cfa2c5b7942cbe83460c413015d2587e6837005b717366f903d20942f79fd06ba95ad1faae4a0958fcdad6aa79363eeb6adf5d8bf59af2a50159a30339adc6535d922a12e4305f83197dab0f332604e8df568e2b168d96ebebd6c1ab23b79f47602c8450822546146263e396846e36858b7dcd13685e643bd2d4c131e17ca2e3e17501c916a55ef0fd5a236ce2e8a8e0499dd28d8499dd3e4bd10295f5a6751464ce7e8ac37e07dd7d61ad3bb87a412ecb095f3051f8fded69beadaa84d187fff0d7188d048072272e2131e6640319dfe144027a6f33891325f95142100b4bfb970e5f1f91db810f6ce87aea5ec579a0844784fa4324aada67c62aa86ff5769fed95ff3dbd38128081aba3bdcf436c4adce7aae825154305b29872dceacd6a9dcb7e96b2031f50bc943d545b57db140a46d9eb83c9d079d2741a7564c083bd36e690d2f84269f2c190f7b2655b8a54d15d12619c63d5eef35adc66f45d1abcee9b29e17a793b19bb4a442ab5d9c4ce1185c744527b371d354c6bb04f2279b4c453e316a42f53d5b703b1cc9281f3ddacf6957ed313709792ec5bd63e326ed01f42ecdae9d8ac92d2e87b4e773d0663f6fd48e5a0ea8aa74999b49a8e297b4dd1c0985f606ab6a37159361fa38ab7b87efaf80ab804e05fe89db45cac01d018dc4106e7184e0e84097dedc27f6b20b05fec2647ab85662a81bf6346ad9cc3ccb4453ec18922c38e2647375d8f447375ecd717ed215a0402f9b77b8f54793751c6209a8529a3deb786d93acac21fd1b16828eeb15f58808e6262012fbc08bd7e7109fcce636e2c7dbca34316cd65a23fa83a704ed58804e40c603beca9d88e84f24235ea56878d47e1fa94534838631e809716d7c970fc3d8e12e0ae0d84eeeabbdf3c2ad37650aff4f45f4003103aa87a6e7e25160e5b4bbecc475706972482681fb1ee5391a28227d6064ba95ac2cb55adde2663d9d9c90b2f44186d22f3e2774c85dce230229888baf69a4103d548ce10834598a8c199ac4d66632b0bbb95089cb983f370305dcb491e79eae818ad9c0db98b0e0631f4ae2dfffaf0b67d10c3cf894520552bfb744eb22289f35339a7c1a181c54be499116cf83e91f909776c50f773ebee03cca47540b7180e9f6d062ba3af656bd7876b335c165b6c54a2e836bee8d007fb8a402cd04c5a1863855037ec3c14dec2cb45287d2d4c44360a37342398a8e1748b4a7919b72b69ba2349059d8afba645a8800c2b6c32e27222983a3520a4c2317871574bedc36bbb2c733b6f6d45fb8897bd1be1fcee694518cf0a9bcc51607dbae141c65e7aa3ec107c1965e335cc787e136b947944ce474a316d5bf04917b8edd1b273f1db5300fc71cd248704897613aea7c390872d1c3d0f21b44d0a3001e9a1e8490773c17fcdfd6c904b1c42383bfc07933eb2419f4c060894cace14f5e635f49e82083d889c24ac8e9772c64a4211b78a141f460fa5c27bcc47305d0d39c87268d6d0a145669cb34fc0b6870a01005f7212f1d979066bea008daeeaeea8aa036cb1f7bd821b1c690bfa049207a778b1189de27ca20c2861b79e03f62c13d5decd112d9cf236ae7ea7f6cbd3ea4eb3c8aaaa51a3e921276b24b35d27b491b3730481607a456d5885425b241b3aacb972c13a137a5f994bdad362bfc13a482c63404d5b8b5664c75e0ae2d97b201ab526caf90dba1ca87ffb4d7d897c099dc113560d7781ea2a4c9dd8fc015774ade840f2d077612e914908c321499bc8da4ab2e500660742b735d97c9564fa5807095daa75e71e08f393018daffa21ab44022b8f04ca87c359e8873f6da94393e68160390a2fc05b8dccda070b29949c780f8fb2280835ad068c46fbb3a21cf79ae09a214a197467ede292fc0945eee573ca2ae34e165156381b2aa4fd9f29428650a184d99d4da1d5cc3d43bace33e96ecf963aecf5b2fb48e45dc2fc6b3d31faae086a639473636a5dce8a238da81eedb79b61fbf972a94026724012daeccaaf53f99263b1e13402ae9b3c8a9e400c2e61f16eccf65248b06b7855bf3653b60314631afa744e6f3c33a4367ce01be7231261a16fab4e66db8b1b9f77fe47e68352cca1e5f442351daee491c2c1f0cf56b2fdf7960cfdc00e6cf002dfd80cbe603f709ece98c2b2dec83331c506a70fac71ceb291507ca05f21d6b7f06af828664fde02b0ea81d68935b8e7155a636cb22875851d236f099751336e5252631ba5b3c0f2a6c14c4f4c9dc3790986c77934d680a0c0534d0a2a542999b1ee433cc99add148b069ecefd72dc56ee83fe5230da5aad884e261243d19c09a48f4b1d3d4098eff53dea303cacda6ef5c2b224c5dd034facd5138b0f28a21d58312773b982c28b807b2a007cfeb21fce48d5d18b91086f5a7df8e8bbcf73e52ed82560ce8ecb226e98b8a338867441ffcf8db1166cb62d5683ad7c1bea26ec1b74ebd800c20aca8d48313142cd0545023bbdfe04b2e80242beb9030a36705709d5161e3a1bd9fdd30d4a0a97b93051f6ce536eb87f4b3302cb4cb9253dda7af239eea0df59cc5a4498c2b51161cc9ecded8701f2b3e3a00660d4492910bd5e3f1c774de3cc591961e008126734c6b870df8ea08c96e98908d1605caaf7dc4d736bcdd4aa06e5a8aeadf0a215966c9f49c082b0f0ea135c5f8b508b681099c91a7e9f85bfe1c241e4c05abd5ee3aa767f21ac4149be3a0a229a562c0bb1d8e4f9adfc51c9fcda4dee508b6bddbbab959bb3038b4b4368f45c2c1b0d640b4724667e17caa7f3a1fb72d4c0e082364180a4758c2e8a97d01692aba048d5a608de13ce04713bfde6b1c60f27ae0a7298bd2dcdacd8f27bfba8a41817141f7fc99a06e37187a9350b1dacf7f9dba0ab533dda4e56642f6ed6fba6bdd9dd3e402b174aaa6b7bb91230a8d0b1fe1a5e7cc185d56ea61b1ec374f1869f737cb61e21c98c89646f90af9a0ab751e6965627f3a78d68b85bf7cf36492aaf99bf439d4dee5af9564819e2879e7c92e86dd8d7bc1173bd2940d0cbf77e5037c0be82050fb6aea19eeafef5c0519a65950aeaff475271b113b0a41516d726ea11b5631a2f687ad1edc10e9a21964c820fb0b50df9357dfe8a6a8fe8b9040631789f1d580377f05eb73cdcff1ed913294eb8b1601dc3fc3c4e0fefcb98895a886d307138ad71a0a9344c8ce63c0e51d8ef5447a333aa2dcd63eee23e8005f6cc1a0178c69c6c05a17d85678d5e62a3b6bde97fae5c7c18de6aaca3b2b75f9671247712799a061db7b2379f0f939181d0f7ed637158d22a415f1feb4d4ca3ce526ae37c8815f49e832c9f220716c6ba57ca1f4866db02f13c12e79bb941fc74b3eb5668ca6e1342d3e587bf9627a8335e5f80461442a45e41f1103bfff872d05fcc8d668dfa3924a82ea37c1ae4f57ca65c17b48b0988efa1a019317288e03ef505542d41482b12c552279a31647635294ef71c0dfa5f3a9ae9ea11e5de4430e051143155a3002ce1709331933233eb9f7630f7322c247362fb8624649a6203f1334a9d52cd428545917a6d37c7b3eb2bb897a5231c45e29719a62de07de3ae80abcb86a74e45e14a18c8eb8dfaa6af5a4f66da42f36fc75b5a57c78df395db68762537456f46e2db447ae0f2d9fcb267548a275a9d424f8f503409d16c29030204495d9008c8078ef78196bcaa6f85489fe8427bc3eab84a0f64a627a2bd88a510df2f5a6a468d9afa79ddbde472288ff866a3e036ad40266968209dac313abf1a3340977d99f4211820be88c0b19156599b08d81667863dbf74f7f389cb47837988a6b484bbe3e8c7295b7cffc39f7e9ff1a11465e61fa6bd7fee7106452d4f04955504c442147263ed1a514aeefd1e41ccafd9126055a53d905460ac2ceceabe7109028a2a37e21d32e0b0cbaf9c5edcf8168bec02eec7eebd07acce8ef2acf0e53273127ef3b4786e8f0aca31ed232f7717b9dd4d72404dfaf42699b544b516e182571e57d2375b7c1c453034b5630f070e97bf70805814229e7af3c915759b6ee483d19c0fd5fa052677e0e14d0f15e07ffe6a73ae07ce9666b8a258184a8caccc1c7e83aad8feca515329bb0e89c1fa8348967f28bfd48e298d906f7b946d37f12d9f53b2c019f1f5d1234963e9d9268c5bd10431e74f1b50bde1f1134343bfc58e744fbb5f535cd014dc27b7e3e155a5187a09b0886f4f6209e539d92bab8231066ada10e12e0c408a2083adbeba65dd8504b7e91cbbbd5ea5ef35f1befc42ff565b9fda08d7ab0f9d05f40b243f737143fa02ae827667b2cff598d95873338d4cdf1d8f27b3544f919d4b95a89f0416703f163c8be6d69b774866384f0d93b3be3d365b6adb53eaf55101cc5e86c0232f5610c4fa86572864a9f9f24f1d7fa16842b865887690ab37e6c609ffb13cdecfc7724f7251a31a803e5423332424895bdbd3a386ec3454bc1766b6a1b21514e866708ea9efde6595abd5ae7f705019132bf1ed2e97f6afdcb748edb70ac2b4148ee117871fcdc79557339295ed713793b739fa607baed178f5c4144d33213930c53eba2c498601b2f863a51a249a2907a038fffc91b12841395761436d593eed68a3ee1ad79236c20dc93d2a985f3bf73bd32a7a6880ef2adafdc22974d17b2278a08d64aa604ecfcc7cb300cce0e8ac51796bfff55058c3efceca17a4a4ce7a8e5021ff5dacdb297b219fe6d41fef56a61c58cb1ca155ffcf7a6947eb9a3fe45966e81957c1afa4c0919fac16f19dfd74562f5a308353e67787238b753013fb80b55f8150fed211112220601681fa266b264ff24252c7f9d35e4938d5caa6b268b247bde0dcbec2aafd41af74ae4a6cab7f1c118352d4f6a08a3fc11c835c707c565b9b5ffdca6d3444f132a1c33c2ae0540e4bea0b49fdce916ca28593166c76c0ef33cc3206ea5617d677723fc63ccf2d4329c58fcbb5a89a5db771c759ba3d4fffc68d268deaad10a3745dcc1857ff6f8b9fef368e3d40f15cb7037e3716b055879608260da1db77dba25ce956371ae9c78c8943f93f7b7d9dedb6edee2337bb909a51396d54b9754f774cd99fb51a4f9a3ca2b165cf90a203e8b6cab57d7c42f52c4a86ccad972379df18fe96f3b7ef7e6f54225a689e4d5ca943fb4e7e3b3af7ed4d95273bc77553560afdd6b1873f51a2a73ddcb74b15962dee154ab0afec8a7894c9456f9c19102c34a6befde1efbfb9b1af9171da905f1ea14c32391febb8bcac41a069cf06fca03bb38631ac1fd165bead89c1e995bc559e807524ab49f24691a3755bccc963a3763e7ee3d02f9b5b99c1b0953d0cba5a97d960a5ff2f5dfd8e4108597f3a7a4178377d6a906f7a8f3b8c8d2ee8176723df2af5402b5501b89bbce46c758077f30ecfb78b8f8e8c37976ca9ffadc0826a5a856edd5d38dc7503978279bbbfcfc989ee56c6ff82a7f4ef527b3e9fd357849160ec7a1dbaa97778eb45328e0d42c6d3a02b74cdce4662232f78c3efc4e98d2a2bbcbd0cc48225d9fff29db334dfd301ddb22e17a2863184c2679b31c41820bfe10734bfbde89076ad3ec014ee2a90612fa88bc8a7e80ea1fc6ebccaec53b9686224029d50bf0dc9147d22e0bd5e4ade2ab1243d1930168a1b754777228566099d4f93ac12ff2db7f705320d084c6cd7060999ce5bfe1589b85477d258b600a55ccb33d1ee571b2bc0ed15fb715dfa7a24fb574f2985b2bc9ce11cf8452dced8882e8061c4b781a3013434a2ebfd82515ae676373cd0ca00bd3b6d30974335094f202cef7cfd3f749f5be119c921f5ead1806a82df175c499d379823d3bd1d9cf1bb442e0604500dd03549528c9876823af5f9fac03ced5ea3242203854a27ff6fba6337633dd8977c32570750b341938c832fe4e232d120cbd4cb555a047c15bc2e84225262ae6385917d19cc8ca6a8f31686edf74a40652bd5ea3b4e59c2bf5a5f30fb9a5405bc05c6e74b31cdb17b0c212fb85687fdcb7d4bf4c9d38e00a2377740e74a00f4752936c3cf1d8a804ac4ddfe425794ae1f79b52cae7352001e7e77d7f42dba228138c155ac14a0a49099501df29cf177830cae4565903484dee6a609a5ce12fd899218733b03dbee6440e517bfe4eadd68d8c3b9cdb4ca893c515c683fef4d3ae583cd14083194dff16f0595388b0360e1a2d6e4b789210244e38dd8e9c8e52ab9e96804c37fa23bd94af8e6207e62494c89bc23a302c7f5d12f5e03e143ef44dff4b14b36851e3f54fa53eed3ff081d8044288b44482de002308e151b6eb6ac0c4c9744c93bdb5ea5fd4ad3111a038ea99bdd7ad9034c0077bdcd7f94d75d9b17c4c2922385d0ac2a1d82cb40a416a1d25e4c8917259f726771134470bfed3d23d9796cc7c96da3823ce08461ee88d92a81de706e66b0d8af3a427b14edb724f498a4e00b5fa71550c5bba05b6f0921d3b113911924dfee14fa81e2ac7729a29d1eec313b2589df6dc7e3c9123f9b37ef28107d084116c66470fb3df00fd25ea316fe8e4a67f472c1dc4bfc08834e5cd20edf5374a74aec791d439336c77d945615b86132da4e358d4abac628a96d9a0124140629896da03125a5e8c8cd2112391f1d6a0311ae875c8e61bc4e7e3714969315d0846ca234cf44820a9723893a12a02e689c01cf8639b9cf71562fd2023a9c677870ea7e51955d4f860e806e813a38d0f2b662143ad7052ad861634b5b0f81a9c6b6183e3a9a73b2034f9c15bf43b10b6180841fc54d1d5bf6548c7b112f36842eaedb1ba23e2d3c2cd8b275714d8c73fe37141f5e8e332b982fa7caf7eb8350dd1c0df04d30ab09a523545d0f7ea2fd88a851040338c719931e3488e9b462e4c6d658347f3e7686d54b20e480fe0e666d21645429b78f020c2d56dc40c7452ac1f365baa36d8af1bb61e3b05e5f560db05a150adbdf983f4971c6dbfa8b7b4990250100e20aa7ecfb42aed68d9ed33efa8564cf654b45dfad83216653f20c3ad1e7605885a1272baa8c9039a65407640ea1361c1a981fce95db1c8b0aea35068b5122712b2c566c4b568f65fc58f979079a24664e8e68f15bb76574a6652a9b30d6e63687189ad70abb4fdadc993d5fc6e60d936f1276636ed23b140df15cb78b07500130decc4d054860658ed3c69e44d8500ea76e53f6f1d44a9820abeaaabca1c0ffad9762baf9052d73b9ead48ac6b75d929e978ac241e80d4d683eae174b04a69ee2bbdd09ca17e9a0c85b36a0d6eccf2ff36c8684ae023b36b1423439b131f3d881246da5f22f686de829e708f88e231eb291be77b23c1285ac3f63d7c0a061bde45743bb849d5a4c5251b0e0588546d662988c811fad1300fddb5bfe57cece7812bdc02ebba92a254a2743fc5b8ad431a460f8e07c27b9e084e06e33059d3a896077cc21581843f69f4af1aa11d808f4cfdb07b66e5fb88ec9aff14137f452c241ba8c441341c941ec791fead20ee3d9bdeb06cf6e0895861b9457cb6e9d6332d2a62894b3157be3e2244aa87cd0a39299a448bbc328dce6d6fc44dcd644054081aa7c5b90fb7351d77fb160f203ac69b81de464e78033c7c98b5ce11519ef63e8889d5d8d455a13e6c88105b49d63cb31c758f5a7ed289effd14c87af7c37aa9f74a403c801a228ba193c4a7a4784a6f9b115d0e86ae0ecd8bef2d9c27a5a0acf5d601f654ae2480992e9bfd8fe9d593d5ac81c45ff4aeff769bc1e3b17fd0558c97e28918d17f2451b7710fe0fd75f3e632e337a137f8c11ce7c3f2f8da7eeb01040c0ed11984b7ca336936831d2db98c291e52e8b99d916408fa149a235530eea3dc1015b10a04bb01e721aca77328264f2bc3a025888923fe9932c71495c4d60d48616b3711a40221902e837d5e660956df9a30a50527c729782f04d030d0879ef9f27b3616fc23f5d865711671bb182c0d796cddc17be3d20bae35aade83085369855ced575ee546e25d454758932fca08ed6209ab8dca18144cff5ffdc4c06a96a61b55699fedab6ec64662b7076a207a4182f31def325abf53eaa0523a35065ecfc0676c3a8e2f717b15adfa9dc177e58422865a0d1266d0d33a74f0d02f0f6bcb88af4b7a832f9c8fde17414e88ae19bcc126c98c2ebcf9a3bbfb213da4200ca5d348a07f326e906a65be7798d666320cee4bc6de4d545a0dc23901c1a535027e93cbe076b8696c01499b1aa1a0bd19829d974e6adc7451dbac8e851027d1690098de56a5649c505946e836dd9308d786ad4926b78acca466eaeb994b578162058d325d4e63e5b0ba08cf0a5d61d3b4275e5b8b67d436442a8c48d5cfe35511e909e70c9fe6750c465af5502450a5b893d67ea8ed401402aa40ccf424afd60cadf5d8fed5c6ef41fab76b55290bcd0cdc8fd7e0858bf8e913bc4683ebe8ef52b86b92a00fb7610e6a28668fcc6ce7f099e85041dd9b0fcdc83199a02bcefbb0be4b05774d1dc362618c279affc9af63a5cc575671db00170075b103985dad2299fcdc061e6c10872535c58405636b89a9964ecb6f59657b68b8e70c6563ec2971374f60075a85e193860deccd08be49ff1e4d8141d045752305c8a6a6b20d6ee0df612253bef5fb32d14bc3fe266b9337ba00c44fc31d835e7b77ee79261143dfea8c913ee23fc471b704c4c8bc2f5f2962e743b6deaae0bcc6b3b1a7cccb6b9a888ee6cbd8b5675b72271a76231def5d3569ebec35f56b21ca126abecf71bfbe80f3797032ce1e41d875b6006aa778a4eeda52592c6570eb28307ec7697fff4654567fbee2beb0a935b0c625adad9a4e01a4123dccc40582d0e43849aba3747aa228900135f4486365d086ec681e1baddcad481c57b9ed650210dbb5c5d29c34535a576751c7d9e0a7e125b20fff1e9c1832dc5b42f5152ed7c57f8d464c65c40e6bf32edf207eac0ad181a420127a48a97931a01216f45791ec123c669eeec1bc4a0a058e64162accc6cfcfe2466afc4136c76b7d5c3ae4dffb118097ff6cc994d07936bef3a235ee2c8bea03da1ea21afbfaf7dd2025ad6da9b7458b009f44eb3b7540cc3aba12edaa703ef2aa964a258d225b5c4cddf34a81eaded807a6e31bd74c1b1e2f4447118dedc4f56a13ff2e15c71167f7a11d31714da7eb5803c64d86a407dcaa37f0a0559c9c081d28b7c337813e40249c2b88aa90427eec4b584e90ce833c473c205c7b548074be277ac1237666b7418d4abac535edf343724a5d8c8d673945d7c848f716eb9e2c6c289a84f2141a2ae800aec8a7ca31230c12f666bed6cdabffeb9f4a81d0f5698a50e356a12a327b032ef1887bf359ec093750ca18c0f3e8ad972f86fe762eb6f9b751fb2bc7fa270d7a01fa848fef480c5f27c7f43da685609520b522ef0d051422214bd5637e9d9cac7bc3ca76f17763cbbb87c86d9a83e74d9022b22150045de75b76aa5ab7570eb9208b1f189310a0f21eae614d5c7f73a7341bb2b9dd26a5b6eb1dc48b47e6142beccc149d594fefa47c6411a698a811f1519fc568b1108ef0b40de67c2279651710c600951a496b0d164441b6dc106e7eb80d2d4c5adedfae63152146f9a0a5e4c38c3fc12ae804c21a1337999c581fa036c3de34c868eb3b208a0c77eec06c1b0512f531bd0bbcf52732b278c2a4ba23c538ae90207d27d87412dd6fc2ce2765da2cbd9bfe72c99b335368cf3d55cda6c7118f21a1b7208f4cb948fcae5bf5db9f7f377cb74352eebb70c461088bd6d6c055d84bc902ef49f9cd66b8a16376b0c911b2a250c0141fd462600854ee953efa90dd8832e4c6d63d3c4e109549c371ae5e25e4a654726475a9690e89a38647a43a9340506af885d8b421090fcdef258f01e538151dd1797d0ff52adf98e6578e0d4993301af4180dd3968e4da5a4f8bcba9f14959d9470b9887de124f8d29d21d1d55d5572e722abde996b25c629f66e2c2bab8a103ad63b18d2c062b75a9141012631b0cef7464c701be5fe67229e7c1dfa3196332fd1f9f3b919aad194460987cc1035a2f38bba5130daf0f1172f99b105a250b0ab092652d4b892ee39b372a4b7870beb5479dc941bb19dcefef37bed33d5e4ab58823ba938eab939af75205c2bc03adb48ba86a787144a7497f2ee63124a0c970c0b96ee3460181d17e018a8de99027fe18e228b5de064b4a7b38c622a80b6682f909245492b46e6adec8bde3f90d9d73073750f6e6db39991553df9f1fe6aefd655594a648eb7b1f1fcb2ac72b394f8864eb3a0b5037be4832c9f5b1ef6232f081be37420540f66c6187ff3d4a88664eb4e94a4fcec95d81c26b9452b03fd0a23e648dfabc4d2deb4920d7fd472e1528977e98f2ab5054933e78d0123fc0ef81d0882a018e4a40748b097209da32f5168d3046642a436913285d665705d35f4e04e8752549bcecb486bac92aa9edcd4389ad39fd1b54c9b840e7ae6d2d7325b103d1fb9dfb35c58b1b950eca0979f3880b8c68eab60b4817a18469e3d92789cb8a9761e0112164e7345cb61b6593544fb8c8473abef0ccdb5dfa76a8d2d7e38ff96c6e06fed9a58c4457243745d6a3f01d719503367ce1c2a1b73834eac15461cbb855603c9a68cfaa440c29d5f75d94dc3234f91ece31c39f17d52124b1545245b45fd7715c014b863b1cef45bc02b45bbc5a7a5254c00907f27fa28bef6f125fdadb3dc8c39e9e1a0df837c4a702eef25c3e88c98809106f9e0deb0eea00952cd95f723d7c1c234576c387902c6cdd29c695e4302f10c5cf7428d286a93bcd93da4d258e09668ed5df1f6d00a6c2431cf1e16ff8c2c076732bf89d4962a74091dd2a736b4ed096dbf2b134dab6645b4ec68dde7c38f715cf701ad31227531a5bf19c7fb6d21c59890926202d6d0194eee7928e72e6e75e3cb197530a567f44785d2df05b0e6074915cf7de9db38cfa383594e20daa8b0dc5fae3cbfd3e686582692b21417d96859af827c382564d1541a46f82ca14b1956f1661b08ce91c7b409e3cd5a23299f3ad6d4389564e267ff69caf1d4c5a801a4394a470223675ce2050bc2eb9ba665980121c07807086f379fbd8aa13ce21518e7edcd98fc5c9c801a90069de36646724554d71a086e4ce61220ce87b3494f36b989d9364b0f1ff47b665dbb7c78be48f52449fcfba7adf56daa91278cade768159ee1ba8a1adfdea026630bd9d4262e2e7e9899cf75aeab6d824aa88f4823d80093de6c8894d377a93df05c7d70e6dd2c11bff56e4adc4504acb32c3792a10a92ee2f73af7751ace0d223b4987f370a1f3641976d32978279b9d6da976aa7189770cd407b0ae940b98b21764df65a327a7e41e71d220c81c18c8c4d8c420f3f7ce610d7dc4d3596df14f3357078ceb620bf961e917cc1a8f9d823b7b7d0167700be7669b0a8e9721441c4cf53218851f4288eb79e956391389cfd51e10b7afe232f178deffeb55c432b7b8353bd23dbb5c3ba219fec44864c2bb4ec17c3ae8f2ca990055016a4a7ccf71cb95fd44af278da9723091ec9f18a1cc1d551873dee08f2d31fadfb406707fabe25cec03a2d420d0709eb39e9ac43999275308d1ec79bc56c0bbb536329c90264590ca5c829153685626d44206894c8e71180becc9c356f3b2f4b829d27d43428b466596845619b70747ef51992157cd94591c73d5d4df60fdf5cc3dec8ea7132f51e2f3d535dd36e56fc53405314b605bcd4668624ff0d5660b1017a616b5694c041f30c44c3e26b7d96856dc3fe21ba6cc3ed3c92c5aa4b29df2deceda99428a5f5ca996b657f0c00076c5c50c04acf71dd7d62bcaad6f2b2da7c74d730aabfbba5d67ed43c3fefe16eabfd7a9fb5815363c0f4a25ea0d8c86adff6a5fed54d5d72ac7c1a7f91d5d0324786b79d9a447944130f4d945731e1ced24b431496e0caa57ae692d596789323e69250480823bd0773f45e61c14258c6e985d3d1a00ccbd0669a309d610ef9f17ef51324d58c58d37e98c5f585c68108656a381ab9a8104ea9868db336d0f8ab5a0232bf6bb6cfbc92f0d72532446d9fde2d7760190921432aec0ecd06fc1da17741f4c60f28371e175f38e3b9145c9c27dc70a9f0aa5bf960f33cf4bcafb7252484f69b7b9bd7faccc391efb920c45643844541abd078f6cc19069ffabd8575855063fa6924c830f17b1fd653d88d92fc5bb11c568a017730e67b3ade8b542ba035b3702d818958fd365ed713864fa3e5b824afede5cd5de3dd0faa9f25f6f6021b04af4129cbe75066f3ff1426e050e41ff2e0dd1f469d0bfcf3e57bfd78240b391b50305bd71de2442f4a946f86a15f1475f117318d66b4ec4a7f97bb4c9fa26f27fa7b3e065d59b5f3335f2dc33b0ad2fdf22f889f8f29fdc88f695ea5f3cea0d8e430f51bbf2e7bdc075ac49c8977c823d6c9039ee5c6f582d3ddca6111fb719e6b371e500a6bffdb1545ba35c91576cc70911512a441f9fe6a3a3f247d959ebdbf9ffa974dc5e2dee193761e2902175b2a1bd2ea4e2d9bfbfd3654b7ef43610b6ab0239b6fb6d548cf75cfb72fae3a525bef2025caf78df09ecead2e354fb86cc3db047f00578debe779e17b7d76a2342de91807e9818d952cf486f1a13231c316c8af617e4668c530d8f5bd1b1420f0d572f40739d9fd88fbf45a1d59ddae7a72884da53325e1cda9a20f61d1bd7f62788076b04d66be7a9507bca1a400aaa43e9f307cce09b7645e0dd979730fc6fb5f7ab922fe16435e1d60bc5c557273667b3bdc1489aff25a21dd3d4bb0881dd51b55ec2b2df604806ecfa67ede4aebfbd74b3ccf81010ad7e4dcce49ad5e568bdb41ff550224e5057f7507f5c6fa4af557da73f8aee3dca1ec6e85d0f502a9c89275b830b94aa64b5d854641def4ef8ed0e7f9098f62693a6741a98e68c2d747f363e590c08240a908a9daf2bb54ab6f85219986f78cf195e7f01d7d0029f6f3c46642688aa8a673f59f8bb0fc62ce995103350e9d5b5d88d0639786c012e3fb9dd5ec967c7eb0bd7d4737f3b78c88d405e179be0e4b415b43c452a8ac034f14ae9be28aca7cc6a2e36e1bc2f4272ad6be3772cb72046139e84bc472c74b59665ee3571273ce0a058c54d656b20bd19d5882d96b1117b905396ce32faaee610087002697181a0e2477057772df8b1bb9774e223cc500a851cb34158a8c1b79f4b4ea8a781d630c83397fed7ed7481140099a63d31bb440a4249a79d346f997df5306d83c3faa16b7e96b07c07b8f0de48a8b0713efc95c271397b882a459da39aba28e41fac045cd4c338191856e881805aab912dddfa4d1f86b1322662a8bb5a387764a3973cc73232870ba2f820a407fbe2787cfa8da5d6ff5bf5e708a37052122889bbe3546830dec1a607f28f801158f21cbccaad3f2b08d89329b14aacde60b7b9c75b10d492dc1edf093a17b145e8c9b81920a64cd5774286e79cc4f684151fa3b6e05b10f9f46d92684e784432a2ba1c030a96c89b8b4c4b3bf263de80195a2dea673c374814ce62a3e7e34b408e2a23fa39ba0b2af4108fd2692eadf2f76297d9168dd31c2ed6b4049afe8d969b28d5d42813d4b45b6eca3e837a78f917ec2d70a1dd31f16ba01cd3726536fc2fc855d9ab025901dd15c034d662d0897bb791737054e3950309c43dff7c8c6010a95dca33d6d92b61ae4fcf78badcdf694636e0d645e3bbae54d159b7a9ce6e04ddfa2bb459847f8d383c4450505e241e00b10f025e1437f88f3accd4fd26f021a48223ebe6a2a00c1e683bd9d58695ed45efc2ad1e29407df089f0f10eb2614011ed9ce96f2961573c0ff48801fe253f68d2fb4b0c3cf7d71160d569a0d6c0e25bf0c3188bb1ee6d402cef69c9416aec3e95ebf5fd9d8e8260c1a238f35815105c89a8edd6cf61204fa5ee7f2a6a75e5d7289886debd4fca55db2f2874668f5614821d662e8490656286ef1bf682d0d87c36bdcbb2b1579d02074ffefe878af2b0d3f68affc6f5ed287d0b283dfb9a9a219b60c9a2eff5eb22642a554b2bdb8110c4ef5099a7826e6eecff9190f62434ed843097397b8c43b8838497ea3bcfef8c5dbaf1b7b52a815560eedd40b27e2fca3cca3b422917600fcbe57e1e8eb227c991ae6d3b8dfd82f453e552e5ef59b40d5609ffb8f3fe3c480f23c7c96b59314844350d4c82f3a556efb02531657584ee4023e8bd1e918eda957a14a8ad4c94acd2e6dc290bdd9c4a6c227d504d387f97f6</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-blink">
      <input class="hbe hbe-input-field hbe-input-field-blink" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-blink" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-blink" data-content="您好, 这里需要密码.">您好, 这里需要密码.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>面试</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>encryptalg</tag>
        <tag>面试算法</tag>
      </tags>
  </entry>
</search>
