<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>密码testpassword</title>
    <url>/posts/d5cdaa49/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">
  <script id="hbeData" type="hbeData" data-hmacdigest="ff70b20ab201b4a3ad0b6750e19f901fa1443cb40589f1cf72d2c936a2eecebe">4c7001934e3e5a2a8fd08e6c38ff7447bba297e9690d41d48dabbda263c1454a84a1183e69110c19be8abbba96073d6f</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-blink">
      <input class="hbe hbe-input-field hbe-input-field-blink" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-blink" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-blink" data-content="您好, 这里需要密码.">您好, 这里需要密码.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>test</category>
      </categories>
      <tags>
        <tag>test</tag>
      </tags>
  </entry>
  <entry>
    <title>test_code</title>
    <url>/posts/726c1a57/</url>
    <content><![CDATA[<h2 id="三维dp"><a class="markdownIt-Anchor" href="#三维dp"></a> 三维dp</h2>
<h3 id="dqwdwq"><a class="markdownIt-Anchor" href="#dqwdwq"></a> dqwdwq</h3>
<p><mark>dwqd</mark><br />
<img data-src="http://hz-picbed-xxh.oss-cn-hangzhou.aliyuncs.com/img-bed/3-1Q113131610L7.gif" alt="顾客购物程序的类图" /></p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msubsup><mo>∑</mo><mi>x</mi><mrow><mi>s</mi><mi>d</mi></mrow></msubsup><mfrac><mrow><mfrac><mi>a</mi><mi>b</mi></mfrac><mo>+</mo><mi>a</mi></mrow><mi>α</mi></mfrac></mrow><annotation encoding="application/x-tex">\sum_{x}^{sd}{\frac{a}{b}+{a}\over{\alpha}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.37988em;vertical-align:-0.345em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9890079999999999em;"><span style="top:-2.40029em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">x</span></span></span></span><span style="top:-3.2029em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">s</span><span class="mord mathdefault mtight">d</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.29971000000000003em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.03488em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.0037em;">α</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.5508em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mopen nulldelimiter sizing reset-size3 size6"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.6915428571428572em;"><span style="top:-2.656em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">b</span></span></span></span><span style="top:-3.2255000000000003em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line mtight" style="border-bottom-width:0.049em;"></span></span><span style="top:-3.384em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">a</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.344em;"><span></span></span></span></span></span><span class="mclose nulldelimiter sizing reset-size3 size6"></span></span><span class="mbin mtight">+</span><span class="mord mtight"><span class="mord mathdefault mtight">a</span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p>
<a id="more"></a>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mo>∗</mo><msup><mi>b</mi><mn>2</mn></msup><mspace width="1em"/><mo stretchy="false">(</mo><mi>b</mi><mi>ω</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">a*b^2 \quad (b \omega)
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.46528em;vertical-align:0em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.1141079999999999em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:1em;"></span><span class="mopen">(</span><span class="mord mathdefault">b</span><span class="mord mathdefault" style="margin-right:0.03588em;">ω</span><span class="mclose">)</span></span></span></span></span></p>
<p><code>dwqdnjk</code><br />
<code>test for ms code</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @Descripttion: 111 https://leetcode.com/discuss/interview-question/1488563/microsoft-on-campus-2021-india</span></span><br><span class="line"><span class="comment"> * @version: </span></span><br><span class="line"><span class="comment"> * @Author: xxh</span></span><br><span class="line"><span class="comment"> * @Date: 2022-01-23</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;dp;</span><br><span class="line"><span class="type">int</span> dd[<span class="number">100</span>][<span class="number">2</span>][<span class="number">200</span>]=&#123;<span class="number">-1</span>&#125; ;<span class="comment">//pos - -x/y - value</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; h,<span class="type">int</span> pos,<span class="type">int</span> rx,<span class="type">int</span> ry,<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pos&gt;=n) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(dp[pos][<span class="built_in">abs</span>(rx-ry)]!=<span class="number">-1</span>)<span class="keyword">return</span> dp[pos][<span class="built_in">abs</span>(rx-ry)];</span><br><span class="line">    <span class="type">int</span> v1=<span class="number">0</span>,v2=<span class="number">0</span>,v3=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(rx&gt;=h[pos])v1 = <span class="number">1</span>+<span class="built_in">dfs</span>(h,pos+<span class="number">1</span>,rx-h[pos],ry,n);</span><br><span class="line">    <span class="keyword">if</span>(ry&gt;=h[pos]) v2 = <span class="number">1</span>+<span class="built_in">dfs</span>(h,pos+<span class="number">1</span>,rx,ry-h[pos],n);</span><br><span class="line">    v3=<span class="built_in">dfs</span>(h,pos+<span class="number">1</span>,rx,ry,n);</span><br><span class="line">    dp[pos][<span class="built_in">abs</span>(rx-ry)] = <span class="built_in">max</span>(v1,<span class="built_in">max</span>(v2,v3));</span><br><span class="line">    <span class="keyword">return</span> dp[pos][<span class="built_in">abs</span>(rx-ry)];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">f</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; h,<span class="type">int</span> pos,<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    dd[<span class="number">0</span>][<span class="number">0</span>][x]=dd[<span class="number">0</span>][<span class="number">1</span>][y]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = x;j&gt;=h[i<span class="number">-1</span>];j--) <span class="comment">//x</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k=y;k&gt;=<span class="number">0</span>;k--)&#123; <span class="comment">//y</span></span><br><span class="line">                <span class="keyword">if</span>(dd[i<span class="number">-1</span>][<span class="number">1</span>][k]!=<span class="number">-1</span>&amp;&amp;dd[i<span class="number">-1</span>][<span class="number">0</span>][j]!=<span class="number">-1</span>) &#123;</span><br><span class="line">                    dd[i][<span class="number">0</span>][j-h[i<span class="number">-1</span>]]= <span class="built_in">max</span>(dd[i<span class="number">-1</span>][<span class="number">1</span>][k]+dd[i<span class="number">-1</span>][<span class="number">0</span>][j]+<span class="number">1</span>,dd[i][<span class="number">0</span>][j-h[i<span class="number">-1</span>]]);</span><br><span class="line">                    cout&lt;&lt;i&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;j&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;dd[i][<span class="number">0</span>][j-h[i<span class="number">-1</span>]]&lt;&lt;endl;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = y;j&gt;=h[i<span class="number">-1</span>];j--)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k=x;k&gt;=<span class="number">0</span>;k--)&#123;</span><br><span class="line">                <span class="keyword">if</span>(dd[i<span class="number">-1</span>][<span class="number">0</span>][k]!=<span class="number">-1</span>&amp;&amp;dd[i<span class="number">-1</span>][<span class="number">1</span>][j]!=<span class="number">-1</span>) dd[i][<span class="number">1</span>][j-h[i<span class="number">-1</span>]] = <span class="built_in">max</span>(dd[i<span class="number">-1</span>][<span class="number">0</span>][k]+dd[i<span class="number">-1</span>][<span class="number">1</span>][j]+<span class="number">1</span>,dd[i][<span class="number">1</span>][j-h[i<span class="number">-1</span>]]);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mx =<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;<span class="number">100</span>;i++)&#123;</span><br><span class="line">        <span class="comment">//cout&lt;&lt;dd[n-1][0][i];</span></span><br><span class="line">        mx = <span class="built_in">max</span>(mx,dd[n<span class="number">-1</span>][<span class="number">0</span>][i]);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="type">int</span> my = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;<span class="number">100</span>;i++)&#123;</span><br><span class="line">        <span class="comment">//cout&lt;&lt;dd[n-1][1][i];</span></span><br><span class="line">        my = <span class="built_in">max</span>(my,dd[n<span class="number">-1</span>][<span class="number">1</span>][i]);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>(mx,my);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;h=&#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">4</span>&#125;;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">8</span>,y=<span class="number">9</span>;</span><br><span class="line">    <span class="type">int</span> n = h.<span class="built_in">size</span>();</span><br><span class="line">    dp.<span class="built_in">resize</span>(n,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="built_in">max</span>(x,y)+<span class="number">1</span>,<span class="number">-1</span>));</span><br><span class="line">    <span class="built_in">memset</span>(dd,<span class="number">0xff</span>,<span class="built_in">sizeof</span>(dd));</span><br><span class="line">    cout&lt;&lt;<span class="built_in">f</span>(h,<span class="number">0</span>,x,y,n);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>test</category>
        <category>面试题</category>
        <category>MS</category>
      </categories>
      <tags>
        <tag>test</tag>
        <tag>dp</tag>
        <tag>ms面试题</tag>
      </tags>
  </entry>
  <entry>
    <title>yaml语法示例</title>
    <url>/posts/34fc2379/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">
  <script id="hbeData" type="hbeData" data-hmacdigest="75cc7945f0190a6df86e1545aec5bf0f9336b15c28b38d82970ed72009aeb283">16c747dc6985ee4fafa2dd616ad7bafaab8a56bd6dcf72a9a0497175f435dd9a</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-blink">
      <input class="hbe hbe-input-field hbe-input-field-blink" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-blink" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-blink" data-content="您好, 这里需要密码.">您好, 这里需要密码.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>test</category>
      </categories>
      <tags>
        <tag>test</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo setups</title>
    <url>/posts/b763a0b1/</url>
    <content><![CDATA[<h3 id="centos-关闭selinux"><a class="markdownIt-Anchor" href="#centos-关闭selinux"></a> centos 关闭SELINUX</h3>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$ </span><span class="language-bash">setenforce 0</span></span><br><span class="line"><span class="meta">$ </span><span class="language-bash">sed -i <span class="string">&#x27;s/SELINUX=enforcing/SELINUX=disabled/&#x27;</span> /etc/selinux/config</span></span><br></pre></td></tr></table></figure>
<h3 id="创建tags-caterories"><a class="markdownIt-Anchor" href="#创建tags-caterories"></a> 创建tags、caterories</h3>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$ </span><span class="language-bash">hexo new page <span class="string">&quot;tags&quot;</span></span></span><br></pre></td></tr></table></figure>
<p>修改source/tags/index.md</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">tags</span></span><br><span class="line"><span class="attr">date:</span> <span class="number">2017-07-10 16:36:26</span></span><br><span class="line"><span class="attr">type:</span> <span class="string">&quot;tags&quot;</span></span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></table></figure>
<p>修改themes/next/_config.yml</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">menu:</span></span><br><span class="line"><span class="attr">home:</span> <span class="string">/</span></span><br><span class="line"><span class="attr">archives:</span> <span class="string">/archives/</span></span><br><span class="line"><span class="attr">categories:</span> <span class="string">/categories/</span></span><br><span class="line"><span class="attr">tags:</span> <span class="string">/tags/</span></span><br></pre></td></tr></table></figure>
<p>tags 不存在多级,cat可以多级</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">categories:</span><br><span class="line">- [Sports, Baseball]</span><br><span class="line">- Baseball</span><br><span class="line">tags:</span><br><span class="line">- Injury</span><br><span class="line">- Fight</span><br><span class="line">- Shocking</span><br></pre></td></tr></table></figure>
<p>使用katex</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$ </span><span class="language-bash">npm un hexo-renderer-marked</span></span><br><span class="line"><span class="meta">$ </span><span class="language-bash">npm i hexo-renderer-markdown-it-plus</span></span><br></pre></td></tr></table></figure>
<h3 id="修改自定义样式"><a class="markdownIt-Anchor" href="#修改自定义样式"></a> 修改自定义样式</h3>
<p><code>css/_common/outline/footer/index.styl</code></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.footer-inner</span> &gt; <span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">padding-left</span>: <span class="number">8px</span>;</span><br><span class="line">  <span class="attribute">padding-right</span>: <span class="number">8px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="博客加密"><a class="markdownIt-Anchor" href="#博客加密"></a> 博客加密</h3>
<p><a href="https://github.com/D0n9X1n/hexo-blog-encrypt/blob/master/ReadMe.zh.md">https://github.com/D0n9X1n/hexo-blog-encrypt/blob/master/ReadMe.zh.md</a></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$ </span><span class="language-bash">npm install --save hexo-blog-encrypt</span></span><br></pre></td></tr></table></figure>
<h4 id="对博文加密"><a class="markdownIt-Anchor" href="#对博文加密"></a> 对博文加密</h4>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">Hello</span> <span class="string">World</span></span><br><span class="line"><span class="attr">tags:</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">作为日记加密</span></span><br><span class="line"><span class="attr">date:</span> <span class="number">2016-03-30 21:12:21</span></span><br><span class="line"><span class="attr">password:</span> <span class="string">mikemessi</span></span><br><span class="line"><span class="attr">abstract:</span> <span class="string">有东西被加密了,</span> <span class="string">请输入密码查看.</span></span><br><span class="line"><span class="attr">message:</span> <span class="string">您好,</span> <span class="string">这里需要密码.</span></span><br><span class="line"><span class="attr">wrong_pass_message:</span> <span class="string">抱歉,</span> <span class="string">这个密码看着不太对,</span> <span class="string">请再试试.</span></span><br><span class="line"><span class="attr">wrong_hash_message:</span> <span class="string">抱歉,</span> <span class="string">这个文章不能被校验,</span> <span class="string">不过您还是能看看解密后的内容.</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="meta"></span></span><br></pre></td></tr></table></figure>
<h4 id="对tag加密"><a class="markdownIt-Anchor" href="#对tag加密"></a> 对tag加密</h4>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># Security</span></span><br><span class="line"><span class="attr">encrypt:</span> <span class="comment"># hexo-blog-encrypt</span></span><br><span class="line">  <span class="attr">abstract:</span> <span class="string">有东西被加密了,</span> <span class="string">请输入密码查看.</span></span><br><span class="line">  <span class="attr">message:</span> <span class="string">您好,</span> <span class="string">这里需要密码.</span></span><br><span class="line">  <span class="attr">tags:</span></span><br><span class="line">  <span class="bullet">-</span> &#123;<span class="attr">name:</span> <span class="string">tagName</span>, <span class="attr">password:</span> <span class="string">密码A</span>&#125;</span><br><span class="line">  <span class="bullet">-</span> &#123;<span class="attr">name:</span> <span class="string">tagName</span>, <span class="attr">password:</span> <span class="string">密码B</span>&#125;</span><br><span class="line">  <span class="attr">wrong_pass_message:</span> <span class="string">抱歉,</span> <span class="string">这个密码看着不太对,</span> <span class="string">请再试试.</span></span><br><span class="line">  <span class="attr">wrong_hash_message:</span> <span class="string">抱歉,</span> <span class="string">这个文章不能被校验,</span> <span class="string">不过您还是能看看解密后的内容.</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><a href="https://theme-next.js.org/docs/theme-settings/">https://theme-next.js.org/docs/theme-settings/</a></p>
<p><code>zhumeng2021.2\node_modules\hexo-theme-next\layout\_macro\sidebar.njk</code> 对sidebar修改</p>
<p><code>zhumeng2021.2\node_modules\hexo-theme-next\layout\_partials\post\post-related.njk</code>对related修改</p>
<p><code>C:\Users\42273\Desktop\hexo_blog\zhumeng2021.2\.deploy_git\js\schemes\muse.js</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (event.<span class="property">target</span>.<span class="title function_">matches</span>(<span class="string">&#x27;img.medium-zoom-image&#x27;</span>)) &#123;<span class="comment">// 删去clickingBlankPart||</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">hideSidebar</span>();</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>
<hr />
<p>TODO:</p>
<ol>
<li>
<h4 id="configuring-favicon"><a class="markdownIt-Anchor" href="#configuring-favicon"></a> Configuring Favicon</h4>
</li>
</ol>
]]></content>
      <categories>
        <category>环境搭建</category>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>【每日】1020. 飞地的数量</title>
    <url>/posts/48f31485/</url>
    <content><![CDATA[<p><img data-src="http://hz-picbed-xxh.oss-cn-hangzhou.aliyuncs.com/img-bed/image-20220212141050874.png" alt="image-20220212141050874" /></p>
<blockquote>
<p>采用多源dfs的思想，每个通往边界的区域经过dfs后设为0，最后统计1的数量即可，只需要扫描边界处的连通分量即可。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> dir[<span class="number">4</span>][<span class="number">2</span>]=&#123;&#123;<span class="number">-1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">0</span>,<span class="number">-1</span>&#125;&#125;;</span><br><span class="line">    <span class="type">int</span> m,n;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; grid)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(grid[x][y]==<span class="number">0</span>)<span class="keyword">return</span>;</span><br><span class="line">        grid[x][y]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> i:dir)&#123;</span><br><span class="line">            <span class="type">int</span> nextx = x+i[<span class="number">0</span>],nexty = y+i[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span>(nextx&gt;=<span class="number">0</span> &amp;&amp; nexty&gt;=<span class="number">0</span> &amp;&amp; nextx&lt;m &amp;&amp; nexty &lt;n &amp;&amp;grid[nextx][nexty])<span class="built_in">dfs</span>(nextx,nexty,grid);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numEnclaves</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        m = grid.<span class="built_in">size</span>(); n = grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;<span class="built_in">dfs</span>(<span class="number">0</span>,j,grid);<span class="built_in">dfs</span>(m<span class="number">-1</span>,j,grid);&#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;<span class="built_in">dfs</span>(i,<span class="number">0</span>,grid);<span class="built_in">dfs</span>(i,n<span class="number">-1</span>,grid);&#125;</span><br><span class="line">        <span class="type">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> i:grid)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> j:i)<span class="keyword">if</span>(j)cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
        <category>力扣</category>
        <category>每日一题</category>
        <category>dfs</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>【每日】688. 骑士在棋盘上的概率</title>
    <url>/posts/2a64def3/</url>
    <content><![CDATA[<p><img data-src="http://hz-picbed-xxh.oss-cn-hangzhou.aliyuncs.com/img-bed/image-20220217185416173.png" alt="image-20220217185416173" /></p>
<blockquote>
<p>思路：采用bfs策略一定会超时，因为步数&lt;=100，理论上可能的总数有<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>8</mn><mn>100</mn></msup></mrow><annotation encoding="application/x-tex">8^{100}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">8</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">0</span><span class="mord mtight">0</span></span></span></span></span></span></span></span></span></span></span></span>次。因此采用三维dp[row][col][step]代表第step步时（row，col）处的概率。统计总数也可以，但是数字太大，若不模会溢出。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">        <span class="type">int</span> row,col,step;</span><br><span class="line">        <span class="built_in">node</span>(<span class="type">int</span> a,<span class="type">int</span> b,<span class="type">int</span> c)&#123;</span><br><span class="line">            <span class="keyword">this</span>-&gt;row = a;<span class="keyword">this</span>-&gt;col=b;<span class="keyword">this</span>-&gt;step=c;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;node;</span><br><span class="line">    <span class="type">int</span> dir[<span class="number">8</span>][<span class="number">2</span>]=&#123;&#123;<span class="number">1</span>,<span class="number">2</span>&#125;,&#123;<span class="number">2</span>,<span class="number">1</span>&#125;,&#123;<span class="number">-1</span>,<span class="number">2</span>&#125;,&#123;<span class="number">-2</span>,<span class="number">1</span>&#125;,&#123;<span class="number">-1</span>,<span class="number">-2</span>&#125;,&#123;<span class="number">-2</span>,<span class="number">-1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">-2</span>&#125;,&#123;<span class="number">2</span>,<span class="number">-1</span>&#125;&#125;;</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">bfs</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> k, <span class="type">int</span> row, <span class="type">int</span> column)</span></span>&#123;</span><br><span class="line">        <span class="comment">//tle k&gt;=10</span></span><br><span class="line">        <span class="keyword">if</span>(k==<span class="number">0</span>)<span class="keyword">return</span> <span class="number">1.0</span>;</span><br><span class="line">        queue&lt;node&gt;q; <span class="type">int</span> steps=<span class="number">0</span>; <span class="type">double</span> res = <span class="number">1.0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="function">node <span class="title">tmp</span><span class="params">(row,column,<span class="number">0</span>)</span></span>;</span><br><span class="line">        q.<span class="built_in">push</span>(tmp);</span><br><span class="line">        <span class="keyword">while</span>(q.<span class="built_in">empty</span>()==<span class="literal">false</span>&amp;&amp;q.<span class="built_in">front</span>().step!=k)&#123;</span><br><span class="line">            <span class="keyword">auto</span> cur = q.<span class="built_in">front</span>();q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> i : dir)&#123;</span><br><span class="line">                <span class="type">int</span> nextrow = cur.row+i[<span class="number">0</span>];</span><br><span class="line">                <span class="type">int</span> nextcol =cur.col + i[<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span>(nextrow&lt;<span class="number">0</span> || nextcol&lt;<span class="number">0</span> || nextrow&gt;=n|| nextcol&gt;=n) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="function">node <span class="title">tmp</span><span class="params">(nextrow,nextcol,cur.step+<span class="number">1</span>)</span></span>;</span><br><span class="line">                q.<span class="built_in">push</span>(tmp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;q.<span class="built_in">size</span>()&lt;&lt;endl;</span><br><span class="line">        res = q.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;k;i++)res/=<span class="number">8.0</span>;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">double</span> f[<span class="number">26</span>][<span class="number">26</span>][<span class="number">200</span>];</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">dp</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> k, <span class="type">int</span> row, <span class="type">int</span> col)</span></span>&#123;</span><br><span class="line">        <span class="built_in">fill</span>((<span class="type">int</span>*)f,(<span class="type">int</span>*)f+(<span class="number">26</span>*<span class="number">26</span>*<span class="number">200</span>),<span class="number">0.0</span>);<span class="type">int</span> step = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;j++) f[i][j][step]=<span class="number">1.0</span>;</span><br><span class="line">        <span class="keyword">while</span>(step!=k)&#123;</span><br><span class="line">            step++;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">auto</span> d:dir)&#123;</span><br><span class="line">                        <span class="type">int</span> prevrow = i+d[<span class="number">0</span>];</span><br><span class="line">                        <span class="type">int</span> prevcol = j+d[<span class="number">1</span>];</span><br><span class="line">                        <span class="keyword">if</span>(prevrow&lt;<span class="number">0</span> || prevcol&lt;<span class="number">0</span> || prevrow&gt;=n|| prevcol&gt;=n)<span class="keyword">continue</span>;</span><br><span class="line">                        f[i][j][step] +=f[prevrow][prevcol][step<span class="number">-1</span>]/<span class="number">8.0</span>;<span class="comment">//到达该位置的前一位置的所有概率和除以当前的选择概率。</span></span><br><span class="line">                    &#125; </span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f[row][col][k];</span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">knightProbability</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> k, <span class="type">int</span> row, <span class="type">int</span> column)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//bfs(n,k,row,column);</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dp</span>(n,k,row,column);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
        <category>力扣</category>
        <category>每日一题</category>
        <category>dp</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>【每日】1984. 学生分数的最小差值</title>
    <url>/posts/3e175728/</url>
    <content><![CDATA[<p><img data-src="http://hz-picbed-xxh.oss-cn-hangzhou.aliyuncs.com/img-bed/image-20220211134306054.png" alt="image-20220211134306054" /></p>
<blockquote>
<p>思路：排序后使用滑动窗口的思想，取窗口内最大值和最小值，即i和i+k-1的差值，取最小。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minimumDifference</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(k==<span class="number">1</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="type">int</span> mi = INT_MAX;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i+k<span class="number">-1</span>&lt;nums.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            mi = <span class="built_in">min</span>(mi,nums[i+k<span class="number">-1</span>]-nums[i]);</span><br><span class="line">        </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> mi;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
        <category>力扣</category>
        <category>每日一题</category>
        <category>模拟题</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>cpp博客汇总</title>
    <url>/posts/26f80d45/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">
  <script id="hbeData" type="hbeData" data-hmacdigest="48d4c2071a98261b91bf0f24d970df9a5ee3e1bc9449d012e30537c624463818">8c5eb7d299eb8204d1aa11d5321f1970e0702a4fa338dd1cc8a5f32ab3a638a5dfe317204ae956e092fc50bb1621e8ea08b755118da87b6340cee979b850f15388d6b14e6dbb75303be94c0ae2e6ad26eb3a75cba0265537fed2ef182633562904235b0284ffd7da53a6cf40d6b9c9fdc57a1e72ccf74d82d900b007763c0fa11de3777c888133a80ebcf422c34dfceae367d70f6a29a85a916cf04b3ed2f82eeb30bbe9fa60970f3db4e55dcb8b5662</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-blink">
      <input class="hbe hbe-input-field hbe-input-field-blink" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-blink" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-blink" data-content="您好, 这里需要密码.">您好, 这里需要密码.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>cpp</category>
        <category>cpp资源</category>
      </categories>
      <tags>
        <tag>cpp资源</tag>
      </tags>
  </entry>
  <entry>
    <title>cpp中的const</title>
    <url>/posts/4bf79020/</url>
    <content><![CDATA[<h2 id="cpp中的const更像是编译阶段的define"><a class="markdownIt-Anchor" href="#cpp中的const更像是编译阶段的define"></a> cpp中的<code>const</code>更像是编译阶段的<code>#define</code></h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> m = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> n = m;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在C语言中，编译器会先在m的内存中取出数据赋值给n；</p>
<p>在cpp中，编译器直接将10赋值给n，没有读取内存的操作。</p>
</blockquote>
<p><code>#define</code>是在预处理阶段替换，常量是在编译阶段替换。提高了程序执行的效率，缺点是不能反映内存变化。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> n =<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span>* p = (<span class="type">int</span>*)&amp;n;</span><br><span class="line">(*p) = <span class="number">100</span>;</span><br><span class="line">cout&lt;&lt;n&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;(*p)&lt;&lt;endl;</span><br><span class="line"><span class="comment">//输出为10 100</span></span><br></pre></td></tr></table></figure>
<p>将代码放到<code>.c</code>文件中，以C语言的方式编译，运行结果为<code>99</code>。再将代码放到<code>.cpp</code>文件中，以C<ins>的方式编译，运行结果就变成了<code>10</code>。这种差异正是由于C和C</ins>对 const 的处理方式不同造成的。</p>
<h2 id="cpp中全局const变量可见范围是当前文件"><a class="markdownIt-Anchor" href="#cpp中全局const变量可见范围是当前文件"></a> cpp中全局const变量可见范围是当前文件</h2>
<p>c语言中：<mark>全局变量的作用域是当前文件，但是在其他文件中也是可见的，使用<code>extern</code>声明后就可以使用</mark></p>
<p>cpp语言中：<mark>const变量的作用域是当前文件，在其他文件中不可见</mark></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="comment">//const int n = 10;</span></span><br><span class="line"><span class="comment">//int n = 10;</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">func</span><span class="params">()</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    func();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;main: %d\n&quot;</span>, n);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> n; </span><br><span class="line"><span class="type">void</span> <span class="title function_">func</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;module: %d\n&quot;</span>, n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>若为<code>int n=10;</code>无论cpp还是c语言均编译通过</p>
<p>若为<code>const int n=10;</code>，cpp编译失败（因为对其他文件不可见），c语言编译通过。</p>
</blockquote>
<h3 id="将const变量放入头文件中"><a class="markdownIt-Anchor" href="#将const变量放入头文件中"></a> 将const变量放入头文件中</h3>
<p><mark>由于 C++ 中全局 const 变量的可见范围仅限于当前源文件，所以可以将它放在头文件中，这样即使头文件被包含多次也不会出错</mark></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//module.h</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> n = <span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//module.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;module.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;module: %d\n&quot;</span>, n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//main.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;module.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">func</span>();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;main: %d\n&quot;</span>, n);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$ </span><span class="language-bash">g++ main.cpp module.cpp -o main &amp;&amp; main</span></span><br><span class="line"></span><br><span class="line">module: 10</span><br><span class="line">main: 10</span><br></pre></td></tr></table></figure>
<p>C和C<ins>中全局 const 变量的作用域相同，都是当前文件，不同的是它们的可见范围：C语言中 const 全局变量的可见范围是整个程序，在其他文件中使用 extern 声明后就可以使用；而C</ins>中 const 全局变量的可见范围仅限于当前文件，在其他文件中不可见，所以它可以定义在头文件中，多次引入后也不会出错。</p>
]]></content>
      <categories>
        <category>cpp</category>
        <category>cpp语法</category>
      </categories>
      <tags>
        <tag>cpp语法</tag>
      </tags>
  </entry>
  <entry>
    <title>cpp中指定默认参数的位置</title>
    <url>/posts/27cf2ee3/</url>
    <content><![CDATA[<p>wu</p>
]]></content>
      <categories>
        <category>cpp</category>
        <category>cpp语法</category>
      </categories>
      <tags>
        <tag>cpp语法</tag>
      </tags>
  </entry>
  <entry>
    <title>二分算法详解</title>
    <url>/posts/99d9a14f/</url>
    <content><![CDATA[<h3 id="常规二分写法"><a class="markdownIt-Anchor" href="#常规二分写法"></a> 常规二分写法</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(l&lt;=r)&#123;</span><br><span class="line">    <span class="type">int</span> mid = l+ (r-l&gt;&gt;<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(mid = target) <span class="keyword">return</span> mid;</span><br><span class="line">    <span class="keyword">if</span>(mid&lt;target)l = mid+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> r = mid<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br></pre></td></tr></table></figure>
<p>每次搜索的区间是[l,r]，因此l和r均不包含mid</p>
<h3 id="查找target的右边界"><a class="markdownIt-Anchor" href="#查找target的右边界"></a> 查找&lt;=target的右边界</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line">    <span class="type">int</span> mid = l + (r-l&gt;&gt;<span class="number">1</span>)+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(mid&lt;=target) l = mid;</span><br><span class="line">    <span class="keyword">else</span> r = mid<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> l;</span><br></pre></td></tr></table></figure>
<ol>
<li>收缩区间，查找右边界指在&lt;=target的区间中取最大的一个，即&gt;target的区间舍去，<code>r = mid-1</code>，每次搜索的区间是(left,right]</li>
<li>因为<code>mid = l+(r-l&gt;&gt;1)</code>总是落在(l+r)/2的右侧，<code>l=mid</code>可以保证<code>l</code>始终在左区间的右边界上</li>
<li>当终止条件<code>l==r</code>时，r右边的区域为&gt;target，l为&lt;=target的区域的右边界。</li>
</ol>
<h4 id="一个其他版本的查找右侧边界代码"><a class="markdownIt-Anchor" href="#一个其他版本的查找右侧边界代码"></a> 一个其他版本的查找右侧边界代码</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line">    <span class="type">int</span> mid = l+ (r-l&gt;&gt;<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(mid&gt;target) r = mid;</span><br><span class="line">    <span class="keyword">else</span> l = mid+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> l<span class="number">-1</span>;</span><br></pre></td></tr></table></figure>
<p>其实就是<mark>查找 &gt;target的左边界</mark>  版本，返回left-1即<mark>为&lt;=tareget的右边界</mark></p>
<h3 id="查找target的左边界"><a class="markdownIt-Anchor" href="#查找target的左边界"></a> 查找&gt;=target的左边界</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line">    <span class="type">int</span> mid = l+(r-l)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(mid&gt;=target)r = mid;</span><br><span class="line">    <span class="keyword">else</span> l = mid+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> l;</span><br></pre></td></tr></table></figure>
<ol>
<li>收缩区间，查找左边界指在&gt;=target的区间中取最小的一个，即&lt;target的区间舍去，<code>l = mid+1</code>，每次搜索的区间是[left,right)</li>
<li>因为mid = l+(r-l&gt;&gt;1)总是落在(l+r)/2的左侧，<code>r = mid</code>可以保证<code>r</code>始终落在右区间的左边界上</li>
<li>当终止条件<code>l==r</code>时，l左侧的部分全部为&lt;target，r为&lt;=target的区域的右边界</li>
</ol>
<h3 id="题目"><a class="markdownIt-Anchor" href="#题目"></a> 题目</h3>
<h4 id="搜索旋转排序数组"><a class="markdownIt-Anchor" href="#搜索旋转排序数组"></a> <a href="https://leetcode-cn.com/problems/search-in-rotated-sorted-array/">搜索旋转排序数组</a></h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">search</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> l  = <span class="number">0</span>,r = nums.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;=r)&#123;</span><br><span class="line">            <span class="type">int</span> mid = l+(r-l&gt;&gt;<span class="number">1</span>);</span><br><span class="line">            <span class="type">int</span> num = nums[mid],numl = nums[l],numr = nums[r];</span><br><span class="line">            <span class="keyword">if</span>(num==target)<span class="keyword">return</span> mid;</span><br><span class="line">            <span class="keyword">if</span>(numl&lt;=num)&#123; <span class="comment">//左边有序</span></span><br><span class="line">                <span class="keyword">if</span>(target&lt;num &amp;&amp; target&gt;=numl)r = mid<span class="number">-1</span>; <span class="comment">//在左边</span></span><br><span class="line">                <span class="keyword">else</span> l = mid+<span class="number">1</span>; <span class="comment">//在右边</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123; <span class="comment">//右边有序</span></span><br><span class="line">                <span class="keyword">if</span>(target&gt;num &amp;&amp; target&lt;=numr ) l = mid+<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> r = mid<span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="寻找峰值"><a class="markdownIt-Anchor" href="#寻找峰值"></a> <a href="https://leetcode-cn.com/problems/find-peak-element/">寻找峰值</a></h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findPeakElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> l = <span class="number">0</span>,r = nums.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line">            <span class="type">int</span> mid = l + (r-l&gt;&gt;<span class="number">1</span>);</span><br><span class="line">            <span class="type">int</span> prev,next;</span><br><span class="line">            <span class="keyword">if</span>(mid<span class="number">-1</span>&gt;=<span class="number">0</span>)prev = nums[mid<span class="number">-1</span>];<span class="keyword">else</span> prev = INT_MIN;</span><br><span class="line">            <span class="keyword">if</span>(mid+<span class="number">1</span>&lt;=nums.<span class="built_in">size</span>()<span class="number">-1</span>)next = nums[mid+<span class="number">1</span>];<span class="keyword">else</span> next = INT_MIN;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid]&gt;prev&amp;&amp;nums[mid]&gt;next)<span class="keyword">return</span> mid;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid]&gt;=prev) l = mid+<span class="number">1</span>; <span class="keyword">else</span> r = mid<span class="number">-1</span>; <span class="comment">//等号给INT_MIN 上坡必有顶</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="在排序数组中查找元素的第一个和最后一个位置"><a class="markdownIt-Anchor" href="#在排序数组中查找元素的第一个和最后一个位置"></a> <a href="https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/">在排序数组中查找元素的第一个和最后一个位置</a></h4>
<p>lower_bound(start,end,target) 返回&gt;=target的第一个位置地址</p>
<p>upper_bound(start,end,target) 返回&gt;target的第一个位置地址</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">searchRange</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//第一种方法使用双二分法，注意边界</span></span><br><span class="line">        <span class="type">int</span> l = <span class="number">0</span>, r = nums.<span class="built_in">size</span>()<span class="number">-1</span>;<span class="type">int</span> left=<span class="number">-1</span>,right = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;r)&#123; <span class="comment">//&gt;=target的左边界</span></span><br><span class="line">            <span class="type">int</span> mid = l+(r-l&gt;&gt;<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span>(nums[mid]&gt;=target)r = mid;<span class="keyword">else</span> l = mid+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(nums.<span class="built_in">size</span>()&gt;<span class="number">0</span>) <span class="keyword">if</span>( nums[l]!=target)left = <span class="number">-1</span>;<span class="keyword">else</span> left=l;</span><br><span class="line">        l =<span class="number">0</span>;r = nums.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;r)&#123;<span class="comment">//&lt;=target的右边界</span></span><br><span class="line">            <span class="type">int</span> mid = l+(r-l&gt;&gt;<span class="number">1</span>)+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid]&lt;=target)l = mid;<span class="keyword">else</span> r = mid<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(nums.<span class="built_in">size</span>()&gt;<span class="number">0</span> )<span class="keyword">if</span>(nums[l]!=target)right = <span class="number">-1</span>;<span class="keyword">else</span> right=l;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt;res; res.<span class="built_in">push_back</span>(left);res.<span class="built_in">push_back</span>(right);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//第二种方法使用STL，注意边界</span></span><br><span class="line">        left = <span class="built_in">lower_bound</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>(),target)-nums.<span class="built_in">begin</span>();</span><br><span class="line">        right = <span class="built_in">upper_bound</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>(),target)-nums.<span class="built_in">begin</span>()<span class="number">-1</span>;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt;res2;</span><br><span class="line">        <span class="keyword">if</span>(nums.<span class="built_in">size</span>()&gt;<span class="number">0</span> &amp;&amp; left&gt;=<span class="number">0</span> &amp;&amp;left &lt;nums.<span class="built_in">size</span>() &amp;&amp; nums[left]==target)res2.<span class="built_in">push_back</span>(left);<span class="keyword">else</span> res2.<span class="built_in">push_back</span>(<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">if</span>(nums.<span class="built_in">size</span>()&gt;<span class="number">0</span> &amp;&amp; right &gt;=<span class="number">0</span> &amp;&amp; right &lt; nums.<span class="built_in">size</span>() &amp;&amp;nums[right]==target)res2.<span class="built_in">push_back</span>(right);<span class="keyword">else</span> res2.<span class="built_in">push_back</span>(<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">return</span> res2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="找到-k-个最接近的元素"><a class="markdownIt-Anchor" href="#找到-k-个最接近的元素"></a> <a href="https://leetcode-cn.com/problems/find-k-closest-elements/">找到 K 个最接近的元素</a></h4>
<h4 id="方法一二分查找双指针"><a class="markdownIt-Anchor" href="#方法一二分查找双指针"></a> 方法一：二分查找+双指针</h4>
<p>首先找到&lt;=target的右边界，确定pos之后</p>
<p>令left=pos-k,right=pos+k，则我们需要的数字必定在这里面。分成三类讨论</p>
<ol>
<li>left&lt;0 left++</li>
<li>right&gt;=arr.size() right–;</li>
<li>在数组范围内，判断x与arr[left]和arr[right]的距离，left近就right–否则left++</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">findClosestElements</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr, <span class="type">int</span> k, <span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> l = <span class="number">0</span>,r = arr.<span class="built_in">size</span>()<span class="number">-1</span>;<span class="type">int</span> pos;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;r)&#123;<span class="comment">//&lt;=target 的右边界</span></span><br><span class="line">            <span class="type">int</span> mid = l+(r-l&gt;&gt;<span class="number">1</span>)+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(arr[mid]&lt;=x)l=mid;<span class="keyword">else</span> r=mid<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        pos = l;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt;res;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> left = pos-k,right=pos+k;</span><br><span class="line">        <span class="keyword">while</span>(right-left+<span class="number">1</span>&gt;k)&#123;</span><br><span class="line">            <span class="keyword">if</span>(left&lt;<span class="number">0</span>)&#123;left++;<span class="keyword">continue</span>;&#125;</span><br><span class="line">            <span class="keyword">if</span>(right&gt;=arr.<span class="built_in">size</span>())&#123;right--;<span class="keyword">continue</span>;&#125;</span><br><span class="line">            <span class="keyword">if</span>(arr[right]-x&gt;=x-arr[left])right--;<span class="keyword">else</span> left++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=left;i&lt;=right;i++)res.<span class="built_in">push_back</span>(arr[i]);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="方法二排序"><a class="markdownIt-Anchor" href="#方法二排序"></a> 方法二：排序</h4>
<p>将所有的数字和x的差值进行排序，取前k个。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//static int target;</span></span><br><span class="line">    <span class="comment">//static bool cmp(int &amp; a,int &amp; b)&#123;</span></span><br><span class="line">        <span class="comment">//if(abs(a-target)==abs(b-target))return a&lt;b;else return abs(a-target)&lt;abs(b-target);</span></span><br><span class="line">    <span class="comment">//&#125;</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">findClosestElements</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr, <span class="type">int</span> k, <span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(arr.<span class="built_in">begin</span>(),arr.<span class="built_in">end</span>(),[&amp;x](<span class="type">int</span> &amp;a,<span class="type">int</span> &amp;b)-&gt; <span class="type">bool</span>&#123;<span class="keyword">if</span>(<span class="built_in">abs</span>(a-x)==<span class="built_in">abs</span>(b-x))<span class="keyword">return</span> a&lt;b; <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">abs</span>(a-x)&lt;<span class="built_in">abs</span>(b-x);&#125;);     <span class="comment">//函数式编程，省去了引用static变量和初始化的过程</span></span><br><span class="line">        <span class="comment">//this-&gt;target = x;</span></span><br><span class="line">        <span class="comment">//sort(arr.begin(),arr.end(),cmp);</span></span><br><span class="line">        vector&lt;<span class="type">int</span>&gt;res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;k;i++)res.<span class="built_in">emplace_back</span>(arr[i]);</span><br><span class="line">        <span class="built_in">sort</span>(res.<span class="built_in">begin</span>(),res.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//int Solution::target = 0; //类型 所在类：：静态变量名 = 初始化值。</span></span><br></pre></td></tr></table></figure>
<h3 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h3>
<p><a href="https://www.cnblogs.com/kyoner/p/11080078.html">https://www.cnblogs.com/kyoner/p/11080078.html</a></p>
<p>《蓝书》P26</p>
]]></content>
      <categories>
        <category>算法</category>
        <category>基础算法</category>
        <category>二分</category>
      </categories>
      <tags>
        <tag>基础算法</tag>
        <tag>encryptalg</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树基础详解</title>
    <url>/posts/99d9a14f/</url>
    <content><![CDATA[<p>删除树中的节点时，删除过程将按照后序遍历的顺序进行。 也就是说，当你删除一个节点时，你将首先删除它的左节点和它的右边的节点，然后再删除节点本身。另外，后序在数学表达中被广泛使用。 编写程序来解析后缀表示法更为容易。</p>
<p><img data-src="http://hz-picbed-xxh.oss-cn-hangzhou.aliyuncs.com/img-bed/mathematical_expression.png" alt="img" /></p>
<p>可以使用中序遍历轻松找出原始表达式。 但是程序处理这个表达式时并不容易，因为你必须检查操作的优先级。</p>
<p>如果你想对这棵树进行后序遍历，使用栈来处理表达式会变得更加容易。 每遇到一个操作符，就可以从栈中弹出栈顶的两个元素，计算并将结果返回到栈中。</p>
<h2 id="遍历"><a class="markdownIt-Anchor" href="#遍历"></a> 遍历</h2>
<h3 id="x序遍历"><a class="markdownIt-Anchor" href="#x序遍历"></a> X序遍历</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">preorder</span><span class="params">(TreeNode* cur,vector&lt;<span class="type">int</span>&gt;&amp; res)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(cur==<span class="literal">nullptr</span>)<span class="keyword">return</span>;</span><br><span class="line">    res.<span class="built_in">push_back</span>(cur-&gt;val); <span class="comment">//不同位置表示不同序的遍历</span></span><br><span class="line">    <span class="built_in">preorder</span>(cur-&gt;left,res);</span><br><span class="line">    <span class="built_in">preorder</span>(cur-&gt;right,res);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="层次遍历"><a class="markdownIt-Anchor" href="#层次遍历"></a> 层次遍历</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">levelOrder</span>(TreeNode* root) &#123;</span><br><span class="line">    vector&lt;TreeNode*&gt;q; vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;res; q.<span class="built_in">push_back</span>(root); <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(cnt&lt;q.<span class="built_in">size</span>())&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt;tmp;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=cnt;i&lt;q.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(q[i]!=<span class="literal">nullptr</span>)tmp.<span class="built_in">push_back</span>(q[i]-&gt;val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(tmp.<span class="built_in">size</span>())res.<span class="built_in">push_back</span>(tmp);</span><br><span class="line">        <span class="type">int</span> bound = q.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(cnt;cnt&lt;bound;cnt++)<span class="keyword">if</span>(q[cnt]!=<span class="literal">nullptr</span>)q.<span class="built_in">push_back</span>(q[cnt]-&gt;left),q.<span class="built_in">push_back</span>(q[cnt]-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="自顶向下"><a class="markdownIt-Anchor" href="#自顶向下"></a> 自顶向下</h3>
<p>“自顶向下” 意味着在每个递归层级，我们将首先访问节点来计算一些值，并在递归调用函数时将这些值传递到子节点。 所以 “自顶向下” 的解决方案可以被认为是一种前序遍历。 具体来说，递归函数 top_down(root, params) 的原理是这样的：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> specific value <span class="keyword">for</span> null node</span><br><span class="line">update the answer <span class="keyword">if</span> needed                      <span class="comment">// answer &lt;-- params</span></span><br><span class="line">left_ans = <span class="built_in">top_down</span>(root.left, left_params)		<span class="comment">// left_params &lt;-- root.val, params</span></span><br><span class="line">right_ans = <span class="built_in">top_down</span>(root.right, right_params)	<span class="comment">// right_params &lt;-- root.val, params</span></span><br><span class="line"><span class="keyword">return</span> the answer <span class="keyword">if</span> needed                      <span class="comment">// answer &lt;-- left_ans, right_ans</span></span><br></pre></td></tr></table></figure>
<h3 id="自底向上"><a class="markdownIt-Anchor" href="#自底向上"></a> 自底向上</h3>
<p>“自底向上” 是另一种递归方法。 在每个递归层次上，我们首先对所有子节点递归地调用函数，然后根据返回值和根节点本身的值得到答案。 这个过程可以看作是后序遍历的一种。 通常， “自底向上” 的递归函数 bottom_up(root) 为如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> specific value <span class="keyword">for</span> null node</span><br><span class="line">left_ans = <span class="built_in">bottom_up</span>(root.left)			<span class="comment">// call function recursively for left child</span></span><br><span class="line">right_ans = <span class="built_in">bottom_up</span>(root.right)		<span class="comment">// call function recursively for right child</span></span><br><span class="line"><span class="keyword">return</span> answers                           <span class="comment">// answer &lt;-- left_ans, right_ans, root.val</span></span><br></pre></td></tr></table></figure>
<h4 id="求树的最大深度"><a class="markdownIt-Anchor" href="#求树的最大深度"></a> 求树的最大深度</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> answer=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">topDown</span><span class="params">(TreeNode* cur,<span class="type">int</span> level)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(cur==<span class="literal">nullptr</span>)<span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">topDown</span>(cur-&gt;left,level+<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">topDown</span>(cur-&gt;right,level+<span class="number">1</span>);</span><br><span class="line">    answer = <span class="built_in">max</span>(answer,level);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bottomUp</span><span class="params">(TreeNode* cur)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(cur==<span class="literal">nullptr</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>(<span class="built_in">bottomUp</span>(cur-&gt;left),<span class="built_in">bottomUp</span>(cur-&gt;right))+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
        <category>基础算法</category>
        <category>二叉树</category>
      </categories>
      <tags>
        <tag>基础算法</tag>
        <tag>encryptalg</tag>
      </tags>
  </entry>
  <entry>
    <title>常用stl算法总结</title>
    <url>/posts/603c8f61/</url>
    <content><![CDATA[<h2 id="容器"><a class="markdownIt-Anchor" href="#容器"></a> 容器</h2>
<h3 id="vector"><a class="markdownIt-Anchor" href="#vector"></a> vector</h3>
<h4 id="基本操作"><a class="markdownIt-Anchor" href="#基本操作"></a> 基本操作</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">push_back</span><span class="params">()</span></span>;<span class="function"><span class="type">void</span>  <span class="title">emplace_back</span><span class="params">()</span></span>; <span class="comment">//尾端插入</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pop_back</span><span class="params">()</span></span>; <span class="comment">//尾端弹出</span></span><br><span class="line"><span class="function">iterator <span class="title">front</span><span class="params">()</span></span>; <span class="function">iterator <span class="title">back</span><span class="params">()</span></span>;<span class="comment">//返回首尾迭代器</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span> <span class="comment">//清空</span></span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="comment">//判空</span></span></span><br><span class="line"><span class="function">iterator <span class="title">erase</span><span class="params">(itereator loc)</span></span>;<span class="comment">//删除loc所指的元素，返回下一元素的迭代器</span></span><br><span class="line"><span class="function">iterator <span class="title">erase</span><span class="params">(iterator start,iterator end)</span></span>;删除[start,end)之间的元素，返回end元素的迭代器</span><br><span class="line"><span class="function">iterator <span class="title">insert</span><span class="params">(iterator loc,val)</span></span>;<span class="comment">//在loc位置插入一个value元素，并且返回其迭代器，原loc及以后的元素后移</span></span><br><span class="line"><span class="comment">//vector&lt;int&gt;::iterator it=q.insert(q.begin()+2,num);</span></span><br></pre></td></tr></table></figure>
<h4 id="一维初始化"><a class="markdownIt-Anchor" href="#一维初始化"></a> 一维初始化</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;T&gt; v1 <span class="comment">//空的vector，执行默认初始化</span></span><br><span class="line"><span class="function">vector&lt;T&gt; <span class="title">v2</span><span class="params">(v1)</span> <span class="comment">//v2包含有v1所有元素的副本</span></span></span><br><span class="line"><span class="function">vector&lt;T&gt; <span class="title">v2</span><span class="params">(v1.begin(),v1.end())</span><span class="comment">//包含指定范围的数据</span></span></span><br><span class="line"><span class="function">vector&lt;T&gt; v2</span>=v1 <span class="comment">//等价于上条语句</span></span><br><span class="line"><span class="function">vector&lt;T&gt; <span class="title">v3</span><span class="params">(n,val)</span> <span class="comment">//包含了n个重复元素，每个元素的值都是val</span></span></span><br><span class="line"><span class="function">vector&lt;T&gt; <span class="title">v4</span><span class="params">(n)</span> <span class="comment">//包含n个默认初始化的对象 </span></span></span><br><span class="line"><span class="function">vector&lt;T&gt; v4</span>&#123;a,b,c...&#125; <span class="comment">//包含了初始值个数的元素，并被初始化</span></span><br><span class="line">vector&lt;T&gt; v5=&#123;a,b,c...&#125; <span class="comment">//等价于上条语句</span></span><br></pre></td></tr></table></figure>
<h4 id="二维数组初始化"><a class="markdownIt-Anchor" href="#二维数组初始化"></a> 二维数组初始化</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">vec</span>(row, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; (col,<span class="number">1</span>));</span><br></pre></td></tr></table></figure>
<h3 id="list"><a class="markdownIt-Anchor" href="#list"></a> List</h3>
<h4 id="初始化"><a class="markdownIt-Anchor" href="#初始化"></a> 初始化</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">list&lt;<span class="type">int</span>&gt;<span class="built_in">a</span>(<span class="number">10</span>,<span class="number">1</span>)<span class="comment">//10大小初始值1</span></span><br><span class="line">list&lt;<span class="type">int</span>&gt;<span class="built_in">a</span>(n,n+<span class="number">5</span>)<span class="comment">//使用数组初始化</span></span><br></pre></td></tr></table></figure>
<h4 id="基本操作-2"><a class="markdownIt-Anchor" href="#基本操作-2"></a> 基本操作</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">list.<span class="built_in">resize</span>()<span class="comment">//改变大小</span></span><br><span class="line">list.<span class="built_in">push_front</span>();</span><br><span class="line">list.<span class="built_in">push_back</span>()</span><br><span class="line">list.<span class="built_in">insert</span>(&amp;it,val);</span><br><span class="line">list.<span class="built_in">insert</span>(&amp;it,<span class="type">int</span> n,val)<span class="comment">//&amp;it位置插入n个val</span></span><br><span class="line">list.<span class="built_in">insert</span>(&amp;it,begin,last)<span class="comment">//&amp;it位置插入begin~end</span></span><br><span class="line">list.<span class="built_in">pop_front</span>()</span><br><span class="line">list.<span class="built_in">pop_back</span>()</span><br><span class="line">list.<span class="built_in">erase</span>(&amp;it)</span><br><span class="line">list.<span class="built_in">erase</span>(begin,end)</span><br><span class="line">list.<span class="built_in">clear</span>()<span class="comment">//清空</span></span><br><span class="line"></span><br><span class="line">list.<span class="built_in">assign</span>(<span class="type">int</span> nSize,val)<span class="comment">//类似数组初始化</span></span><br><span class="line"><span class="built_in">swap</span>(list&amp;,list&amp;)<span class="comment">//交换</span></span><br><span class="line">list.<span class="built_in">merge</span>();<span class="comment">//合并，默认升序</span></span><br><span class="line">list.<span class="built_in">splice</span>(&amp;it,list&amp;) <span class="comment">//&amp;it位置接入list</span></span><br><span class="line">list.<span class="built_in">unique</span>()<span class="comment">//去重</span></span><br><span class="line">list.<span class="built_in">sort</span>()</span><br><span class="line">list.<span class="built_in">remove_if</span>()<span class="comment">//条件去重</span></span><br><span class="line">list.<span class="built_in">reverse</span>()</span><br></pre></td></tr></table></figure>
<h3 id="stack"><a class="markdownIt-Anchor" href="#stack"></a> stack</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span>	栈为空返回<span class="literal">true</span>,否则返回<span class="literal">false</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">()</span>	删除栈顶元素，即出栈</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">const</span> TYPE &amp;val)</span>	将新元素val进栈，使其成为栈顶元素</span></span><br><span class="line"><span class="function"><span class="title">top</span><span class="params">()</span> 查看当前栈顶元素</span></span><br><span class="line"><span class="function"><span class="title">size</span><span class="params">()</span> 返回元素数目</span></span><br></pre></td></tr></table></figure>
<h3 id="queue"><a class="markdownIt-Anchor" href="#queue"></a> queue</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span>	队列为空返回<span class="literal">true</span>,否则返回<span class="literal">false</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">()</span>	删除队列头元素，即出栈</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">const</span> TYPE &amp;val)</span>	将新元素val进队尾</span></span><br><span class="line"><span class="function"><span class="title">top</span><span class="params">()</span> 查看当前栈顶元素</span></span><br><span class="line"><span class="function"><span class="title">size</span><span class="params">()</span> 返回元素数目</span></span><br></pre></td></tr></table></figure>
<h3 id="deque"><a class="markdownIt-Anchor" href="#deque"></a> deque</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">assign</span>()	设置双向队列的值</span><br><span class="line"><span class="built_in">at</span>()	返回指定的元素</span><br><span class="line"><span class="built_in">back</span>()	返回最后一个元素</span><br><span class="line"><span class="built_in">begin</span>()	返回指向第一个元素的迭代器</span><br><span class="line"><span class="built_in">clear</span>()	删除所有元素</span><br><span class="line"><span class="built_in">empty</span>()	返回真如果双向队列为空</span><br><span class="line"><span class="built_in">end</span>()	返回指向尾部的迭代器</span><br><span class="line"><span class="built_in">erase</span>()	删除一个元素</span><br><span class="line"><span class="built_in">front</span>()	返回第一个元素</span><br><span class="line"><span class="built_in">get_allocator</span>()	返回双向队列的配置器</span><br><span class="line"><span class="built_in">insert</span>()	插入一个元素到双向队列中</span><br><span class="line"><span class="built_in">max_size</span>()	返回双向队列能容纳的最大元素个数</span><br><span class="line"><span class="built_in">pop_back</span>()	删除尾部的元素</span><br><span class="line"><span class="built_in">pop_front</span>()	删除头部的元素</span><br><span class="line"><span class="built_in">push_back</span>()	在尾部加入一个元素</span><br><span class="line"><span class="built_in">push_front</span>()	在头部加入一个元素</span><br><span class="line"><span class="built_in">rbegin</span>()	返回指向尾部的逆向迭代器</span><br><span class="line"><span class="built_in">rend</span>()	返回指向头部的逆向迭代器</span><br><span class="line"><span class="built_in">resize</span>()	改变双向队列的大小</span><br><span class="line"><span class="built_in">size</span>()	返回双向队列中元素的个数</span><br><span class="line"><span class="built_in">swap</span>()	和另一个双向队列交换元素</span><br></pre></td></tr></table></figure>
<h3 id="优先队列-重定义"><a class="markdownIt-Anchor" href="#优先队列-重定义"></a> 优先队列-重定义</h3>
<ol>
<li>自定义类型重载，使用仿函数中的比较函数</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">    <span class="type">int</span> x, y;</span><br><span class="line">    <span class="built_in">Node</span>( <span class="type">int</span> a= <span class="number">0</span>, <span class="type">int</span> b= <span class="number">0</span> ):</span><br><span class="line">        <span class="built_in">x</span>(a), <span class="built_in">y</span>(b) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>&gt;( Node a, Node b )&#123;<span class="comment">//返回true，a的优先级大于b</span></span><br><span class="line">    <span class="comment">//x大的排在队前部；x相同时，y大的排在队前部</span></span><br><span class="line">    <span class="keyword">if</span>( a.x== b.x ) <span class="keyword">return</span> a.y&gt; b.y;</span><br><span class="line">    <span class="keyword">return</span> a.x&gt; b.x; </span><br><span class="line">&#125;</span><br><span class="line">priority_queue&lt;Node,vector&lt;Node&gt;,greater&lt;Node&gt; &gt; q;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ol start="2">
<li>自定义函数对象()</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">cmp</span>&#123;</span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(NODE n1,NODE n2)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> n1.val&gt;n2.val; <span class="comment">//小根堆 </span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">priority_queue&lt;NODE,vector&lt;NODE&gt;,cmp&gt;q;</span><br></pre></td></tr></table></figure>
<h3 id="set"><a class="markdownIt-Anchor" href="#set"></a> Set</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">begin</span>()：返回指向第一个元素的迭代器</span><br><span class="line"><span class="built_in">clear</span>()：清除所有元素</span><br><span class="line"><span class="built_in">count</span>()：返回某个值元素的个数</span><br><span class="line"><span class="built_in">empty</span>()：如果集合为空，返回<span class="function"><span class="literal">true</span></span></span><br><span class="line"><span class="function"><span class="title">end</span><span class="params">()</span>：返回指向最后一个元素的迭代器</span></span><br><span class="line"><span class="function"><span class="title">equal_range</span><span class="params">()</span>：返回集合中与给定值相等的上下限的两个迭代器</span></span><br><span class="line"><span class="function"><span class="title">erase</span><span class="params">()</span>：删除集合中的元素</span></span><br><span class="line"><span class="function"><span class="title">find</span><span class="params">()</span>：返回一个指向被查找到元素的迭代器</span></span><br><span class="line"><span class="function"><span class="title">get_allocator</span><span class="params">()</span>：返回集合的分配器</span></span><br><span class="line"><span class="function"><span class="title">insert</span><span class="params">()</span>：在集合中插入元素</span></span><br><span class="line"><span class="function"><span class="title">lower_bound</span><span class="params">()</span>：返回指向大于（或等于）某值的第一个元素的迭代器</span></span><br><span class="line"><span class="function"><span class="title">key_comp</span><span class="params">()</span>：返回一个用于元素间值比较的函数</span></span><br><span class="line"><span class="function"><span class="title">max_size</span><span class="params">()</span>：返回集合能容纳的元素的最大限值</span></span><br><span class="line"><span class="function"><span class="title">rbegin</span><span class="params">()</span>：返回指向集合中最后一个元素的反向迭代器</span></span><br><span class="line"><span class="function"><span class="title">rend</span><span class="params">()</span>：返回指向集合中第一个元素的反向迭代器</span></span><br><span class="line"><span class="function"><span class="title">size</span><span class="params">()</span>：集合中元素的数目</span></span><br><span class="line"><span class="function"><span class="title">swap</span><span class="params">()</span>：交换两个集合变量</span></span><br><span class="line"><span class="function"><span class="title">upper_bound</span><span class="params">()</span>：返回大于某个值元素的迭代器</span></span><br><span class="line"><span class="function"><span class="title">value_comp</span><span class="params">()</span>：返回一个用于比较元素间的值的函数</span></span><br></pre></td></tr></table></figure>
<h3 id="map"><a class="markdownIt-Anchor" href="#map"></a> Map</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">map.<span class="built_in">size</span>()/<span class="built_in">clear</span>()/<span class="built_in">empty</span>()</span><br><span class="line"><span class="function">iterator <span class="title">lower_bound</span><span class="params">(key)</span><span class="comment">//返回指向键值&gt;=key的第一个元素upper_bound 键值&gt;key</span></span></span><br><span class="line"><span class="function">map.<span class="title">key_comp</span><span class="params">()</span><span class="comment">//返回比较key大小</span></span></span><br><span class="line"><span class="function">map.<span class="title">value_comp</span><span class="params">()</span><span class="comment">//返回比较value大小</span></span></span><br><span class="line"><span class="function">itearator <span class="title">find</span><span class="params">(key)</span><span class="comment">//返回键值为key的迭代器，未找到则返回end()</span></span></span><br><span class="line"><span class="function">pair&lt;itaratoe,<span class="type">bool</span>&gt; <span class="title">insert</span><span class="params">(pair&lt;key,value&gt;)</span>插入键值对，返回pair&lt;迭代器，成功与否&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="stl内置算法"><a class="markdownIt-Anchor" href="#stl内置算法"></a> STL内置算法</h2>
<h3 id="fill"><a class="markdownIt-Anchor" href="#fill"></a> fill</h3>
<h4 id="给一维数组赋值"><a class="markdownIt-Anchor" href="#给一维数组赋值"></a> 给一维数组赋值</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> f[MAXN];</span><br><span class="line"><span class="built_in">fill</span>(f,f+MAXN,num);</span><br></pre></td></tr></table></figure>
<h4 id="给二维数组赋值"><a class="markdownIt-Anchor" href="#给二维数组赋值"></a> 给二维数组赋值</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> f[MAXN][MAXN];</span><br><span class="line"><span class="built_in">fill</span>(f[<span class="number">0</span>],f[<span class="number">0</span>]+MAXN*MAXN,num);</span><br></pre></td></tr></table></figure>
<h3 id=""><a class="markdownIt-Anchor" href="#"></a> </h3>
]]></content>
      <categories>
        <category>算法</category>
        <category>基础算法</category>
        <category>stl</category>
      </categories>
      <tags>
        <tag>stl</tag>
      </tags>
  </entry>
  <entry>
    <title>并查集模板</title>
    <url>/posts/83a4cde7/</url>
    <content><![CDATA[<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">UF</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> fa[<span class="number">65</span>],rank[<span class="number">65</span>];</span><br><span class="line">    <span class="built_in">UF</span>(<span class="type">int</span> n)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            fa[i]=i;</span><br><span class="line">            rank[i]=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x==fa[x]?x:(fa[x]=<span class="built_in">find</span>(fa[x]));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">uni</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> x=<span class="built_in">find</span>(i),y=<span class="built_in">find</span>(j);</span><br><span class="line">        <span class="keyword">if</span>(rank[x]&lt;=rank[y])fa[x]=y;</span><br><span class="line">        <span class="keyword">else</span> fa[y]=x;</span><br><span class="line">        <span class="keyword">if</span>(rank[x]==rank[y]&amp;&amp;x!=y)rank[y]++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
        <category>基础算法</category>
      </categories>
      <tags>
        <tag>基础算法</tag>
      </tags>
  </entry>
  <entry>
    <title>前缀和、差分与树状数组</title>
    <url>/posts/8f4b279/</url>
    <content><![CDATA[<h3 id="树状数组解决的问题"><a class="markdownIt-Anchor" href="#树状数组解决的问题"></a> 树状数组解决的问题</h3>
<ol>
<li>单点修改，求区间和</li>
<li>区间修改，求区间和</li>
</ol>
<h3 id="前缀和数组"><a class="markdownIt-Anchor" href="#前缀和数组"></a> 前缀和数组</h3>
<p>可以快速求出<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">[</mo><mi>l</mi><mo separator="true">,</mo><mi>r</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[l,r]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mclose">]</span></span></span></span> 范围内的和<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mi>u</mi><mi>m</mi><mo>=</mo><mi>s</mi><mi>u</mi><mi>m</mi><mi>a</mi><mi>r</mi><mi>r</mi><mo stretchy="false">[</mo><mi>r</mi><mo stretchy="false">]</mo><mo>−</mo><mi>s</mi><mi>u</mi><mi>m</mi><mi>a</mi><mi>r</mi><mi>r</mi><mo stretchy="false">[</mo><mi>l</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">sum = sumarr[r]-sumarr[l-1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span></p>
<p>缺点：无法支持单点修改和区间修改，因为每修改一次需要对后续所有的数组元素重新计算。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=nums.<span class="built_in">size</span>();i++)dp[i] = dp[i<span class="number">-1</span>]+nums[i<span class="number">-1</span>];</span><br><span class="line">cout&lt;&lt;dp[r]-dp[l<span class="number">-1</span>]&lt;&lt;endl;</span><br></pre></td></tr></table></figure>
<h4 id="二维矩阵-子矩阵的和"><a class="markdownIt-Anchor" href="#二维矩阵-子矩阵的和"></a> 二维矩阵-子矩阵的和</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,m,q;cin&gt;&gt;n&gt;&gt;m&gt;&gt;q;</span><br><span class="line">    <span class="built_in">fill</span>(f[<span class="number">0</span>],f[<span class="number">0</span>]+<span class="number">1010</span>*<span class="number">1010</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;j++)&#123;</span><br><span class="line">            <span class="type">int</span> num;cin&gt;&gt;num;</span><br><span class="line">            f[i][j] = num+f[i<span class="number">-1</span>][j]+f[i][j<span class="number">-1</span>]-f[i<span class="number">-1</span>][j<span class="number">-1</span>]; cout&lt;&lt;f[i][j]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(q--)&#123;</span><br><span class="line">        <span class="type">int</span> a,b,c,d;cin&gt;&gt;a&gt;&gt;b&gt;&gt;c&gt;&gt;d;</span><br><span class="line">        cout&lt;&lt;f[c][d]-f[a<span class="number">-1</span>][d]-f[c][b<span class="number">-1</span>]+f[a<span class="number">-1</span>][b<span class="number">-1</span>]&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="差分数组"><a class="markdownIt-Anchor" href="#差分数组"></a> 差分数组</h3>
<p>差分为前缀和的逆运算，将当前数组看成前缀和数组，差分数组为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mi>d</mi><mi>j</mi><mi>a</mi><mi>r</mi><mi>r</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo>=</mo><mi>s</mi><mi>u</mi><mi>m</mi><mi>a</mi><mi>r</mi><mi>r</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo>−</mo><mi>s</mi><mi>u</mi><mi>m</mi><mi>a</mi><mi>r</mi><mi>r</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">adjarr[i] = sumarr[i]-sumarr[i-1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault">d</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span>支持单点修改和区间修改，以及最后的一次查询。</p>
<p>缺点：无法支持动态查询</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    <span class="type">int</span> n,m;cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;<span class="built_in">sum</span>(n+<span class="number">1</span>),<span class="built_in">adj</span>(n+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)cin&gt;&gt;sum[i];</span><br><span class="line">    <span class="built_in">adjacent_difference</span>(sum.<span class="built_in">begin</span>(),sum.<span class="built_in">end</span>(),adj.<span class="built_in">begin</span>());<span class="comment">//构造差分数组</span></span><br><span class="line">    <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">        <span class="type">int</span> l,r,c;cin&gt;&gt;l&gt;&gt;r&gt;&gt;c;</span><br><span class="line">        adj[l<span class="number">-1</span>]+=c;adj[r]-=c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> num=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        num = num+ adj[i];</span><br><span class="line">        cout&lt;&lt;num&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="树状数组-stage1"><a class="markdownIt-Anchor" href="#树状数组-stage1"></a> 树状数组-stage1</h3>
<p>ref： <a href="https://blog.csdn.net/bestsort/article/details/80796531">https://blog.csdn.net/bestsort/article/details/80796531</a></p>
<h4 id="lowbit函数"><a class="markdownIt-Anchor" href="#lowbit函数"></a> lowbit函数</h4>
<p>返回x的二进制最低位的1组成的整数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">lowbit</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;<span class="keyword">return</span> x&amp;(-x);&#125;<span class="comment">// 6 = 110 -&gt; 10 = 2</span></span><br></pre></td></tr></table></figure>
<p>树状数组其实就是二叉树化的前缀和数组。每个数组元素<code>x</code>对<code>x+lowbit(x)</code>有贡献，因此每个<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span>控制<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">[</mo><mi>x</mi><mo>−</mo><mi>l</mi><mi>o</mi><mi>w</mi><mi>b</mi><mi>i</mi><mi>t</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>+</mo><mn>1</mn><mo separator="true">,</mo><mi>x</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[x-lowbit(x)+1,x]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord mathdefault">b</span><span class="mord mathdefault">i</span><span class="mord mathdefault">t</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">x</span><span class="mclose">]</span></span></span></span>,易知当<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mo>+</mo><mi>l</mi><mi>o</mi><mi>w</mi><mi>b</mi><mi>i</mi><mi>t</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">x+lowbit(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord mathdefault">b</span><span class="mord mathdefault">i</span><span class="mord mathdefault">t</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span></span></span></span>时类似二叉树的向其父节点追溯，而<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mo>−</mo><mi>l</mi><mi>o</mi><mi>w</mi><mi>b</mi><mi>i</mi><mi>t</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">x-lowbit(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord mathdefault">b</span><span class="mord mathdefault">i</span><span class="mord mathdefault">t</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span></span></span></span>时类似寻找其孩子。</p>
<p><img data-src="http://hz-picbed-xxh.oss-cn-hangzhou.aliyuncs.com/img-bed/20200717113256650.png" alt="img" /></p>
<p><img data-src="http://hz-picbed-xxh.oss-cn-hangzhou.aliyuncs.com/img-bed/20200717113236761.png" alt="img" /></p>
<h4 id="单点更新"><a class="markdownIt-Anchor" href="#单点更新"></a> 单点更新</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">lowadd</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; bit,<span class="type">int</span> pos,<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(pos&lt;bit.<span class="built_in">size</span>())&#123;</span><br><span class="line">        bit[pos]+=k;</span><br><span class="line">        pos+=<span class="built_in">lowbit</span>(pos);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="区间求和"><a class="markdownIt-Anchor" href="#区间求和"></a> 区间求和</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">lowsum</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp; bit,<span class="type">int</span> pos)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(pos&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        sum+=bit[pos];</span><br><span class="line">        pos-=<span class="built_in">lowbit</span>(pos);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
        <category>基础算法</category>
      </categories>
      <tags>
        <tag>基础算法</tag>
      </tags>
  </entry>
  <entry>
    <title>离散化</title>
    <url>/posts/515818b4/</url>
    <content><![CDATA[<h3 id="acwing802-区间和"><a class="markdownIt-Anchor" href="#acwing802-区间和"></a> Acwing802 区间和</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">findpos</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; src,<span class="type">int</span> pos)</span></span>&#123;<span class="comment">//离散化映射</span></span><br><span class="line">    <span class="type">int</span> l=<span class="number">0</span>,r=src.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line">        <span class="type">int</span> mid = l+(r-l&gt;&gt;<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(src[mid]&gt;=pos)r= mid;</span><br><span class="line">        <span class="keyword">else</span> l = mid+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r+<span class="number">1</span>; <span class="comment">//从1开始</span></span><br><span class="line">&#125;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;::<span class="function">iterator <span class="title">my_unique</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp;src)</span></span>&#123; <span class="comment">//手动去重，返回迭代器指针</span></span><br><span class="line">    <span class="type">int</span> j=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;src.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!i  || src[i]!=src[i<span class="number">-1</span>]) src[j++]=src[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> src.<span class="built_in">begin</span>()+j;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="type">int</span> n,m;cin&gt;&gt;n&gt;&gt;m;  <span class="keyword">constexpr</span> <span class="type">int</span> size = <span class="number">300010</span>;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;pos;vector&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt;add;vector&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt;query;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;<span class="built_in">nums</span>(,<span class="number">0</span>),<span class="built_in">sums</span>(size,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="type">int</span> x,c;cin&gt;&gt;x&gt;&gt;c;</span><br><span class="line">        pos.<span class="built_in">push_back</span>(x);</span><br><span class="line">        add.<span class="built_in">push_back</span>(&#123;x,c&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">        <span class="type">int</span> l,r;cin&gt;&gt;l&gt;&gt;r;</span><br><span class="line">        pos.<span class="built_in">push_back</span>(l);pos.<span class="built_in">push_back</span>(r);</span><br><span class="line">        query.<span class="built_in">push_back</span>(&#123;l,r&#125;);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//排序+去重</span></span><br><span class="line">    <span class="built_in">sort</span>(pos.<span class="built_in">begin</span>(),pos.<span class="built_in">end</span>(),<span class="built_in">less</span>&lt;<span class="type">int</span>&gt;());</span><br><span class="line">    pos.<span class="built_in">erase</span>(<span class="built_in">unique</span>(pos.<span class="built_in">begin</span>(),pos.<span class="built_in">end</span>()),pos.<span class="built_in">end</span>());</span><br><span class="line"><span class="comment">//离散化</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i:add)&#123;</span><br><span class="line">        <span class="type">int</span> newpos = <span class="built_in">findpos</span>(pos,i.first);</span><br><span class="line">        nums[newpos]+=i.second;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//处理离散化后的前缀和</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=nums.<span class="built_in">size</span>();i++) <span class="comment">//注意从1开始</span></span><br><span class="line">        sums[i] = sums[i<span class="number">-1</span>]+nums[i];</span><br><span class="line"><span class="comment">//处理查询</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i:query)&#123;</span><br><span class="line">        <span class="type">int</span> l=<span class="built_in">findpos</span>(pos,i.first),r = <span class="built_in">findpos</span>(pos,i.second);</span><br><span class="line">        cout&lt;&lt;sums[r]-sums[l<span class="number">-1</span>]&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
        <category>基础算法</category>
      </categories>
      <tags>
        <tag>基础算法</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/posts/0/</url>
    <content><![CDATA[<p>快速排序</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">qsort</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r,vector&lt;<span class="type">int</span>&gt;&amp; a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l&gt;=r)<span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> pivot = a[l+(r-l&gt;&gt;<span class="number">1</span>)];</span><br><span class="line">    <span class="type">int</span> lp=l<span class="number">-1</span>;<span class="type">int</span> rp=r+<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//int lp=l, rp=r;</span></span><br><span class="line">    <span class="keyword">while</span>(lp&lt;rp)&#123;</span><br><span class="line">        <span class="keyword">do</span> lp++;<span class="keyword">while</span>(a[lp]&lt;pivot);</span><br><span class="line">        <span class="keyword">do</span> rp--;<span class="keyword">while</span>(a[rp]&gt;pivot);</span><br><span class="line">        <span class="comment">//while(a[lp]&lt;pivot)lp++;//疑似越界bug</span></span><br><span class="line">        <span class="comment">//while(a[rp]&gt;pivot)rp--;</span></span><br><span class="line">        <span class="keyword">if</span>(lp&lt;rp)<span class="built_in">swap</span>(a[lp],a[rp]);</span><br><span class="line">        /lp++;rp--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">qsort</span>(l,rp,a);<span class="built_in">qsort</span>(rp+<span class="number">1</span>,r,a);  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">qsort</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r,vector&lt;<span class="type">int</span>&gt;&amp;a)</span></span>&#123;<span class="comment">//速度慢,</span></span><br><span class="line">    <span class="keyword">if</span>(l&gt;=r)<span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">swap</span>(a[l],a[l+(<span class="type">int</span>)<span class="built_in">rand</span>()%(r-l)]);</span><br><span class="line">    <span class="type">int</span> pivot = a[l];</span><br><span class="line">    <span class="type">int</span> lp = l,rp = r;</span><br><span class="line">    <span class="keyword">while</span>(lp&lt;rp)&#123;</span><br><span class="line">        <span class="keyword">while</span>(lp&lt;rp &amp;&amp; a[rp]&gt;=pivot)rp--;</span><br><span class="line">        a[lp] = a[rp];</span><br><span class="line">        <span class="keyword">while</span>(lp&lt;rp &amp;&amp; a[lp]&lt;=pivot)lp++;</span><br><span class="line">        a[rp] = a[lp];</span><br><span class="line">    &#125;</span><br><span class="line">    a[lp]=pivot;</span><br><span class="line">    <span class="built_in">qsort</span>(l,lp<span class="number">-1</span>,a);<span class="built_in">qsort</span>(lp+<span class="number">1</span>,r,a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>快选</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">qselect</span><span class="params">(<span class="type">int</span> l , <span class="type">int</span> r, vector&lt;<span class="type">int</span>&gt;&amp;a,<span class="type">int</span> kk)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l&gt;=r)&#123;<span class="keyword">return</span> ;&#125;</span><br><span class="line">    <span class="type">int</span> pivot = a[l];</span><br><span class="line">    <span class="type">int</span> lp = l<span class="number">-1</span>; <span class="type">int</span> rp = r+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(lp&lt;rp)&#123;</span><br><span class="line">        <span class="keyword">while</span>(a[++lp]&lt;pivot);</span><br><span class="line">        <span class="keyword">while</span>(a[--rp]&gt;pivot);</span><br><span class="line">        <span class="keyword">if</span>(lp&lt;rp)<span class="built_in">swap</span>(a[lp],a[rp]);</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="keyword">if</span>(rp&gt;=kk)<span class="built_in">qselect</span>(l,rp,a,kk);</span><br><span class="line">     <span class="keyword">else</span> <span class="built_in">qselect</span>(rp+<span class="number">1</span>,r,a,kk);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>二分</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> l = <span class="number">0</span>;<span class="type">int</span> r = r;</span><br><span class="line"><span class="keyword">while</span>(l&lt;=r)&#123;</span><br><span class="line">    <span class="type">int</span> mid = l+(r-l&gt;&gt;<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(a[mid]==target) <span class="keyword">return</span> mid;</span><br><span class="line">    <span class="keyword">if</span>(a[mid]&gt;target)r = mid<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">else</span> l = mid+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"><span class="comment">//左二分</span></span><br><span class="line"><span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line">    <span class="type">int</span> mid = l+(r-l&gt;&gt;<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(a[mid]&gt;=target)r = mid;<span class="keyword">else</span> l = mid+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> l;</span><br><span class="line"><span class="comment">//右二分</span></span><br><span class="line"><span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line">    <span class="type">int</span> mid = l+(r-l&gt;&gt;<span class="number">1</span>)+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(a[mid]&lt;=target) l = mid; <span class="keyword">else</span> r = mid<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> l;</span><br></pre></td></tr></table></figure>
<p>逆序对</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">inversePairs</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r,vector&lt;<span class="type">int</span>&gt;&amp; a)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l&gt;=r)<span class="keyword">return</span> ;</span><br><span class="line">    <span class="type">int</span> mid = l+(r-l&gt;&gt;<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">inversePairs</span>(l,mid,a);<span class="built_in">inversePairs</span>(mid+<span class="number">1</span>,r,a);</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;<span class="built_in">tmp</span>(r-l+<span class="number">1</span>);</span><br><span class="line">    <span class="type">int</span> i=l,j=mid+<span class="number">1</span>,tp = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=mid &amp;&amp; j&lt;=r)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i]&lt;=a[j])tmp[tp++]=a[i++];</span><br><span class="line">        <span class="keyword">else</span> tmp[tp++]=a[j++],cnt+=(mid-i+<span class="number">1</span>); <span class="comment">//加后续所有大的数量，即可；</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=mid)tmp[tp++]=a[i++];</span><br><span class="line">    <span class="keyword">while</span>(j&lt;=r)tmp[tp++]=a[j++];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> p = l;p&lt;=r;p++)a[p]=tmp[p-l];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对顶堆寻找中位数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//https://leetcode-cn.com/problems/median-of-two-sorted-arrays/</span></span><br><span class="line"><span class="keyword">while</span>(nums1.<span class="built_in">empty</span>()!=<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(bigq.<span class="built_in">empty</span>()||nums1.<span class="built_in">back</span>()&lt;bigq.<span class="built_in">top</span>())bigq.<span class="built_in">push</span>(nums1.<span class="built_in">back</span>());</span><br><span class="line">            <span class="keyword">else</span> smallq.<span class="built_in">push</span>(nums1.<span class="built_in">back</span>());</span><br><span class="line">            nums1.<span class="built_in">pop_back</span>();</span><br><span class="line">            <span class="keyword">while</span>(bigq.<span class="built_in">empty</span>()!=<span class="number">1</span>&amp;&amp;smallq.<span class="built_in">empty</span>()!=<span class="number">1</span>&amp;&amp;bigq.<span class="built_in">top</span>()&gt;smallq.<span class="built_in">top</span>())&#123;</span><br><span class="line">                smallq.<span class="built_in">push</span>(bigq.<span class="built_in">top</span>());bigq.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">           <span class="keyword">while</span>(bigq.<span class="built_in">size</span>()&gt;smallq.<span class="built_in">size</span>())&#123;</span><br><span class="line">                <span class="type">int</span> tmp = bigq.<span class="built_in">top</span>();smallq.<span class="built_in">push</span>(tmp);bigq.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;<span class="keyword">while</span>(bigq.<span class="built_in">size</span>()&lt;smallq.<span class="built_in">size</span>())&#123;</span><br><span class="line">                <span class="type">int</span> tmp =  smallq.<span class="built_in">top</span>();bigq.<span class="built_in">push</span>(tmp);smallq.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>decltype关键字</title>
    <url>/posts/6d46b940/</url>
    <content><![CDATA[<h3 id="decltype关键字"><a class="markdownIt-Anchor" href="#decltype关键字"></a> decltype关键字</h3>
<p><mark>decltype</mark>被称作类型说明符，作用是选择并返回操作数的数据类型。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// sum类型就是函数f返回的类型</span></span><br><span class="line"><span class="keyword">decltype</span>(<span class="built_in">f</span>()) sum = x;</span><br></pre></td></tr></table></figure>
<p>解决难以拼写的类型名，有以下两个方案：</p>
<ol>
<li>使用类型别名技术</li>
<li>使用auto和decltype</li>
</ol>
<h3 id="工作原理"><a class="markdownIt-Anchor" href="#工作原理"></a> 工作原理</h3>
<p><mark>decltype</mark>不会计算表达式的值，编译器分析表达式并得到它的类型。</p>
<p>函数调用也算一种表达式，因此不必担心在使用deltype时执行了函数。</p>
<h3 id="decltype变量"><a class="markdownIt-Anchor" href="#decltype变量"></a> decltype+变量</h3>
<p>根据表达式的定义，单独使用一个变量，相当于一个最简单的表达式。</p>
]]></content>
      <categories>
        <category>cpp</category>
        <category>cpp语法</category>
      </categories>
      <tags>
        <tag>cpp语法</tag>
      </tags>
  </entry>
  <entry>
    <title>Lambda表达式</title>
    <url>/posts/e9ee750c/</url>
    <content><![CDATA[<h3 id="声明lambda表达式"><a class="markdownIt-Anchor" href="#声明lambda表达式"></a> 声明Lambda表达式</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">[capture list] (params list) <span class="keyword">mutable</span> exception-&gt; <span class="keyword">return</span> type &#123; function body &#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>capture list： 捕获外部变量的列表</li>
<li>params list：形参列表</li>
<li>mutable指示符：是否可以修改捕获的变量</li>
<li>exception：异常设定</li>
<li>return type：返回类型</li>
<li>function body：函数体</li>
</ol>
<h4 id="格式1"><a class="markdownIt-Anchor" href="#格式1"></a> 格式1</h4>
<p>声明了const类型的表达式，函数中不能修改捕获列表中的值（引用传递除外）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">[capture list] (params list) -&gt; <span class="keyword">return</span> type &#123; function body &#125;</span><br></pre></td></tr></table></figure>
<h4 id="格式2"><a class="markdownIt-Anchor" href="#格式2"></a> 格式2</h4>
<p>省略了返回值的类型，编译器自动推断，若：</p>
<ol>
<li>
<p>含有return，则类型由return决定</p>
</li>
<li>
<p>不含有return，类型为void</p>
</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">[capture list] (params list)  &#123; function body &#125;</span><br></pre></td></tr></table></figure>
<h4 id="格式3"><a class="markdownIt-Anchor" href="#格式3"></a> 格式3</h4>
<p>无参数函数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">[capture list] &#123; function body &#125;</span><br></pre></td></tr></table></figure>
<h3 id="捕获外部变量"><a class="markdownIt-Anchor" href="#捕获外部变量"></a> 捕获外部变量</h3>
<table>
<thead>
<tr>
<th>捕获形式</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>[]</td>
<td>不捕获任何外部变量</td>
</tr>
<tr>
<td>[变量名…]</td>
<td>默认以值形式捕获多个指定外部变量，如果引用捕获，需要显式声明<code>&amp;</code>说明符</td>
</tr>
<tr>
<td>[this]</td>
<td>值形式捕获this指针</td>
</tr>
<tr>
<td>[=]</td>
<td>值形式捕获外部所有变量</td>
</tr>
<tr>
<td>[&amp;]</td>
<td>引用方式捕获外部所有变量</td>
</tr>
<tr>
<td>[=,&amp;x]</td>
<td>变量x用引用方式捕获，其余变量以传值形式捕获</td>
</tr>
<tr>
<td>[&amp;,x]</td>
<td>变量x以传值方式捕获，其余变量以引用形式捕获</td>
</tr>
</tbody>
</table>
<h3 id="lambda表达式的参数"><a class="markdownIt-Anchor" href="#lambda表达式的参数"></a> Lambda表达式的参数</h3>
<ol>
<li>参数列表中不能用默认参数</li>
<li>不支持可变长度的参数</li>
<li>所有参数必须有参数名</li>
</ol>
<h3 id="lambda表达式的类型"><a class="markdownIt-Anchor" href="#lambda表达式的类型"></a> Lambda表达式的类型</h3>
<p>Lambda 函数是一个依赖于实现的函数对象类型,这个类型的名字只有编译器知道. 如果用户想把 lambda 函数做为一个参数来传递, 那么形参的类型必须是模板类型或者必须能创建一个 <mark>std::function</mark> 类似的对象去捕获 lambda 函数.使用 auto 关键字可以帮助存储 Lambda 函数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> my_lambda_func = [&amp;](<span class="type">int</span> x) &#123; <span class="comment">/* ... */</span> &#125;;</span><br><span class="line"><span class="keyword">auto</span> my_onheap_lambda_func = <span class="keyword">new</span> <span class="built_in">auto</span>([=](<span class="type">int</span> x) &#123; <span class="comment">/* ... */</span> &#125;);</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">double</span> <span class="title">eval</span><span class="params">(std::function&lt;<span class="type">double</span>(<span class="type">double</span>)&gt; f,<span class="type">double</span> x=<span class="number">2.0</span>)</span></span>&#123;<span class="keyword">return</span> <span class="built_in">f</span>(x);&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	std::function&lt;<span class="type">double</span>(<span class="type">double</span>)&gt; f0 = [](<span class="type">double</span> x)&#123;<span class="keyword">return</span> <span class="number">1</span>;&#125;;</span><br><span class="line">    <span class="keyword">auto</span> f1 = [](<span class="type">double</span> x)&#123;<span class="keyword">return</span> x;&#125;;</span><br><span class="line">    <span class="keyword">decltype</span>(f0) fa[<span class="number">3</span>]=&#123;f0,f1,[](<span class="type">double</span> x)&#123;<span class="keyword">return</span> x*x;&#125;&#125;;</span><br><span class="line">    std::vector&lt;std::function&lt;<span class="type">double</span>(<span class="type">double</span>)&gt; &gt; fv = &#123;f0,f1&#125;;</span><br><span class="line">    fv.<span class="built_in">push_back</span>([](<span class="type">double</span> x)&#123;<span class="keyword">return</span> x*x;&#125;);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;fv.<span class="built_in">size</span>();i++) std::cout&lt;&lt;fv[i](<span class="number">2.0</span>)&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一个没有指定任何捕获的 lambda 函数,可以显式转换成一个具有相同声明形式函数指针.所以,像下面这样做是合法的:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> a_lambda_func = [](<span class="type">int</span> x) &#123; <span class="comment">/* ... */</span> &#125;;</span><br><span class="line"><span class="built_in">void</span> (*func_ptr)(<span class="type">int</span>) = a_lambda_func;</span><br><span class="line"><span class="built_in">func_ptr</span>(<span class="number">4</span>); <span class="comment">// calls the lambda</span></span><br></pre></td></tr></table></figure>
<p>但是<mark>带捕获的lambda是不能够作为函数指针进行参数传递</mark>。</p>
<h3 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h3>
<p><a href="https://www.cnblogs.com/DswCnblog/p/5629165.html">https://www.cnblogs.com/DswCnblog/p/5629165.html</a></p>
<p><a href="https://www.cnblogs.com/jimodetiantang/p/9016826.html">https://www.cnblogs.com/jimodetiantang/p/9016826.html</a></p>
<p>关于捕获和不捕获的lambda转换汇编代码分析</p>
<p><a href="https://blog.csdn.net/qq_36419971/article/details/117396419">https://blog.csdn.net/qq_36419971/article/details/117396419</a></p>
]]></content>
      <categories>
        <category>cpp</category>
        <category>cpp语法</category>
      </categories>
      <tags>
        <tag>cpp语法</tag>
      </tags>
  </entry>
  <entry>
    <title>unordered_map set自定义对象的hash</title>
    <url>/posts/f17b9616/</url>
    <content><![CDATA[<p><code>unordered_map/set</code>使用hash进行存储，因此存储自定义对象前，必须：</p>
<ol>
<li><code>hash</code>告知此容器如何生成hash值，</li>
<li><code>equal_to</code>告知容器当出现hash冲突时，如何区分hash值相同的不同对象。</li>
</ol>
<p><strong>具体有4种方案</strong>：</p>
<ol>
<li>定义两个函数对象ObjectHash，以及ObjectCmp，分别实现对Object进行hash，以及比较两个对象是否相同。</li>
<li>定义两个普通的函数，实现hash以及对象比较，与<mark>1</mark>不同的是普通函数在构建<code>unordered_map/set</code>时，需要decltype来减少声明它的类型（或手动指定，<code>std::function &lt;size_t(const Object&amp;)&gt;</code>说明hash类型，<code>std::function &lt;bool(const Object&amp;, const Object&amp;)&gt;</code>说明比较cmp类型</li>
<li>定义两个lambda表达式（仿函数），与2类似</li>
<li>对Object对象进行模板特化定制</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"># unordered_set的声明</span><br><span class="line"><span class="keyword">template</span>&lt;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Key</span>, <span class="comment">//类型</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Hash</span> = std::hash&lt;Key&gt;,</span><br><span class="line">    <span class="keyword">class</span> KeyEqual = std::equal_to&lt;Key&gt;,</span><br><span class="line">    <span class="keyword">class</span> Allocator = std::allocator&lt;Key&gt;</span><br><span class="line">&gt; <span class="keyword">class</span> unordered_set;</span><br><span class="line"></span><br><span class="line">#unordered_map的声明</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">Key</span>, <span class="comment">//key的类型</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Ty</span>, <span class="comment">//val的类型</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Hash</span> = std::hash&lt;Key&gt;,</span><br><span class="line">    <span class="keyword">class</span> Pred = std::equal_to&lt;Key&gt;,</span><br><span class="line">    <span class="keyword">class</span> Alloc = std::allocator&lt;std::pair&lt;<span class="type">const</span> Key, Ty&gt; &gt; &gt;</span><br><span class="line">    <span class="keyword">class</span> unordered_map;</span><br><span class="line">&gt; <span class="keyword">class</span> <span class="title class_">unordered_map</span></span><br></pre></td></tr></table></figure>
<h3 id="示例"><a class="markdownIt-Anchor" href="#示例"></a> 示例</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"># 自定义<span class="keyword">struct</span>的类型</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Object</span>&#123;</span><br><span class="line">    string name;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="定义两个函数对象"><a class="markdownIt-Anchor" href="#定义两个函数对象"></a> 定义两个函数对象</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ObjectHash</span>&#123;</span><br><span class="line">	<span class="function"><span class="type">size_t</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> Object&amp; rhs)</span><span class="type">const</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">hash</span>&lt;string&gt;()(rhs.name) ^ <span class="built_in">hash</span>&lt;<span class="type">int</span>&gt;()(rhs.val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ObjectCmp</span>&#123;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> Object&amp; lhs,<span class="type">const</span> Object&amp; rhs)</span><span class="type">const</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> lhs.name == rhs.name &amp;&amp; lhs.val ==rhs.val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">unordered_set&lt;Object,ObjectHash,ObjectCmp&gt; objects;</span><br></pre></td></tr></table></figure>
<h4 id="定义两个普通函数重写hash和cmp"><a class="markdownIt-Anchor" href="#定义两个普通函数重写hash和cmp"></a> 定义两个普通函数，重写hash和cmp</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">ObjectHash</span><span class="params">(<span class="type">const</span> Object&amp; rhs)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">hash</span>&lt;string&gt;()(rhs.name) ^ <span class="built_in">hash</span>&lt;<span class="type">int</span>&gt;()(rhs.val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ObjectCmp</span><span class="params">(<span class="type">const</span> Object&amp; lhs, <span class="type">const</span> Record&amp; rhs)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> lhs.name == rhs.name &amp;&amp; lhs.val == rhs.val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">unordered_set&lt;Object , <span class="title">decltype</span><span class="params">(&amp;ObjectHash)</span>, <span class="title">decltype</span><span class="params">(&amp;ObjectCmp)</span>&gt; <span class="title">objects</span><span class="params">(<span class="number">0</span>,ObjectHash,ObjectCmp)</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="使用lambda函数"><a class="markdownIt-Anchor" href="#使用lambda函数"></a> 使用lambda函数</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> ObjectHash = [](<span class="type">const</span> Object&amp; rhs)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">hash</span>&lt;string&gt;(rhs.name) ^ <span class="built_in">hash</span>&lt;<span class="type">int</span>&gt;()(rhs.val);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> ObjectCmp = [](<span class="type">const</span> Object&amp; lhs, <span class="type">const</span> Object&amp; rhs)&#123;</span><br><span class="line">    <span class="keyword">return</span> lhs.name==rhs.name &amp;&amp; lhs.val==rhs.val;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">unordered_set&lt;Object, <span class="keyword">decltype</span>(&amp;ObjectHash),<span class="keyword">decltype</span>(&amp;ObjectCmp)&gt;<span class="built_in">object</span>(<span class="number">0</span>,ObjectHash,ObjectCmp);</span><br></pre></td></tr></table></figure>
<h4 id="模板定制重写"><a class="markdownIt-Anchor" href="#模板定制重写"></a> 模板定制重写</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//注意namespace ，必要时可以指定namespace std&#123;&#125;</span></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">hash</span>&lt;Object&gt;&#123;</span><br><span class="line">    <span class="function"><span class="type">size_t</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> Object&amp; rhs)</span><span class="type">const</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">hash</span>&lt;string&gt;()(rhs.name) ^ <span class="built_in">hash</span>&lt;<span class="type">int</span>&gt;()(rhs.val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">equal_to</span>&lt;Object&gt;&#123;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> Object&amp; lhs,<span class="type">const</span> Object&amp; rhs)</span><span class="type">const</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> lhs.name == rhs.name &amp;&amp; lhs.val == rhs.val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">unordered_set&lt;Object&gt; objects;</span><br></pre></td></tr></table></figure>
<h3 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h3>
<p><a href="https://blog.csdn.net/lpstudy/article/details/54345050">https://blog.csdn.net/lpstudy/article/details/54345050</a></p>
<p><a href="https://blog.csdn.net/y109y/article/details/82669620">https://blog.csdn.net/y109y/article/details/82669620</a></p>
]]></content>
      <categories>
        <category>cpp</category>
        <category>cpp语法</category>
      </categories>
      <tags>
        <tag>cpp语法</tag>
      </tags>
  </entry>
</search>
