<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>密码testpassword</title>
    <url>/posts/d5cdaa49/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">
  <script id="hbeData" type="hbeData" data-hmacdigest="ff70b20ab201b4a3ad0b6750e19f901fa1443cb40589f1cf72d2c936a2eecebe">4c7001934e3e5a2a8fd08e6c38ff7447bba297e9690d41d48dabbda263c1454a84a1183e69110c19be8abbba96073d6f</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-blink">
      <input class="hbe hbe-input-field hbe-input-field-blink" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-blink" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-blink" data-content="您好, 这里需要密码.">您好, 这里需要密码.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>test</category>
      </categories>
      <tags>
        <tag>test</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo setups</title>
    <url>/posts/b763a0b1/</url>
    <content><![CDATA[<h3 id="centos-关闭selinux"><a class="markdownIt-Anchor" href="#centos-关闭selinux"></a> centos 关闭SELINUX</h3>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$ </span><span class="language-bash">setenforce 0</span></span><br><span class="line"><span class="meta">$ </span><span class="language-bash">sed -i <span class="string">&#x27;s/SELINUX=enforcing/SELINUX=disabled/&#x27;</span> /etc/selinux/config</span></span><br></pre></td></tr></table></figure>
<h3 id="创建tags-caterories"><a class="markdownIt-Anchor" href="#创建tags-caterories"></a> 创建tags、caterories</h3>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$ </span><span class="language-bash">hexo new page <span class="string">&quot;tags&quot;</span></span></span><br></pre></td></tr></table></figure>
<p>修改source/tags/index.md</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">tags</span></span><br><span class="line"><span class="attr">date:</span> <span class="number">2017-07-10 16:36:26</span></span><br><span class="line"><span class="attr">type:</span> <span class="string">&quot;tags&quot;</span></span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></table></figure>
<p>修改themes/next/_config.yml</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">menu:</span></span><br><span class="line"><span class="attr">home:</span> <span class="string">/</span></span><br><span class="line"><span class="attr">archives:</span> <span class="string">/archives/</span></span><br><span class="line"><span class="attr">categories:</span> <span class="string">/categories/</span></span><br><span class="line"><span class="attr">tags:</span> <span class="string">/tags/</span></span><br></pre></td></tr></table></figure>
<p>tags 不存在多级,cat可以多级</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">categories:</span><br><span class="line">- [Sports, Baseball]</span><br><span class="line">- Baseball</span><br><span class="line">tags:</span><br><span class="line">- Injury</span><br><span class="line">- Fight</span><br><span class="line">- Shocking</span><br></pre></td></tr></table></figure>
<p>使用katex</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$ </span><span class="language-bash">npm un hexo-renderer-marked</span></span><br><span class="line"><span class="meta">$ </span><span class="language-bash">npm i hexo-renderer-markdown-it-plus</span></span><br></pre></td></tr></table></figure>
<h3 id="修改自定义样式"><a class="markdownIt-Anchor" href="#修改自定义样式"></a> 修改自定义样式</h3>
<p><code>css/_common/outline/footer/index.styl</code></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.footer-inner</span> &gt; <span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">padding-left</span>: <span class="number">8px</span>;</span><br><span class="line">  <span class="attribute">padding-right</span>: <span class="number">8px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="博客加密"><a class="markdownIt-Anchor" href="#博客加密"></a> 博客加密</h3>
<p><a href="https://github.com/D0n9X1n/hexo-blog-encrypt/blob/master/ReadMe.zh.md">https://github.com/D0n9X1n/hexo-blog-encrypt/blob/master/ReadMe.zh.md</a></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$ </span><span class="language-bash">npm install --save hexo-blog-encrypt</span></span><br></pre></td></tr></table></figure>
<h4 id="对博文加密"><a class="markdownIt-Anchor" href="#对博文加密"></a> 对博文加密</h4>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">Hello</span> <span class="string">World</span></span><br><span class="line"><span class="attr">tags:</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">作为日记加密</span></span><br><span class="line"><span class="attr">date:</span> <span class="number">2016-03-30 21:12:21</span></span><br><span class="line"><span class="attr">password:</span> <span class="string">mikemessi</span></span><br><span class="line"><span class="attr">abstract:</span> <span class="string">有东西被加密了,</span> <span class="string">请输入密码查看.</span></span><br><span class="line"><span class="attr">message:</span> <span class="string">您好,</span> <span class="string">这里需要密码.</span></span><br><span class="line"><span class="attr">wrong_pass_message:</span> <span class="string">抱歉,</span> <span class="string">这个密码看着不太对,</span> <span class="string">请再试试.</span></span><br><span class="line"><span class="attr">wrong_hash_message:</span> <span class="string">抱歉,</span> <span class="string">这个文章不能被校验,</span> <span class="string">不过您还是能看看解密后的内容.</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="meta"></span></span><br></pre></td></tr></table></figure>
<h4 id="对tag加密"><a class="markdownIt-Anchor" href="#对tag加密"></a> 对tag加密</h4>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># Security</span></span><br><span class="line"><span class="attr">encrypt:</span> <span class="comment"># hexo-blog-encrypt</span></span><br><span class="line">  <span class="attr">abstract:</span> <span class="string">有东西被加密了,</span> <span class="string">请输入密码查看.</span></span><br><span class="line">  <span class="attr">message:</span> <span class="string">您好,</span> <span class="string">这里需要密码.</span></span><br><span class="line">  <span class="attr">tags:</span></span><br><span class="line">  <span class="bullet">-</span> &#123;<span class="attr">name:</span> <span class="string">tagName</span>, <span class="attr">password:</span> <span class="string">密码A</span>&#125;</span><br><span class="line">  <span class="bullet">-</span> &#123;<span class="attr">name:</span> <span class="string">tagName</span>, <span class="attr">password:</span> <span class="string">密码B</span>&#125;</span><br><span class="line">  <span class="attr">wrong_pass_message:</span> <span class="string">抱歉,</span> <span class="string">这个密码看着不太对,</span> <span class="string">请再试试.</span></span><br><span class="line">  <span class="attr">wrong_hash_message:</span> <span class="string">抱歉,</span> <span class="string">这个文章不能被校验,</span> <span class="string">不过您还是能看看解密后的内容.</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><a href="https://theme-next.js.org/docs/theme-settings/">https://theme-next.js.org/docs/theme-settings/</a></p>
<p><code>zhumeng2021.2\node_modules\hexo-theme-next\layout\_macro\sidebar.njk</code> 对sidebar修改</p>
<p><code>zhumeng2021.2\node_modules\hexo-theme-next\layout\_partials\post\post-related.njk</code>对related修改</p>
<p><code>C:\Users\42273\Desktop\hexo_blog\zhumeng2021.2\.deploy_git\js\schemes\muse.js</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (event.<span class="property">target</span>.<span class="title function_">matches</span>(<span class="string">&#x27;img.medium-zoom-image&#x27;</span>)) &#123;<span class="comment">// 删去clickingBlankPart||</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">hideSidebar</span>();</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>
<hr />
<p>TODO:</p>
<ol>
<li>
<h4 id="configuring-favicon"><a class="markdownIt-Anchor" href="#configuring-favicon"></a> Configuring Favicon</h4>
</li>
</ol>
]]></content>
      <categories>
        <category>环境搭建</category>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>【C++语法进阶】Lambda表达式</title>
    <url>/posts/e9ee750c/</url>
    <content><![CDATA[<h3 id="声明lambda表达式"><a class="markdownIt-Anchor" href="#声明lambda表达式"></a> 声明Lambda表达式</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">[capture list] (params list) <span class="keyword">mutable</span> exception-&gt; <span class="keyword">return</span> type &#123; function body &#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>capture list： 捕获外部变量的列表</li>
<li>params list：形参列表</li>
<li>mutable指示符：是否可以修改捕获的变量</li>
<li>exception：异常设定</li>
<li>return type：返回类型</li>
<li>function body：函数体</li>
</ol>
<h4 id="格式1"><a class="markdownIt-Anchor" href="#格式1"></a> 格式1</h4>
<p>声明了const类型的表达式，函数中不能修改捕获列表中的值（引用传递除外）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">[capture list] (params list) -&gt; <span class="keyword">return</span> type &#123; function body &#125;</span><br></pre></td></tr></table></figure>
<h4 id="格式2"><a class="markdownIt-Anchor" href="#格式2"></a> 格式2</h4>
<p>省略了返回值的类型，编译器自动推断，若：</p>
<ol>
<li>
<p>含有return，则类型由return决定</p>
</li>
<li>
<p>不含有return，类型为void</p>
</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">[capture list] (params list)  &#123; function body &#125;</span><br></pre></td></tr></table></figure>
<h4 id="格式3"><a class="markdownIt-Anchor" href="#格式3"></a> 格式3</h4>
<p>无参数函数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">[capture list] &#123; function body &#125;</span><br></pre></td></tr></table></figure>
<h3 id="捕获外部变量"><a class="markdownIt-Anchor" href="#捕获外部变量"></a> 捕获外部变量</h3>
<table>
<thead>
<tr>
<th>捕获形式</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>[]</td>
<td>不捕获任何外部变量</td>
</tr>
<tr>
<td>[变量名…]</td>
<td>默认以值形式捕获多个指定外部变量，如果引用捕获，需要显式声明<code>&amp;</code>说明符</td>
</tr>
<tr>
<td>[this]</td>
<td>值形式捕获this指针</td>
</tr>
<tr>
<td>[=]</td>
<td>值形式捕获外部所有变量</td>
</tr>
<tr>
<td>[&amp;]</td>
<td>引用方式捕获外部所有变量</td>
</tr>
<tr>
<td>[=,&amp;x]</td>
<td>变量x用引用方式捕获，其余变量以传值形式捕获</td>
</tr>
<tr>
<td>[&amp;,x]</td>
<td>变量x以传值方式捕获，其余变量以引用形式捕获</td>
</tr>
</tbody>
</table>
<h3 id="lambda表达式的参数"><a class="markdownIt-Anchor" href="#lambda表达式的参数"></a> Lambda表达式的参数</h3>
<ol>
<li>参数列表中不能用默认参数</li>
<li>不支持可变长度的参数</li>
<li>所有参数必须有参数名</li>
</ol>
<h3 id="lambda表达式的类型"><a class="markdownIt-Anchor" href="#lambda表达式的类型"></a> Lambda表达式的类型</h3>
<p>Lambda 函数是一个依赖于实现的函数对象类型,这个类型的名字只有编译器知道. 如果用户想把 lambda 函数做为一个参数来传递, 那么形参的类型必须是模板类型或者必须能创建一个 <mark>std::function</mark> 类似的对象去捕获 lambda 函数.使用 auto 关键字可以帮助存储 Lambda 函数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> my_lambda_func = [&amp;](<span class="type">int</span> x) &#123; <span class="comment">/* ... */</span> &#125;;</span><br><span class="line"><span class="keyword">auto</span> my_onheap_lambda_func = <span class="keyword">new</span> <span class="built_in">auto</span>([=](<span class="type">int</span> x) &#123; <span class="comment">/* ... */</span> &#125;);</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">double</span> <span class="title">eval</span><span class="params">(std::function&lt;<span class="type">double</span>(<span class="type">double</span>)&gt; f,<span class="type">double</span> x=<span class="number">2.0</span>)</span></span>&#123;<span class="keyword">return</span> <span class="built_in">f</span>(x);&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	std::function&lt;<span class="type">double</span>(<span class="type">double</span>)&gt; f0 = [](<span class="type">double</span> x)&#123;<span class="keyword">return</span> <span class="number">1</span>;&#125;;</span><br><span class="line">    <span class="keyword">auto</span> f1 = [](<span class="type">double</span> x)&#123;<span class="keyword">return</span> x;&#125;;</span><br><span class="line">    <span class="keyword">decltype</span>(f0) fa[<span class="number">3</span>]=&#123;f0,f1,[](<span class="type">double</span> x)&#123;<span class="keyword">return</span> x*x;&#125;&#125;;</span><br><span class="line">    std::vector&lt;std::function&lt;<span class="type">double</span>(<span class="type">double</span>)&gt; &gt; fv = &#123;f0,f1&#125;;</span><br><span class="line">    fv.<span class="built_in">push_back</span>([](<span class="type">double</span> x)&#123;<span class="keyword">return</span> x*x;&#125;);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;fv.<span class="built_in">size</span>();i++) std::cout&lt;&lt;fv[i](<span class="number">2.0</span>)&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一个没有指定任何捕获的 lambda 函数,可以显式转换成一个具有相同声明形式函数指针.所以,像下面这样做是合法的:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> a_lambda_func = [](<span class="type">int</span> x) &#123; <span class="comment">/* ... */</span> &#125;;</span><br><span class="line"><span class="built_in">void</span> (*func_ptr)(<span class="type">int</span>) = a_lambda_func;</span><br><span class="line"><span class="built_in">func_ptr</span>(<span class="number">4</span>); <span class="comment">// calls the lambda</span></span><br></pre></td></tr></table></figure>
<p>但是<mark>带捕获的lambda是不能够作为函数指针进行参数传递</mark>。</p>
<h3 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h3>
<p><a href="https://www.cnblogs.com/DswCnblog/p/5629165.html">https://www.cnblogs.com/DswCnblog/p/5629165.html</a></p>
<p><a href="https://www.cnblogs.com/jimodetiantang/p/9016826.html">https://www.cnblogs.com/jimodetiantang/p/9016826.html</a></p>
<p>关于捕获和不捕获的lambda转换汇编代码分析https://blog.csdn.net/qq_36419971/article/details/117396419</p>
]]></content>
      <categories>
        <category>cpp</category>
        <category>cpp语法</category>
      </categories>
      <tags>
        <tag>cpp语法</tag>
      </tags>
  </entry>
  <entry>
    <title>test_code</title>
    <url>/posts/726c1a57/</url>
    <content><![CDATA[<h2 id="三维dp"><a class="markdownIt-Anchor" href="#三维dp"></a> 三维dp</h2>
<h3 id="dqwdwq"><a class="markdownIt-Anchor" href="#dqwdwq"></a> dqwdwq</h3>
<p><mark>dwqd</mark><br />
<img data-src="http://hz-picbed-xxh.oss-cn-hangzhou.aliyuncs.com/img-bed/3-1Q113131610L7.gif" alt="顾客购物程序的类图" /></p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msubsup><mo>∑</mo><mi>x</mi><mrow><mi>s</mi><mi>d</mi></mrow></msubsup><mfrac><mrow><mfrac><mi>a</mi><mi>b</mi></mfrac><mo>+</mo><mi>a</mi></mrow><mi>α</mi></mfrac></mrow><annotation encoding="application/x-tex">\sum_{x}^{sd}{\frac{a}{b}+{a}\over{\alpha}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.37988em;vertical-align:-0.345em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9890079999999999em;"><span style="top:-2.40029em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">x</span></span></span></span><span style="top:-3.2029em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">s</span><span class="mord mathdefault mtight">d</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.29971000000000003em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.03488em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.0037em;">α</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.5508em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mopen nulldelimiter sizing reset-size3 size6"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.6915428571428572em;"><span style="top:-2.656em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">b</span></span></span></span><span style="top:-3.2255000000000003em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line mtight" style="border-bottom-width:0.049em;"></span></span><span style="top:-3.384em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">a</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.344em;"><span></span></span></span></span></span><span class="mclose nulldelimiter sizing reset-size3 size6"></span></span><span class="mbin mtight">+</span><span class="mord mtight"><span class="mord mathdefault mtight">a</span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p>
<a id="more"></a>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mo>∗</mo><msup><mi>b</mi><mn>2</mn></msup><mspace width="1em"/><mo stretchy="false">(</mo><mi>b</mi><mi>ω</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">a*b^2 \quad (b \omega)
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.46528em;vertical-align:0em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.1141079999999999em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:1em;"></span><span class="mopen">(</span><span class="mord mathdefault">b</span><span class="mord mathdefault" style="margin-right:0.03588em;">ω</span><span class="mclose">)</span></span></span></span></span></p>
<p><code>dwqdnjk</code><br />
<code>test for ms code</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @Descripttion: 111 https://leetcode.com/discuss/interview-question/1488563/microsoft-on-campus-2021-india</span></span><br><span class="line"><span class="comment"> * @version: </span></span><br><span class="line"><span class="comment"> * @Author: xxh</span></span><br><span class="line"><span class="comment"> * @Date: 2022-01-23</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;dp;</span><br><span class="line"><span class="type">int</span> dd[<span class="number">100</span>][<span class="number">2</span>][<span class="number">200</span>]=&#123;<span class="number">-1</span>&#125; ;<span class="comment">//pos - -x/y - value</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; h,<span class="type">int</span> pos,<span class="type">int</span> rx,<span class="type">int</span> ry,<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pos&gt;=n) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(dp[pos][<span class="built_in">abs</span>(rx-ry)]!=<span class="number">-1</span>)<span class="keyword">return</span> dp[pos][<span class="built_in">abs</span>(rx-ry)];</span><br><span class="line">    <span class="type">int</span> v1=<span class="number">0</span>,v2=<span class="number">0</span>,v3=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(rx&gt;=h[pos])v1 = <span class="number">1</span>+<span class="built_in">dfs</span>(h,pos+<span class="number">1</span>,rx-h[pos],ry,n);</span><br><span class="line">    <span class="keyword">if</span>(ry&gt;=h[pos]) v2 = <span class="number">1</span>+<span class="built_in">dfs</span>(h,pos+<span class="number">1</span>,rx,ry-h[pos],n);</span><br><span class="line">    v3=<span class="built_in">dfs</span>(h,pos+<span class="number">1</span>,rx,ry,n);</span><br><span class="line">    dp[pos][<span class="built_in">abs</span>(rx-ry)] = <span class="built_in">max</span>(v1,<span class="built_in">max</span>(v2,v3));</span><br><span class="line">    <span class="keyword">return</span> dp[pos][<span class="built_in">abs</span>(rx-ry)];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">f</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; h,<span class="type">int</span> pos,<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    dd[<span class="number">0</span>][<span class="number">0</span>][x]=dd[<span class="number">0</span>][<span class="number">1</span>][y]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = x;j&gt;=h[i<span class="number">-1</span>];j--) <span class="comment">//x</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k=y;k&gt;=<span class="number">0</span>;k--)&#123; <span class="comment">//y</span></span><br><span class="line">                <span class="keyword">if</span>(dd[i<span class="number">-1</span>][<span class="number">1</span>][k]!=<span class="number">-1</span>&amp;&amp;dd[i<span class="number">-1</span>][<span class="number">0</span>][j]!=<span class="number">-1</span>) &#123;</span><br><span class="line">                    dd[i][<span class="number">0</span>][j-h[i<span class="number">-1</span>]]= <span class="built_in">max</span>(dd[i<span class="number">-1</span>][<span class="number">1</span>][k]+dd[i<span class="number">-1</span>][<span class="number">0</span>][j]+<span class="number">1</span>,dd[i][<span class="number">0</span>][j-h[i<span class="number">-1</span>]]);</span><br><span class="line">                    cout&lt;&lt;i&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;j&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;dd[i][<span class="number">0</span>][j-h[i<span class="number">-1</span>]]&lt;&lt;endl;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = y;j&gt;=h[i<span class="number">-1</span>];j--)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k=x;k&gt;=<span class="number">0</span>;k--)&#123;</span><br><span class="line">                <span class="keyword">if</span>(dd[i<span class="number">-1</span>][<span class="number">0</span>][k]!=<span class="number">-1</span>&amp;&amp;dd[i<span class="number">-1</span>][<span class="number">1</span>][j]!=<span class="number">-1</span>) dd[i][<span class="number">1</span>][j-h[i<span class="number">-1</span>]] = <span class="built_in">max</span>(dd[i<span class="number">-1</span>][<span class="number">0</span>][k]+dd[i<span class="number">-1</span>][<span class="number">1</span>][j]+<span class="number">1</span>,dd[i][<span class="number">1</span>][j-h[i<span class="number">-1</span>]]);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mx =<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;<span class="number">100</span>;i++)&#123;</span><br><span class="line">        <span class="comment">//cout&lt;&lt;dd[n-1][0][i];</span></span><br><span class="line">        mx = <span class="built_in">max</span>(mx,dd[n<span class="number">-1</span>][<span class="number">0</span>][i]);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="type">int</span> my = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;<span class="number">100</span>;i++)&#123;</span><br><span class="line">        <span class="comment">//cout&lt;&lt;dd[n-1][1][i];</span></span><br><span class="line">        my = <span class="built_in">max</span>(my,dd[n<span class="number">-1</span>][<span class="number">1</span>][i]);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>(mx,my);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;h=&#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">4</span>&#125;;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">8</span>,y=<span class="number">9</span>;</span><br><span class="line">    <span class="type">int</span> n = h.<span class="built_in">size</span>();</span><br><span class="line">    dp.<span class="built_in">resize</span>(n,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="built_in">max</span>(x,y)+<span class="number">1</span>,<span class="number">-1</span>));</span><br><span class="line">    <span class="built_in">memset</span>(dd,<span class="number">0xff</span>,<span class="built_in">sizeof</span>(dd));</span><br><span class="line">    cout&lt;&lt;<span class="built_in">f</span>(h,<span class="number">0</span>,x,y,n);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>test</category>
        <category>面试题</category>
        <category>MS</category>
      </categories>
      <tags>
        <tag>test</tag>
        <tag>dp</tag>
        <tag>ms面试题</tag>
      </tags>
  </entry>
  <entry>
    <title>unordered_map set自定义对象的hash</title>
    <url>/posts/f17b9616/</url>
    <content><![CDATA[<p><code>unordered_map/set</code>使用hash进行存储，因此存储自定义对象前，必须：</p>
<ol>
<li><code>hash</code>告知此容器如何生成hash值，</li>
<li><code>equal_to</code>告知容器当出现hash冲突时，如何区分hash值相同的不同对象。</li>
</ol>
<p><strong>具体有4种方案</strong>：</p>
<ol>
<li>定义两个函数对象ObjectHash，以及ObjectCmp，分别实现对Object进行hash，以及比较两个对象是否相同。</li>
<li>定义两个普通的函数，实现hash以及对象比较，与<mark>1</mark>不同的是普通函数在构建<code>unordered_map/set</code>时，需要decltype来减少声明它的类型（或手动指定，<code>std::function &lt;size_t(const Object&amp;)&gt;</code>说明hash类型，<code>std::function &lt;bool(const Object&amp;, const Object&amp;)&gt;</code>说明比较cmp类型</li>
<li>定义两个lambda表达式（仿函数），与2类似</li>
<li>对Object对象进行模板特化定制</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"># unordered_set的声明</span><br><span class="line"><span class="keyword">template</span>&lt;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Key</span>, <span class="comment">//类型</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Hash</span> = std::hash&lt;Key&gt;,</span><br><span class="line">    <span class="keyword">class</span> KeyEqual = std::equal_to&lt;Key&gt;,</span><br><span class="line">    <span class="keyword">class</span> Allocator = std::allocator&lt;Key&gt;</span><br><span class="line">&gt; <span class="keyword">class</span> unordered_set;</span><br><span class="line"></span><br><span class="line">#unordered_map的声明</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">Key</span>, <span class="comment">//key的类型</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Ty</span>, <span class="comment">//val的类型</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Hash</span> = std::hash&lt;Key&gt;,</span><br><span class="line">    <span class="keyword">class</span> Pred = std::equal_to&lt;Key&gt;,</span><br><span class="line">    <span class="keyword">class</span> Alloc = std::allocator&lt;std::pair&lt;<span class="type">const</span> Key, Ty&gt; &gt; &gt;</span><br><span class="line">    <span class="keyword">class</span> unordered_map;</span><br><span class="line">&gt; <span class="keyword">class</span> <span class="title class_">unordered_map</span></span><br></pre></td></tr></table></figure>
<h3 id="示例"><a class="markdownIt-Anchor" href="#示例"></a> 示例</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"># 自定义<span class="keyword">struct</span>的类型</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Object</span>&#123;</span><br><span class="line">    string name;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="定义两个函数对象"><a class="markdownIt-Anchor" href="#定义两个函数对象"></a> 定义两个函数对象</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ObjectHash</span>&#123;</span><br><span class="line">	<span class="function"><span class="type">size_t</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> Object&amp; rhs)</span><span class="type">const</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">hash</span>&lt;string&gt;()(rhs.name) ^ <span class="built_in">hash</span>&lt;<span class="type">int</span>&gt;()(rhs.val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ObjectCmp</span>&#123;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> Object&amp; lhs,<span class="type">const</span> Object&amp; rhs)</span><span class="type">const</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> lhs.name == rhs.name &amp;&amp; lhs.val ==rhs.val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">unordered_set&lt;Object,ObjectHash,ObjectCmp&gt; objects;</span><br></pre></td></tr></table></figure>
<h4 id="定义两个普通函数重写hash和cmp"><a class="markdownIt-Anchor" href="#定义两个普通函数重写hash和cmp"></a> 定义两个普通函数，重写hash和cmp</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">ObjectHash</span><span class="params">(<span class="type">const</span> Object&amp; rhs)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">hash</span>&lt;string&gt;()(rhs.name) ^ <span class="built_in">hash</span>&lt;<span class="type">int</span>&gt;()(rhs.val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ObjectCmp</span><span class="params">(<span class="type">const</span> Object&amp; lhs, <span class="type">const</span> Record&amp; rhs)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> lhs.name == rhs.name &amp;&amp; lhs.val == rhs.val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">unordered_set&lt;Object , <span class="title">decltype</span><span class="params">(&amp;ObjectHash)</span>, <span class="title">decltype</span><span class="params">(&amp;ObjectCmp)</span>&gt; <span class="title">objects</span><span class="params">(<span class="number">0</span>,ObjectHash,ObjectCmp)</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="使用lambda函数"><a class="markdownIt-Anchor" href="#使用lambda函数"></a> 使用lambda函数</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> ObjectHash = [](<span class="type">const</span> Object&amp; rhs)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">hash</span>&lt;string&gt;(rhs.name) ^ <span class="built_in">hash</span>&lt;<span class="type">int</span>&gt;()(rhs.val);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> ObjectCmp = [](<span class="type">const</span> Object&amp; lhs, <span class="type">const</span> Object&amp; rhs)&#123;</span><br><span class="line">    <span class="keyword">return</span> lhs.name==rhs.name &amp;&amp; lhs.val==rhs.val;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">unordered_set&lt;Object, <span class="keyword">decltype</span>(&amp;ObjectHash),<span class="keyword">decltype</span>(&amp;ObjectCmp)&gt;<span class="built_in">object</span>(<span class="number">0</span>,ObjectHash,ObjectCmp);</span><br></pre></td></tr></table></figure>
<h4 id="模板定制重写"><a class="markdownIt-Anchor" href="#模板定制重写"></a> 模板定制重写</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//注意namespace ，必要时可以指定namespace std&#123;&#125;</span></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">hash</span>&lt;Object&gt;&#123;</span><br><span class="line">    <span class="function"><span class="type">size_t</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> Object&amp; rhs)</span><span class="type">const</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">hash</span>&lt;string&gt;()(rhs.name) ^ <span class="built_in">hash</span>&lt;<span class="type">int</span>&gt;()(rhs.val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">equal_to</span>&lt;Object&gt;&#123;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> Object&amp; lhs,<span class="type">const</span> Object&amp; rhs)</span><span class="type">const</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> lhs.name == rhs.name &amp;&amp; lhs.val == rhs.val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">unordered_set&lt;Object&gt; objects;</span><br></pre></td></tr></table></figure>
<h3 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h3>
<p><a href="https://blog.csdn.net/lpstudy/article/details/54345050">https://blog.csdn.net/lpstudy/article/details/54345050</a></p>
]]></content>
      <categories>
        <category>cpp</category>
        <category>cpp语法</category>
      </categories>
      <tags>
        <tag>cpp语法</tag>
      </tags>
  </entry>
  <entry>
    <title>yaml语法示例</title>
    <url>/posts/34fc2379/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">
  <script id="hbeData" type="hbeData" data-hmacdigest="75cc7945f0190a6df86e1545aec5bf0f9336b15c28b38d82970ed72009aeb283">16c747dc6985ee4fafa2dd616ad7bafaab8a56bd6dcf72a9a0497175f435dd9a</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-blink">
      <input class="hbe hbe-input-field hbe-input-field-blink" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-blink" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-blink" data-content="您好, 这里需要密码.">您好, 这里需要密码.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>test</category>
      </categories>
      <tags>
        <tag>test</tag>
      </tags>
  </entry>
  <entry>
    <title>decltype关键字</title>
    <url>/posts/6d46b940/</url>
    <content><![CDATA[<h3 id="decltype关键字"><a class="markdownIt-Anchor" href="#decltype关键字"></a> decltype关键字</h3>
<p><mark>decltype</mark>被称作类型说明符，作用是选择并返回操作数的数据类型。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// sum类型就是函数f返回的类型</span></span><br><span class="line"><span class="keyword">decltype</span>(<span class="built_in">f</span>()) sum = x;</span><br></pre></td></tr></table></figure>
<p>解决难以拼写的类型名，有以下两个方案：</p>
<ol>
<li>使用类型别名技术</li>
<li>使用auto和decltype</li>
</ol>
<h3 id="工作原理"><a class="markdownIt-Anchor" href="#工作原理"></a> 工作原理</h3>
<p><mark>decltype</mark>不会计算表达式的值，编译器分析表达式并得到它的类型。</p>
<p>函数调用也算一种表达式，因此不必担心在使用deltype时执行了函数。</p>
<h3 id="decltype变量"><a class="markdownIt-Anchor" href="#decltype变量"></a> decltype+变量</h3>
<p>根据表达式的定义，单独使用一个变量，相当于一个最简单的表达式。</p>
]]></content>
      <categories>
        <category>cpp</category>
        <category>cpp语法</category>
      </categories>
      <tags>
        <tag>cpp语法</tag>
      </tags>
  </entry>
  <entry>
    <title>【每日】1984. 学生分数的最小差值</title>
    <url>/posts/3e175728/</url>
    <content><![CDATA[<p><img data-src="http://hz-picbed-xxh.oss-cn-hangzhou.aliyuncs.com/img-bed/image-20220211134306054.png" alt="image-20220211134306054" /></p>
<blockquote>
<p>思路：排序后使用滑动窗口的思想，取窗口内最大值和最小值，即i和i+k-1的差值，取最小。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minimumDifference</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(k==<span class="number">1</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="type">int</span> mi = INT_MAX;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i+k<span class="number">-1</span>&lt;nums.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            mi = <span class="built_in">min</span>(mi,nums[i+k<span class="number">-1</span>]-nums[i]);</span><br><span class="line">        </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> mi;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
        <category>力扣</category>
        <category>每日一题</category>
        <category>模拟题</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>二分算法详解</title>
    <url>/posts/99d9a14f/</url>
    <content><![CDATA[<h3 id="常规二分写法"><a class="markdownIt-Anchor" href="#常规二分写法"></a> 常规二分写法</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(l&lt;=r)&#123;</span><br><span class="line">    <span class="type">int</span> mid = l+ (r-l&gt;&gt;<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(mid = target) <span class="keyword">return</span> mid;</span><br><span class="line">    <span class="keyword">if</span>(mid&lt;target)l = mid+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> r = mid<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br></pre></td></tr></table></figure>
<p>每次搜索的区间是[l,r]，因此l和r均不包含mid</p>
<h3 id="查找target的右边界"><a class="markdownIt-Anchor" href="#查找target的右边界"></a> 查找&lt;=target的右边界</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line">    <span class="type">int</span> mid = l + (r-l&gt;&gt;<span class="number">1</span>)+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(mid&lt;=target) l = mid;</span><br><span class="line">    <span class="keyword">else</span> r = mid<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> l;</span><br></pre></td></tr></table></figure>
<ol>
<li>收缩区间，查找右边界指在&lt;=target的区间中取最大的一个，即&gt;target的区间舍去，<code>r = mid-1</code>，每次搜索的区间是(left,right]</li>
<li>因为<code>mid = l+(r-l&gt;&gt;1)</code>总是落在(l+r)/2的右侧，<code>l=mid</code>可以保证<code>l</code>始终在左区间的右边界上</li>
<li>当终止条件<code>l==r</code>时，r右边的区域为&gt;target，l为&lt;=target的区域的右边界。</li>
</ol>
<h4 id="一个其他版本的查找右侧边界代码"><a class="markdownIt-Anchor" href="#一个其他版本的查找右侧边界代码"></a> 一个其他版本的查找右侧边界代码</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line">    <span class="type">int</span> mid = l+ (r-l&gt;&gt;<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(mid&gt;target) r = mid;</span><br><span class="line">    <span class="keyword">else</span> l = mid+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> l<span class="number">-1</span>;</span><br></pre></td></tr></table></figure>
<p>其实就是<mark>查找 &gt;target的左边界</mark>  版本，返回left-1即<mark>为&lt;=tareget的右边界</mark></p>
<h3 id="查找target的左边界"><a class="markdownIt-Anchor" href="#查找target的左边界"></a> 查找&gt;=target的左边界</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line">    <span class="type">int</span> mid = l+(r-l)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(mid&gt;=target)r = mid;</span><br><span class="line">    <span class="keyword">else</span> l = mid+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> l;</span><br></pre></td></tr></table></figure>
<ol>
<li>收缩区间，查找左边界指在&gt;=target的区间中取最小的一个，即&lt;target的区间舍去，<code>l = mid+1</code>，每次搜索的区间是[left,right)</li>
<li>因为mid = l+(r-l&gt;&gt;1)总是落在(l+r)/2的左侧，<code>r = mid</code>可以保证<code>r</code>始终落在右区间的左边界上</li>
<li>当终止条件<code>l==r</code>时，l左侧的部分全部为&lt;target，r为&lt;=target的区域的右边界</li>
</ol>
<h3 id="题目"><a class="markdownIt-Anchor" href="#题目"></a> 题目</h3>
<h4 id="搜索旋转排序数组"><a class="markdownIt-Anchor" href="#搜索旋转排序数组"></a> <a href="https://leetcode-cn.com/problems/search-in-rotated-sorted-array/">搜索旋转排序数组</a></h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">search</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> l  = <span class="number">0</span>,r = nums.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;=r)&#123;</span><br><span class="line">            <span class="type">int</span> mid = l+(r-l&gt;&gt;<span class="number">1</span>);</span><br><span class="line">            <span class="type">int</span> num = nums[mid],numl = nums[l],numr = nums[r];</span><br><span class="line">            <span class="keyword">if</span>(num==target)<span class="keyword">return</span> mid;</span><br><span class="line">            <span class="keyword">if</span>(numl&lt;=num)&#123; <span class="comment">//左边有序</span></span><br><span class="line">                <span class="keyword">if</span>(target&lt;num &amp;&amp; target&gt;=numl)r = mid<span class="number">-1</span>; <span class="comment">//在左边</span></span><br><span class="line">                <span class="keyword">else</span> l = mid+<span class="number">1</span>; <span class="comment">//在右边</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123; <span class="comment">//右边有序</span></span><br><span class="line">                <span class="keyword">if</span>(target&gt;num &amp;&amp; target&lt;=numr ) l = mid+<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> r = mid<span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="寻找峰值"><a class="markdownIt-Anchor" href="#寻找峰值"></a> <a href="https://leetcode-cn.com/problems/find-peak-element/">寻找峰值</a></h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findPeakElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> l = <span class="number">0</span>,r = nums.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line">            <span class="type">int</span> mid = l + (r-l&gt;&gt;<span class="number">1</span>);</span><br><span class="line">            <span class="type">int</span> prev,next;</span><br><span class="line">            <span class="keyword">if</span>(mid<span class="number">-1</span>&gt;=<span class="number">0</span>)prev = nums[mid<span class="number">-1</span>];<span class="keyword">else</span> prev = INT_MIN;</span><br><span class="line">            <span class="keyword">if</span>(mid+<span class="number">1</span>&lt;=nums.<span class="built_in">size</span>()<span class="number">-1</span>)next = nums[mid+<span class="number">1</span>];<span class="keyword">else</span> next = INT_MIN;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid]&gt;prev&amp;&amp;nums[mid]&gt;next)<span class="keyword">return</span> mid;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid]&gt;=prev) l = mid+<span class="number">1</span>; <span class="keyword">else</span> r = mid<span class="number">-1</span>; <span class="comment">//等号给INT_MIN 上坡必有顶</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="在排序数组中查找元素的第一个和最后一个位置"><a class="markdownIt-Anchor" href="#在排序数组中查找元素的第一个和最后一个位置"></a> <a href="https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/">在排序数组中查找元素的第一个和最后一个位置</a></h4>
<p>lower_bound(start,end,target) 返回&gt;=target的第一个位置地址</p>
<p>upper_bound(start,end,target) 返回&gt;target的第一个位置地址</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">searchRange</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//第一种方法使用双二分法，注意边界</span></span><br><span class="line">        <span class="type">int</span> l = <span class="number">0</span>, r = nums.<span class="built_in">size</span>()<span class="number">-1</span>;<span class="type">int</span> left=<span class="number">-1</span>,right = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;r)&#123; <span class="comment">//&gt;=target的左边界</span></span><br><span class="line">            <span class="type">int</span> mid = l+(r-l&gt;&gt;<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span>(nums[mid]&gt;=target)r = mid;<span class="keyword">else</span> l = mid+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(nums.<span class="built_in">size</span>()&gt;<span class="number">0</span>) <span class="keyword">if</span>( nums[l]!=target)left = <span class="number">-1</span>;<span class="keyword">else</span> left=l;</span><br><span class="line">        l =<span class="number">0</span>;r = nums.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;r)&#123;<span class="comment">//&lt;=target的右边界</span></span><br><span class="line">            <span class="type">int</span> mid = l+(r-l&gt;&gt;<span class="number">1</span>)+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid]&lt;=target)l = mid;<span class="keyword">else</span> r = mid<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(nums.<span class="built_in">size</span>()&gt;<span class="number">0</span> )<span class="keyword">if</span>(nums[l]!=target)right = <span class="number">-1</span>;<span class="keyword">else</span> right=l;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt;res; res.<span class="built_in">push_back</span>(left);res.<span class="built_in">push_back</span>(right);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//第二种方法使用STL，注意边界</span></span><br><span class="line">        left = <span class="built_in">lower_bound</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>(),target)-nums.<span class="built_in">begin</span>();</span><br><span class="line">        right = <span class="built_in">upper_bound</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>(),target)-nums.<span class="built_in">begin</span>()<span class="number">-1</span>;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt;res2;</span><br><span class="line">        <span class="keyword">if</span>(nums.<span class="built_in">size</span>()&gt;<span class="number">0</span> &amp;&amp; left&gt;=<span class="number">0</span> &amp;&amp;left &lt;nums.<span class="built_in">size</span>() &amp;&amp; nums[left]==target)res2.<span class="built_in">push_back</span>(left);<span class="keyword">else</span> res2.<span class="built_in">push_back</span>(<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">if</span>(nums.<span class="built_in">size</span>()&gt;<span class="number">0</span> &amp;&amp; right &gt;=<span class="number">0</span> &amp;&amp; right &lt; nums.<span class="built_in">size</span>() &amp;&amp;nums[right]==target)res2.<span class="built_in">push_back</span>(right);<span class="keyword">else</span> res2.<span class="built_in">push_back</span>(<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">return</span> res2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="找到-k-个最接近的元素"><a class="markdownIt-Anchor" href="#找到-k-个最接近的元素"></a> <a href="https://leetcode-cn.com/problems/find-k-closest-elements/">找到 K 个最接近的元素</a></h4>
<h4 id="方法一二分查找双指针"><a class="markdownIt-Anchor" href="#方法一二分查找双指针"></a> 方法一：二分查找+双指针</h4>
<p>首先找到&lt;=target的右边界，确定pos之后</p>
<p>令left=pos-k,right=pos+k，则我们需要的数字必定在这里面。分成三类讨论</p>
<ol>
<li>left&lt;0 left++</li>
<li>right&gt;=arr.size() right–;</li>
<li>在数组范围内，判断x与arr[left]和arr[right]的距离，left近就right–否则left++</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">findClosestElements</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr, <span class="type">int</span> k, <span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> l = <span class="number">0</span>,r = arr.<span class="built_in">size</span>()<span class="number">-1</span>;<span class="type">int</span> pos;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;r)&#123;<span class="comment">//&lt;=target 的右边界</span></span><br><span class="line">            <span class="type">int</span> mid = l+(r-l&gt;&gt;<span class="number">1</span>)+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(arr[mid]&lt;=x)l=mid;<span class="keyword">else</span> r=mid<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        pos = l;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt;res;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> left = pos-k,right=pos+k;</span><br><span class="line">        <span class="keyword">while</span>(right-left+<span class="number">1</span>&gt;k)&#123;</span><br><span class="line">            <span class="keyword">if</span>(left&lt;<span class="number">0</span>)&#123;left++;<span class="keyword">continue</span>;&#125;</span><br><span class="line">            <span class="keyword">if</span>(right&gt;=arr.<span class="built_in">size</span>())&#123;right--;<span class="keyword">continue</span>;&#125;</span><br><span class="line">            <span class="keyword">if</span>(arr[right]-x&gt;=x-arr[left])right--;<span class="keyword">else</span> left++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=left;i&lt;=right;i++)res.<span class="built_in">push_back</span>(arr[i]);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="方法二排序"><a class="markdownIt-Anchor" href="#方法二排序"></a> 方法二：排序</h4>
<p>将所有的数字和x的差值进行排序，取前k个。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//static int target;</span></span><br><span class="line">    <span class="comment">//static bool cmp(int &amp; a,int &amp; b)&#123;</span></span><br><span class="line">        <span class="comment">//if(abs(a-target)==abs(b-target))return a&lt;b;else return abs(a-target)&lt;abs(b-target);</span></span><br><span class="line">    <span class="comment">//&#125;</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">findClosestElements</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr, <span class="type">int</span> k, <span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(arr.<span class="built_in">begin</span>(),arr.<span class="built_in">end</span>(),[&amp;x](<span class="type">int</span> &amp;a,<span class="type">int</span> &amp;b)-&gt; <span class="type">bool</span>&#123;<span class="keyword">if</span>(<span class="built_in">abs</span>(a-x)==<span class="built_in">abs</span>(b-x))<span class="keyword">return</span> a&lt;b; <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">abs</span>(a-x)&lt;<span class="built_in">abs</span>(b-x);&#125;);     <span class="comment">//函数式编程，省去了引用static变量和初始化的过程</span></span><br><span class="line">        <span class="comment">//this-&gt;target = x;</span></span><br><span class="line">        <span class="comment">//sort(arr.begin(),arr.end(),cmp);</span></span><br><span class="line">        vector&lt;<span class="type">int</span>&gt;res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;k;i++)res.<span class="built_in">emplace_back</span>(arr[i]);</span><br><span class="line">        <span class="built_in">sort</span>(res.<span class="built_in">begin</span>(),res.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//int Solution::target = 0; //类型 所在类：：静态变量名 = 初始化值。</span></span><br></pre></td></tr></table></figure>
<h3 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h3>
<p><a href="https://www.cnblogs.com/kyoner/p/11080078.html">https://www.cnblogs.com/kyoner/p/11080078.html</a></p>
<p>《蓝书》P26</p>
]]></content>
      <categories>
        <category>算法</category>
        <category>基础算法</category>
      </categories>
      <tags>
        <tag>基础算法</tag>
        <tag>encryptalg</tag>
      </tags>
  </entry>
  <entry>
    <title>cpp博客汇总</title>
    <url>/posts/26f80d45/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">
  <script id="hbeData" type="hbeData" data-hmacdigest="2ad428ac34b9d30537e31d1e6ea1063a6cb32c94d1652167623c37725a469867">8c5eb7d299eb8204d1aa11d5321f1970e0702a4fa338dd1cc8a5f32ab3a638a5dfe317204ae956e092fc50bb1621e8ea08b755118da87b6340cee979b850f15388d6b14e6dbb75303be94c0ae2e6ad263861a013083448150d2196193e2ba07b</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-blink">
      <input class="hbe hbe-input-field hbe-input-field-blink" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-blink" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-blink" data-content="您好, 这里需要密码.">您好, 这里需要密码.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>cpp</category>
        <category>cpp资源</category>
      </categories>
      <tags>
        <tag>cpp资源</tag>
      </tags>
  </entry>
</search>
