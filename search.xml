<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>hexo setups</title>
    <url>/posts/b763a0b1/</url>
    <content><![CDATA[<h3 id="centos-关闭selinux及防火墙"><a class="markdownIt-Anchor" href="#centos-关闭selinux及防火墙"></a> centos 关闭SELINUX及防火墙</h3>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$ </span><span class="language-bash">setenforce 0</span></span><br><span class="line"><span class="meta">$ </span><span class="language-bash">sed -i <span class="string">&#x27;s/SELINUX=enforcing/SELINUX=disabled/&#x27;</span> /etc/selinux/config</span></span><br><span class="line"><span class="meta">$ </span><span class="language-bash">systemctl <span class="built_in">disable</span> firewalld &amp;&amp; systemctl stop firewalld</span></span><br></pre></td></tr></table></figure>
<h3 id="创建tags-caterories"><a class="markdownIt-Anchor" href="#创建tags-caterories"></a> 创建tags、caterories</h3>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$ </span><span class="language-bash">hexo new page <span class="string">&quot;tags&quot;</span></span></span><br></pre></td></tr></table></figure>
<p>修改source/tags/index.md</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">tags</span></span><br><span class="line"><span class="attr">date:</span> <span class="number">2017-07-10 16:36:26</span></span><br><span class="line"><span class="attr">type:</span> <span class="string">&quot;tags&quot;</span></span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></table></figure>
<p>修改themes/next/_config.yml</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">menu:</span></span><br><span class="line"><span class="attr">home:</span> <span class="string">/</span></span><br><span class="line"><span class="attr">archives:</span> <span class="string">/archives/</span></span><br><span class="line"><span class="attr">categories:</span> <span class="string">/categories/</span></span><br><span class="line"><span class="attr">tags:</span> <span class="string">/tags/</span></span><br></pre></td></tr></table></figure>
<p>tags 不存在多级,cat可以多级</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">categories:</span><br><span class="line">- [Sports, Baseball]</span><br><span class="line">- Baseball</span><br><span class="line">tags:</span><br><span class="line">- Injury</span><br><span class="line">- Fight</span><br><span class="line">- Shocking</span><br></pre></td></tr></table></figure>
<p>使用katex</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$ </span><span class="language-bash">npm un hexo-renderer-marked</span></span><br><span class="line"><span class="meta">$ </span><span class="language-bash">npm i hexo-renderer-markdown-it-plus</span></span><br></pre></td></tr></table></figure>
<h3 id="修改自定义样式"><a class="markdownIt-Anchor" href="#修改自定义样式"></a> 修改自定义样式</h3>
<p><code>css/_common/outline/footer/index.styl</code></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.footer-inner</span> &gt; <span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">padding-left</span>: <span class="number">8px</span>;</span><br><span class="line">  <span class="attribute">padding-right</span>: <span class="number">8px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="博客加密"><a class="markdownIt-Anchor" href="#博客加密"></a> 博客加密</h3>
<p><a href="https://github.com/D0n9X1n/hexo-blog-encrypt/blob/master/ReadMe.zh.md">https://github.com/D0n9X1n/hexo-blog-encrypt/blob/master/ReadMe.zh.md</a></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$ </span><span class="language-bash">npm install --save hexo-blog-encrypt</span></span><br></pre></td></tr></table></figure>
<h4 id="对博文加密"><a class="markdownIt-Anchor" href="#对博文加密"></a> 对博文加密</h4>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">Hello</span> <span class="string">World</span></span><br><span class="line"><span class="attr">tags:</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">作为日记加密</span></span><br><span class="line"><span class="attr">date:</span> <span class="number">2016-03-30 21:12:21</span></span><br><span class="line"><span class="attr">password:</span> <span class="string">mikemessi</span></span><br><span class="line"><span class="attr">abstract:</span> <span class="string">有东西被加密了,</span> <span class="string">请输入密码查看.</span></span><br><span class="line"><span class="attr">message:</span> <span class="string">您好,</span> <span class="string">这里需要密码.</span></span><br><span class="line"><span class="attr">wrong_pass_message:</span> <span class="string">抱歉,</span> <span class="string">这个密码看着不太对,</span> <span class="string">请再试试.</span></span><br><span class="line"><span class="attr">wrong_hash_message:</span> <span class="string">抱歉,</span> <span class="string">这个文章不能被校验,</span> <span class="string">不过您还是能看看解密后的内容.</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="meta"></span></span><br></pre></td></tr></table></figure>
<h4 id="对tag加密"><a class="markdownIt-Anchor" href="#对tag加密"></a> 对tag加密</h4>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># Security</span></span><br><span class="line"><span class="attr">encrypt:</span> <span class="comment"># hexo-blog-encrypt</span></span><br><span class="line">  <span class="attr">abstract:</span> <span class="string">有东西被加密了,</span> <span class="string">请输入密码查看.</span></span><br><span class="line">  <span class="attr">message:</span> <span class="string">您好,</span> <span class="string">这里需要密码.</span></span><br><span class="line">  <span class="attr">tags:</span></span><br><span class="line">  <span class="bullet">-</span> &#123;<span class="attr">name:</span> <span class="string">tagName</span>, <span class="attr">password:</span> <span class="string">密码A</span>&#125;</span><br><span class="line">  <span class="bullet">-</span> &#123;<span class="attr">name:</span> <span class="string">tagName</span>, <span class="attr">password:</span> <span class="string">密码B</span>&#125;</span><br><span class="line">  <span class="attr">wrong_pass_message:</span> <span class="string">抱歉,</span> <span class="string">这个密码看着不太对,</span> <span class="string">请再试试.</span></span><br><span class="line">  <span class="attr">wrong_hash_message:</span> <span class="string">抱歉,</span> <span class="string">这个文章不能被校验,</span> <span class="string">不过您还是能看看解密后的内容.</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><a href="https://theme-next.js.org/docs/theme-settings/">https://theme-next.js.org/docs/theme-settings/</a></p>
<p><code>zhumeng2021.2\node_modules\hexo-theme-next\layout\_macro\sidebar.njk</code> 对sidebar修改</p>
<p><code>zhumeng2021.2\node_modules\hexo-theme-next\layout\_partials\post\post-related.njk</code>对related修改</p>
<p><code>C:\Users\42273\Desktop\hexo_blog\zhumeng2021.2\.deploy_git\js\schemes\muse.js</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (event.<span class="property">target</span>.<span class="title function_">matches</span>(<span class="string">&#x27;img.medium-zoom-image&#x27;</span>)) &#123;<span class="comment">// 删去clickingBlankPart||</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">hideSidebar</span>();</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>
<hr />
<p>TODO:</p>
<ol>
<li>
<h4 id="configuring-favicon"><a class="markdownIt-Anchor" href="#configuring-favicon"></a> Configuring Favicon</h4>
</li>
</ol>
]]></content>
      <categories>
        <category>环境搭建</category>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>面经</title>
    <url>/posts/98e6f621/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">
  <script id="hbeData" type="hbeData" data-hmacdigest="4c5582a6b7c5da8f706f0b2529e2c252377cb5dc55ea771f6102d0f793eda5a5">8c5eb7d299eb8204d1aa11d5321f19709a60da0fde5d858f6efa5c0b10cf9aa646d1e0f14867aa9f78f43de519d2988ce99bbe5072edcd4adde9727a27e7fa68610ee1f30906b33fd1a7d1a9bece5326110be27a8ef748600603611e1c6fae239037baf7f6391627719794c3766a6debe252c0a5fc85f18f7e9c6069f53a59159ba08f79f4c503d4b8fcb3d1aae28047f594dda015734bacc12b82321455dfa7990e8ea56f67692246524ceee2047e96b3e8db152c123b0b56c706316fd8485d7c2a843957757db9a2b3a5d43435a3e8d282f54bca3a1360af1cc511bf74d24c0f74656def08b5c84bd4ab5008ac10441ba19dfbc48ffb5ad51384c5c436a5f6125f33172aeb154818d1ff348d05ca0b177878ddb19968ffcd0533f66b55aae34248698c61087205a914874a0e94cc6bdb76a54585d83c67e8a7a4bc3a2ceef4864f202e69c3a82e104d51396644e4c3b2e2bbc1c4e130f2ff0ac1c41727b6d39a9feb068e9d9d261812d5317bd991358ec417ff10e8205bbed86bad422873263902f07fe8b393c0d2ffa0aeb0cbbfae</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-blink">
      <input class="hbe hbe-input-field hbe-input-field-blink" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-blink" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-blink" data-content="您好, 这里需要密码.">您好, 这里需要密码.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
  </entry>
  <entry>
    <title>Lambda表达式</title>
    <url>/posts/e9ee750c/</url>
    <content><![CDATA[<h3 id="声明lambda表达式"><a class="markdownIt-Anchor" href="#声明lambda表达式"></a> 声明Lambda表达式</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">[capture list] (params list) <span class="keyword">mutable</span> exception-&gt; <span class="keyword">return</span> type &#123; function body &#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>capture list： 捕获外部变量的列表</li>
<li>params list：形参列表</li>
<li>mutable指示符：是否可以修改捕获的变量</li>
<li>exception：异常设定</li>
<li>return type：返回类型</li>
<li>function body：函数体</li>
</ol>
<h4 id="格式1"><a class="markdownIt-Anchor" href="#格式1"></a> 格式1</h4>
<p>声明了const类型的表达式，函数中不能修改捕获列表中的值（引用传递除外）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">[capture list] (params list) -&gt; <span class="keyword">return</span> type &#123; function body &#125;</span><br></pre></td></tr></table></figure>
<h4 id="格式2"><a class="markdownIt-Anchor" href="#格式2"></a> 格式2</h4>
<p>省略了返回值的类型，编译器自动推断，若：</p>
<ol>
<li>
<p>含有return，则类型由return决定</p>
</li>
<li>
<p>不含有return，类型为void</p>
</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">[capture list] (params list)  &#123; function body &#125;</span><br></pre></td></tr></table></figure>
<h4 id="格式3"><a class="markdownIt-Anchor" href="#格式3"></a> 格式3</h4>
<p>无参数函数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">[capture list] &#123; function body &#125;</span><br></pre></td></tr></table></figure>
<h3 id="捕获外部变量"><a class="markdownIt-Anchor" href="#捕获外部变量"></a> 捕获外部变量</h3>
<table>
<thead>
<tr>
<th>捕获形式</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>[]</td>
<td>不捕获任何外部变量</td>
</tr>
<tr>
<td>[变量名…]</td>
<td>默认以值形式捕获多个指定外部变量，如果引用捕获，需要显式声明<code>&amp;</code>说明符</td>
</tr>
<tr>
<td>[this]</td>
<td>值形式捕获this指针</td>
</tr>
<tr>
<td>[=]</td>
<td>值形式捕获外部所有变量</td>
</tr>
<tr>
<td>[&amp;]</td>
<td>引用方式捕获外部所有变量</td>
</tr>
<tr>
<td>[=,&amp;x]</td>
<td>变量x用引用方式捕获，其余变量以传值形式捕获</td>
</tr>
<tr>
<td>[&amp;,x]</td>
<td>变量x以传值方式捕获，其余变量以引用形式捕获</td>
</tr>
</tbody>
</table>
<h3 id="lambda表达式的参数"><a class="markdownIt-Anchor" href="#lambda表达式的参数"></a> Lambda表达式的参数</h3>
<ol>
<li>参数列表中不能用默认参数</li>
<li>不支持可变长度的参数</li>
<li>所有参数必须有参数名</li>
</ol>
<h3 id="lambda表达式的类型"><a class="markdownIt-Anchor" href="#lambda表达式的类型"></a> Lambda表达式的类型</h3>
<p>Lambda 函数是一个依赖于实现的函数对象类型,这个类型的名字只有编译器知道. 如果用户想把 lambda 函数做为一个参数来传递, 那么形参的类型必须是模板类型或者必须能创建一个 <mark>std::function</mark> 类似的对象去捕获 lambda 函数.使用 auto 关键字可以帮助存储 Lambda 函数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> my_lambda_func = [&amp;](<span class="type">int</span> x) &#123; <span class="comment">/* ... */</span> &#125;;</span><br><span class="line"><span class="keyword">auto</span> my_onheap_lambda_func = <span class="keyword">new</span> <span class="built_in">auto</span>([=](<span class="type">int</span> x) &#123; <span class="comment">/* ... */</span> &#125;);</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">double</span> <span class="title">eval</span><span class="params">(std::function&lt;<span class="type">double</span>(<span class="type">double</span>)&gt; f,<span class="type">double</span> x=<span class="number">2.0</span>)</span></span>&#123;<span class="keyword">return</span> <span class="built_in">f</span>(x);&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	std::function&lt;<span class="type">double</span>(<span class="type">double</span>)&gt; f0 = [](<span class="type">double</span> x)&#123;<span class="keyword">return</span> <span class="number">1</span>;&#125;;</span><br><span class="line">    <span class="keyword">auto</span> f1 = [](<span class="type">double</span> x)&#123;<span class="keyword">return</span> x;&#125;;</span><br><span class="line">    <span class="keyword">decltype</span>(f0) fa[<span class="number">3</span>]=&#123;f0,f1,[](<span class="type">double</span> x)&#123;<span class="keyword">return</span> x*x;&#125;&#125;;</span><br><span class="line">    std::vector&lt;std::function&lt;<span class="type">double</span>(<span class="type">double</span>)&gt; &gt; fv = &#123;f0,f1&#125;;</span><br><span class="line">    fv.<span class="built_in">push_back</span>([](<span class="type">double</span> x)&#123;<span class="keyword">return</span> x*x;&#125;);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;fv.<span class="built_in">size</span>();i++) std::cout&lt;&lt;fv[i](<span class="number">2.0</span>)&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一个没有指定任何捕获的 lambda 函数,可以显式转换成一个具有相同声明形式函数指针.所以,像下面这样做是合法的:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> a_lambda_func = [](<span class="type">int</span> x) &#123; <span class="comment">/* ... */</span> &#125;;</span><br><span class="line"><span class="built_in">void</span> (*func_ptr)(<span class="type">int</span>) = a_lambda_func;</span><br><span class="line"><span class="built_in">func_ptr</span>(<span class="number">4</span>); <span class="comment">// calls the lambda</span></span><br></pre></td></tr></table></figure>
<p>但是<mark>带捕获的lambda是不能够作为函数指针进行参数传递</mark>。</p>
<h3 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h3>
<p><a href="https://www.cnblogs.com/DswCnblog/p/5629165.html">https://www.cnblogs.com/DswCnblog/p/5629165.html</a></p>
<p><a href="https://www.cnblogs.com/jimodetiantang/p/9016826.html">https://www.cnblogs.com/jimodetiantang/p/9016826.html</a></p>
<p>关于捕获和不捕获的lambda转换汇编代码分析</p>
<p><a href="https://blog.csdn.net/qq_36419971/article/details/117396419">https://blog.csdn.net/qq_36419971/article/details/117396419</a></p>
]]></content>
      <categories>
        <category>cpp</category>
        <category>cpp语法</category>
      </categories>
      <tags>
        <tag>cpp语法</tag>
      </tags>
  </entry>
  <entry>
    <title>unordered_map set自定义对象的hash</title>
    <url>/posts/f17b9616/</url>
    <content><![CDATA[<p><code>unordered_map/set</code>使用hash进行存储，因此存储自定义对象前，必须：</p>
<ol>
<li><code>hash</code>告知此容器如何生成hash值，</li>
<li><code>equal_to</code>告知容器当出现hash冲突时，如何区分hash值相同的不同对象。</li>
</ol>
<p><strong>具体有4种方案</strong>：</p>
<ol>
<li>定义两个函数对象ObjectHash，以及ObjectCmp，分别实现对Object进行hash，以及比较两个对象是否相同。</li>
<li>定义两个普通的函数，实现hash以及对象比较，与<mark>1</mark>不同的是普通函数在构建<code>unordered_map/set</code>时，需要decltype来减少声明它的类型（或手动指定，<code>std::function &lt;size_t(const Object&amp;)&gt;</code>说明hash类型，<code>std::function &lt;bool(const Object&amp;, const Object&amp;)&gt;</code>说明比较cmp类型</li>
<li>定义两个lambda表达式（仿函数），与2类似</li>
<li>对Object对象进行模板特化定制</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"># unordered_set的声明</span><br><span class="line"><span class="keyword">template</span>&lt;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Key</span>, <span class="comment">//类型</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Hash</span> = std::hash&lt;Key&gt;,</span><br><span class="line">    <span class="keyword">class</span> KeyEqual = std::equal_to&lt;Key&gt;,</span><br><span class="line">    <span class="keyword">class</span> Allocator = std::allocator&lt;Key&gt;</span><br><span class="line">&gt; <span class="keyword">class</span> unordered_set;</span><br><span class="line"></span><br><span class="line">#unordered_map的声明</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">Key</span>, <span class="comment">//key的类型</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Ty</span>, <span class="comment">//val的类型</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Hash</span> = std::hash&lt;Key&gt;,</span><br><span class="line">    <span class="keyword">class</span> Pred = std::equal_to&lt;Key&gt;,</span><br><span class="line">    <span class="keyword">class</span> Alloc = std::allocator&lt;std::pair&lt;<span class="type">const</span> Key, Ty&gt; &gt; &gt;</span><br><span class="line">    <span class="keyword">class</span> unordered_map;</span><br><span class="line">&gt; <span class="keyword">class</span> <span class="title class_">unordered_map</span></span><br></pre></td></tr></table></figure>
<h3 id="示例"><a class="markdownIt-Anchor" href="#示例"></a> 示例</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"># 自定义<span class="keyword">struct</span>的类型</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Object</span>&#123;</span><br><span class="line">    string name;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="定义两个函数对象"><a class="markdownIt-Anchor" href="#定义两个函数对象"></a> 定义两个函数对象</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ObjectHash</span>&#123;</span><br><span class="line">	<span class="function"><span class="type">size_t</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> Object&amp; rhs)</span><span class="type">const</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">hash</span>&lt;string&gt;()(rhs.name) ^ <span class="built_in">hash</span>&lt;<span class="type">int</span>&gt;()(rhs.val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ObjectCmp</span>&#123;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> Object&amp; lhs,<span class="type">const</span> Object&amp; rhs)</span><span class="type">const</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> lhs.name == rhs.name &amp;&amp; lhs.val ==rhs.val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">unordered_set&lt;Object,ObjectHash,ObjectCmp&gt; objects;</span><br></pre></td></tr></table></figure>
<h4 id="定义两个普通函数重写hash和cmp"><a class="markdownIt-Anchor" href="#定义两个普通函数重写hash和cmp"></a> 定义两个普通函数，重写hash和cmp</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">ObjectHash</span><span class="params">(<span class="type">const</span> Object&amp; rhs)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">hash</span>&lt;string&gt;()(rhs.name) ^ <span class="built_in">hash</span>&lt;<span class="type">int</span>&gt;()(rhs.val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ObjectCmp</span><span class="params">(<span class="type">const</span> Object&amp; lhs, <span class="type">const</span> Record&amp; rhs)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> lhs.name == rhs.name &amp;&amp; lhs.val == rhs.val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">unordered_set&lt;Object , <span class="title">decltype</span><span class="params">(&amp;ObjectHash)</span>, <span class="title">decltype</span><span class="params">(&amp;ObjectCmp)</span>&gt; <span class="title">objects</span><span class="params">(<span class="number">0</span>,ObjectHash,ObjectCmp)</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="使用lambda函数"><a class="markdownIt-Anchor" href="#使用lambda函数"></a> 使用lambda函数</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> ObjectHash = [](<span class="type">const</span> Object&amp; rhs)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">hash</span>&lt;string&gt;(rhs.name) ^ <span class="built_in">hash</span>&lt;<span class="type">int</span>&gt;()(rhs.val);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> ObjectCmp = [](<span class="type">const</span> Object&amp; lhs, <span class="type">const</span> Object&amp; rhs)&#123;</span><br><span class="line">    <span class="keyword">return</span> lhs.name==rhs.name &amp;&amp; lhs.val==rhs.val;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">unordered_set&lt;Object, <span class="keyword">decltype</span>(&amp;ObjectHash),<span class="keyword">decltype</span>(&amp;ObjectCmp)&gt;<span class="built_in">object</span>(<span class="number">0</span>,ObjectHash,ObjectCmp);</span><br></pre></td></tr></table></figure>
<h4 id="模板定制重写"><a class="markdownIt-Anchor" href="#模板定制重写"></a> 模板定制重写</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//注意namespace ，必要时可以指定namespace std&#123;&#125;</span></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">hash</span>&lt;Object&gt;&#123;</span><br><span class="line">    <span class="function"><span class="type">size_t</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> Object&amp; rhs)</span><span class="type">const</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">hash</span>&lt;string&gt;()(rhs.name) ^ <span class="built_in">hash</span>&lt;<span class="type">int</span>&gt;()(rhs.val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">equal_to</span>&lt;Object&gt;&#123;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> Object&amp; lhs,<span class="type">const</span> Object&amp; rhs)</span><span class="type">const</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> lhs.name == rhs.name &amp;&amp; lhs.val == rhs.val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">unordered_set&lt;Object&gt; objects;</span><br></pre></td></tr></table></figure>
<h3 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h3>
<p><a href="https://blog.csdn.net/lpstudy/article/details/54345050">https://blog.csdn.net/lpstudy/article/details/54345050</a></p>
<p><a href="https://blog.csdn.net/y109y/article/details/82669620">https://blog.csdn.net/y109y/article/details/82669620</a></p>
]]></content>
      <categories>
        <category>cpp</category>
        <category>cpp语法</category>
      </categories>
      <tags>
        <tag>cpp语法</tag>
      </tags>
  </entry>
  <entry>
    <title>test_code</title>
    <url>/posts/726c1a57/</url>
    <content><![CDATA[<h2 id="三维dp"><a class="markdownIt-Anchor" href="#三维dp"></a> 三维dp</h2>
<h3 id="dqwdwq"><a class="markdownIt-Anchor" href="#dqwdwq"></a> dqwdwq</h3>
<p><mark>dwqd</mark><br />
<img data-src="http://hz-picbed-xxh.oss-cn-hangzhou.aliyuncs.com/img-bed/3-1Q113131610L7.gif" alt="顾客购物程序的类图" /></p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msubsup><mo>∑</mo><mi>x</mi><mrow><mi>s</mi><mi>d</mi></mrow></msubsup><mfrac><mrow><mfrac><mi>a</mi><mi>b</mi></mfrac><mo>+</mo><mi>a</mi></mrow><mi>α</mi></mfrac></mrow><annotation encoding="application/x-tex">\sum_{x}^{sd}{\frac{a}{b}+{a}\over{\alpha}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.37988em;vertical-align:-0.345em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9890079999999999em;"><span style="top:-2.40029em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">x</span></span></span></span><span style="top:-3.2029em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">s</span><span class="mord mathdefault mtight">d</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.29971000000000003em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.03488em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.0037em;">α</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.5508em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mopen nulldelimiter sizing reset-size3 size6"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.6915428571428572em;"><span style="top:-2.656em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">b</span></span></span></span><span style="top:-3.2255000000000003em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line mtight" style="border-bottom-width:0.049em;"></span></span><span style="top:-3.384em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">a</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.344em;"><span></span></span></span></span></span><span class="mclose nulldelimiter sizing reset-size3 size6"></span></span><span class="mbin mtight">+</span><span class="mord mtight"><span class="mord mathdefault mtight">a</span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p>
<a id="more"></a>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mo>∗</mo><msup><mi>b</mi><mn>2</mn></msup><mspace width="1em"/><mo stretchy="false">(</mo><mi>b</mi><mi>ω</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">a*b^2 \quad (b \omega)
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.46528em;vertical-align:0em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.1141079999999999em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:1em;"></span><span class="mopen">(</span><span class="mord mathdefault">b</span><span class="mord mathdefault" style="margin-right:0.03588em;">ω</span><span class="mclose">)</span></span></span></span></span></p>
<p><code>dwqdnjk</code><br />
<code>test for ms code</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @Descripttion: 111 https://leetcode.com/discuss/interview-question/1488563/microsoft-on-campus-2021-india</span></span><br><span class="line"><span class="comment"> * @version: </span></span><br><span class="line"><span class="comment"> * @Author: xxh</span></span><br><span class="line"><span class="comment"> * @Date: 2022-01-23</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;dp;</span><br><span class="line"><span class="type">int</span> dd[<span class="number">100</span>][<span class="number">2</span>][<span class="number">200</span>]=&#123;<span class="number">-1</span>&#125; ;<span class="comment">//pos - -x/y - value</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; h,<span class="type">int</span> pos,<span class="type">int</span> rx,<span class="type">int</span> ry,<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pos&gt;=n) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(dp[pos][<span class="built_in">abs</span>(rx-ry)]!=<span class="number">-1</span>)<span class="keyword">return</span> dp[pos][<span class="built_in">abs</span>(rx-ry)];</span><br><span class="line">    <span class="type">int</span> v1=<span class="number">0</span>,v2=<span class="number">0</span>,v3=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(rx&gt;=h[pos])v1 = <span class="number">1</span>+<span class="built_in">dfs</span>(h,pos+<span class="number">1</span>,rx-h[pos],ry,n);</span><br><span class="line">    <span class="keyword">if</span>(ry&gt;=h[pos]) v2 = <span class="number">1</span>+<span class="built_in">dfs</span>(h,pos+<span class="number">1</span>,rx,ry-h[pos],n);</span><br><span class="line">    v3=<span class="built_in">dfs</span>(h,pos+<span class="number">1</span>,rx,ry,n);</span><br><span class="line">    dp[pos][<span class="built_in">abs</span>(rx-ry)] = <span class="built_in">max</span>(v1,<span class="built_in">max</span>(v2,v3));</span><br><span class="line">    <span class="keyword">return</span> dp[pos][<span class="built_in">abs</span>(rx-ry)];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">f</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; h,<span class="type">int</span> pos,<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    dd[<span class="number">0</span>][<span class="number">0</span>][x]=dd[<span class="number">0</span>][<span class="number">1</span>][y]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = x;j&gt;=h[i<span class="number">-1</span>];j--) <span class="comment">//x</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k=y;k&gt;=<span class="number">0</span>;k--)&#123; <span class="comment">//y</span></span><br><span class="line">                <span class="keyword">if</span>(dd[i<span class="number">-1</span>][<span class="number">1</span>][k]!=<span class="number">-1</span>&amp;&amp;dd[i<span class="number">-1</span>][<span class="number">0</span>][j]!=<span class="number">-1</span>) &#123;</span><br><span class="line">                    dd[i][<span class="number">0</span>][j-h[i<span class="number">-1</span>]]= <span class="built_in">max</span>(dd[i<span class="number">-1</span>][<span class="number">1</span>][k]+dd[i<span class="number">-1</span>][<span class="number">0</span>][j]+<span class="number">1</span>,dd[i][<span class="number">0</span>][j-h[i<span class="number">-1</span>]]);</span><br><span class="line">                    cout&lt;&lt;i&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;j&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;dd[i][<span class="number">0</span>][j-h[i<span class="number">-1</span>]]&lt;&lt;endl;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = y;j&gt;=h[i<span class="number">-1</span>];j--)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k=x;k&gt;=<span class="number">0</span>;k--)&#123;</span><br><span class="line">                <span class="keyword">if</span>(dd[i<span class="number">-1</span>][<span class="number">0</span>][k]!=<span class="number">-1</span>&amp;&amp;dd[i<span class="number">-1</span>][<span class="number">1</span>][j]!=<span class="number">-1</span>) dd[i][<span class="number">1</span>][j-h[i<span class="number">-1</span>]] = <span class="built_in">max</span>(dd[i<span class="number">-1</span>][<span class="number">0</span>][k]+dd[i<span class="number">-1</span>][<span class="number">1</span>][j]+<span class="number">1</span>,dd[i][<span class="number">1</span>][j-h[i<span class="number">-1</span>]]);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mx =<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;<span class="number">100</span>;i++)&#123;</span><br><span class="line">        <span class="comment">//cout&lt;&lt;dd[n-1][0][i];</span></span><br><span class="line">        mx = <span class="built_in">max</span>(mx,dd[n<span class="number">-1</span>][<span class="number">0</span>][i]);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="type">int</span> my = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;<span class="number">100</span>;i++)&#123;</span><br><span class="line">        <span class="comment">//cout&lt;&lt;dd[n-1][1][i];</span></span><br><span class="line">        my = <span class="built_in">max</span>(my,dd[n<span class="number">-1</span>][<span class="number">1</span>][i]);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>(mx,my);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;h=&#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">4</span>&#125;;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">8</span>,y=<span class="number">9</span>;</span><br><span class="line">    <span class="type">int</span> n = h.<span class="built_in">size</span>();</span><br><span class="line">    dp.<span class="built_in">resize</span>(n,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="built_in">max</span>(x,y)+<span class="number">1</span>,<span class="number">-1</span>));</span><br><span class="line">    <span class="built_in">memset</span>(dd,<span class="number">0xff</span>,<span class="built_in">sizeof</span>(dd));</span><br><span class="line">    cout&lt;&lt;<span class="built_in">f</span>(h,<span class="number">0</span>,x,y,n);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>test</category>
        <category>面试题</category>
        <category>MS</category>
      </categories>
      <tags>
        <tag>test</tag>
        <tag>dp</tag>
        <tag>ms面试题</tag>
      </tags>
  </entry>
  <entry>
    <title>decltype关键字</title>
    <url>/posts/6d46b940/</url>
    <content><![CDATA[<h3 id="decltype关键字"><a class="markdownIt-Anchor" href="#decltype关键字"></a> decltype关键字</h3>
<p><mark>decltype</mark>被称作类型说明符，作用是选择并返回操作数的数据类型。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// sum类型就是函数f返回的类型</span></span><br><span class="line"><span class="keyword">decltype</span>(<span class="built_in">f</span>()) sum = x;</span><br></pre></td></tr></table></figure>
<p>解决难以拼写的类型名，有以下两个方案：</p>
<ol>
<li>使用类型别名技术</li>
<li>使用auto和decltype</li>
</ol>
<h3 id="工作原理"><a class="markdownIt-Anchor" href="#工作原理"></a> 工作原理</h3>
<p><mark>decltype</mark>不会计算表达式的值，编译器分析表达式并得到它的类型。</p>
<p>函数调用也算一种表达式，因此不必担心在使用deltype时执行了函数。</p>
<h3 id="decltype变量"><a class="markdownIt-Anchor" href="#decltype变量"></a> decltype+变量</h3>
<p>根据表达式的定义，单独使用一个变量，相当于一个最简单的表达式。</p>
]]></content>
      <categories>
        <category>cpp</category>
        <category>cpp语法</category>
      </categories>
      <tags>
        <tag>cpp语法</tag>
      </tags>
  </entry>
  <entry>
    <title>【每日】1020. 飞地的数量</title>
    <url>/posts/48f31485/</url>
    <content><![CDATA[<p><img data-src="http://hz-picbed-xxh.oss-cn-hangzhou.aliyuncs.com/img-bed/image-20220212141050874.png" alt="image-20220212141050874" /></p>
<blockquote>
<p>采用多源dfs的思想，每个通往边界的区域经过dfs后设为0，最后统计1的数量即可，只需要扫描边界处的连通分量即可。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> dir[<span class="number">4</span>][<span class="number">2</span>]=&#123;&#123;<span class="number">-1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">0</span>,<span class="number">-1</span>&#125;&#125;;</span><br><span class="line">    <span class="type">int</span> m,n;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; grid)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(grid[x][y]==<span class="number">0</span>)<span class="keyword">return</span>;</span><br><span class="line">        grid[x][y]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> i:dir)&#123;</span><br><span class="line">            <span class="type">int</span> nextx = x+i[<span class="number">0</span>],nexty = y+i[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span>(nextx&gt;=<span class="number">0</span> &amp;&amp; nexty&gt;=<span class="number">0</span> &amp;&amp; nextx&lt;m &amp;&amp; nexty &lt;n &amp;&amp;grid[nextx][nexty])<span class="built_in">dfs</span>(nextx,nexty,grid);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numEnclaves</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        m = grid.<span class="built_in">size</span>(); n = grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;<span class="built_in">dfs</span>(<span class="number">0</span>,j,grid);<span class="built_in">dfs</span>(m<span class="number">-1</span>,j,grid);&#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;<span class="built_in">dfs</span>(i,<span class="number">0</span>,grid);<span class="built_in">dfs</span>(i,n<span class="number">-1</span>,grid);&#125;</span><br><span class="line">        <span class="type">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> i:grid)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> j:i)<span class="keyword">if</span>(j)cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
        <category>力扣</category>
        <category>每日一题</category>
        <category>dfs</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>【每日】2055.蜡烛之间的盘子</title>
    <url>/posts/f2608f0/</url>
    <content><![CDATA[<p><img data-src="http://hz-picbed-xxh.oss-cn-hangzhou.aliyuncs.com/img-bed/image-20220308131742743.png" alt="image-20220308131742743" /></p>
<blockquote>
<p>思路一：使用二分查找的思想，记录蜡烛的位置存入cpos[]，然后对每次查询进行左二分和右二分，查找到&gt;=和&lt;=的pos位置 lpos和rpos，sum=cpos[rpos]-cpos[lpos]-(rpos-lpos)</p>
<p>复杂度O(nlogn)</p>
<p>注意特判边界条件和rpos&lt;=lpos的情况</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lbs</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp;a,<span class="type">int</span> pos)</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> l = <span class="number">0</span>,r = a.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line">            <span class="type">int</span> mid = l+(r-l&gt;&gt;<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span>(a[mid]&gt;=pos)r = mid;<span class="keyword">else</span> l= mid+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">rbs</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp;a,<span class="type">int</span> pos)</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> l=<span class="number">0</span>,r=a.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line">            <span class="type">int</span> mid = l+(r-l&gt;&gt;<span class="number">1</span>)+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(a[mid]&lt;=pos)l = mid;<span class="keyword">else</span> r = mid<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">platesBetweenCandles</span><span class="params">(string s, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; queries)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt;cpos; vector&lt;<span class="type">int</span>&gt;ans;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;s.<span class="built_in">size</span>();i++)<span class="keyword">if</span>(s[i]==<span class="string">&#x27;|&#x27;</span>)cpos.<span class="built_in">emplace_back</span>(i);</span><br><span class="line">        <span class="keyword">if</span>(cpos.<span class="built_in">empty</span>())<span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> i:queries)&#123;</span><br><span class="line">            <span class="type">int</span> lpos = <span class="built_in">lbs</span>(cpos,i[<span class="number">0</span>]),rpos = <span class="built_in">rbs</span>(cpos,i[<span class="number">1</span>]); </span><br><span class="line">            <span class="keyword">if</span>(cpos.<span class="built_in">front</span>()&gt;=cpos[rpos] || cpos.<span class="built_in">back</span>()&lt;=cpos[lpos] || rpos&lt;=lpos) ans.<span class="built_in">emplace_back</span>(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="type">int</span> cnt = cpos[rpos]-cpos[lpos] - (rpos - lpos);</span><br><span class="line">                ans.<span class="built_in">emplace_back</span>(cnt);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>思路二：前缀和思想，分别处理三个数组pre记录从0开始的*数量的前缀和。lpos记录&gt;=当前i位置的最小蜡烛位置，需要逆序，且最大值为数组长度-1。rpos记录&lt;=当前i位置的最大蜡烛位置，需要顺序，且最小值为0。</p>
<p>对每个query，sum=pre[rpos[query[1]]]-pre[lpos[query[0]]]</p>
<p>时间复杂度为O(n)</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">platesBetweenCandles</span><span class="params">(string s, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; queries)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt;<span class="built_in">pre</span>(s.<span class="built_in">size</span>(),<span class="number">0</span>),<span class="built_in">lpos</span>(s.<span class="built_in">size</span>(),<span class="number">0</span>),<span class="built_in">rpos</span>(s.<span class="built_in">size</span>(),<span class="number">0</span>); vector&lt;<span class="type">int</span>&gt;ans;<span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;s.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i]==<span class="string">&#x27;*&#x27;</span>)sum++;</span><br><span class="line">            pre[i]=sum;  </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> rp=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;s.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i]==<span class="string">&#x27;|&#x27;</span>)rp = i;</span><br><span class="line">            rpos[i]=rp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> lp=s.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=s.<span class="built_in">size</span>()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i]==<span class="string">&#x27;|&#x27;</span>)lp=i;</span><br><span class="line">            lpos[i]=lp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> i:queries)&#123;ans.<span class="built_in">emplace_back</span>(<span class="built_in">max</span>(<span class="number">0</span>,pre[rpos[i[<span class="number">1</span>]]]-pre[lpos[i[<span class="number">0</span>]]]));&#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
        <category>力扣</category>
        <category>每日一题</category>
        <category>前缀和</category>
        <category>二分</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>【每日】1984. 学生分数的最小差值</title>
    <url>/posts/3e175728/</url>
    <content><![CDATA[<p><img data-src="http://hz-picbed-xxh.oss-cn-hangzhou.aliyuncs.com/img-bed/image-20220211134306054.png" alt="image-20220211134306054" /></p>
<blockquote>
<p>思路：排序后使用滑动窗口的思想，取窗口内最大值和最小值，即i和i+k-1的差值，取最小。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minimumDifference</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(k==<span class="number">1</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="type">int</span> mi = INT_MAX;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i+k<span class="number">-1</span>&lt;nums.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            mi = <span class="built_in">min</span>(mi,nums[i+k<span class="number">-1</span>]-nums[i]);</span><br><span class="line">        </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> mi;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
        <category>力扣</category>
        <category>每日一题</category>
        <category>模拟题</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>cpp博客汇总</title>
    <url>/posts/26f80d45/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">
  <script id="hbeData" type="hbeData" data-hmacdigest="2460c6807de3abebe8d9342e8ea9beb17d2f4b7b1a1b52cacbbffcacccf00fbc">8c5eb7d299eb8204d1aa11d5321f1970e0702a4fa338dd1cc8a5f32ab3a638a5dfe317204ae956e092fc50bb1621e8ea08b755118da87b6340cee979b850f15388d6b14e6dbb75303be94c0ae2e6ad26eb3a75cba0265537fed2ef182633562904235b0284ffd7da53a6cf40d6b9c9fdc57a1e72ccf74d82d900b007763c0fa11de3777c888133a80ebcf422c34dfceae367d70f6a29a85a916cf04b3ed2f82e39c22edf7e9b771c8233d0f91391246a1e2fe94cbacbf87db9838b9f2728379bef603a45e2ed6216996d4b704363154b5f085310c168d8cef1ae628e02152199d3c03ecc29743403dc46d4e49a0a301e1a3c29b31e3fa265b4c2e087ec50fb4e76c610b062d13c66e4fb3aafc9607bf1d80cf99d5b2971c7018efd7dcd56b5cbfca40b40c14765c2678f6eacf3aa573ebdd0f2a6d0ae6e6d17abb7d558532c85</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-blink">
      <input class="hbe hbe-input-field hbe-input-field-blink" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-blink" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-blink" data-content="您好, 这里需要密码.">您好, 这里需要密码.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>cpp</category>
        <category>cpp资源</category>
      </categories>
      <tags>
        <tag>cpp资源</tag>
      </tags>
  </entry>
  <entry>
    <title>【每日】688. 骑士在棋盘上的概率</title>
    <url>/posts/2a64def3/</url>
    <content><![CDATA[<p><img data-src="http://hz-picbed-xxh.oss-cn-hangzhou.aliyuncs.com/img-bed/image-20220217185416173.png" alt="image-20220217185416173" /></p>
<blockquote>
<p>思路：采用bfs策略一定会超时，因为步数&lt;=100，理论上可能的总数有<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>8</mn><mn>100</mn></msup></mrow><annotation encoding="application/x-tex">8^{100}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">8</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">0</span><span class="mord mtight">0</span></span></span></span></span></span></span></span></span></span></span></span>次。因此采用三维dp[row][col][step]代表第step步时（row，col）处的概率。统计总数也可以，但是数字太大，若不模会溢出。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">        <span class="type">int</span> row,col,step;</span><br><span class="line">        <span class="built_in">node</span>(<span class="type">int</span> a,<span class="type">int</span> b,<span class="type">int</span> c)&#123;</span><br><span class="line">            <span class="keyword">this</span>-&gt;row = a;<span class="keyword">this</span>-&gt;col=b;<span class="keyword">this</span>-&gt;step=c;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;node;</span><br><span class="line">    <span class="type">int</span> dir[<span class="number">8</span>][<span class="number">2</span>]=&#123;&#123;<span class="number">1</span>,<span class="number">2</span>&#125;,&#123;<span class="number">2</span>,<span class="number">1</span>&#125;,&#123;<span class="number">-1</span>,<span class="number">2</span>&#125;,&#123;<span class="number">-2</span>,<span class="number">1</span>&#125;,&#123;<span class="number">-1</span>,<span class="number">-2</span>&#125;,&#123;<span class="number">-2</span>,<span class="number">-1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">-2</span>&#125;,&#123;<span class="number">2</span>,<span class="number">-1</span>&#125;&#125;;</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">bfs</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> k, <span class="type">int</span> row, <span class="type">int</span> column)</span></span>&#123;</span><br><span class="line">        <span class="comment">//tle k&gt;=10</span></span><br><span class="line">        <span class="keyword">if</span>(k==<span class="number">0</span>)<span class="keyword">return</span> <span class="number">1.0</span>;</span><br><span class="line">        queue&lt;node&gt;q; <span class="type">int</span> steps=<span class="number">0</span>; <span class="type">double</span> res = <span class="number">1.0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="function">node <span class="title">tmp</span><span class="params">(row,column,<span class="number">0</span>)</span></span>;</span><br><span class="line">        q.<span class="built_in">push</span>(tmp);</span><br><span class="line">        <span class="keyword">while</span>(q.<span class="built_in">empty</span>()==<span class="literal">false</span>&amp;&amp;q.<span class="built_in">front</span>().step!=k)&#123;</span><br><span class="line">            <span class="keyword">auto</span> cur = q.<span class="built_in">front</span>();q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> i : dir)&#123;</span><br><span class="line">                <span class="type">int</span> nextrow = cur.row+i[<span class="number">0</span>];</span><br><span class="line">                <span class="type">int</span> nextcol =cur.col + i[<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span>(nextrow&lt;<span class="number">0</span> || nextcol&lt;<span class="number">0</span> || nextrow&gt;=n|| nextcol&gt;=n) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="function">node <span class="title">tmp</span><span class="params">(nextrow,nextcol,cur.step+<span class="number">1</span>)</span></span>;</span><br><span class="line">                q.<span class="built_in">push</span>(tmp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;q.<span class="built_in">size</span>()&lt;&lt;endl;</span><br><span class="line">        res = q.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;k;i++)res/=<span class="number">8.0</span>;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">double</span> f[<span class="number">26</span>][<span class="number">26</span>][<span class="number">200</span>];</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">dp</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> k, <span class="type">int</span> row, <span class="type">int</span> col)</span></span>&#123;</span><br><span class="line">        <span class="built_in">fill</span>((<span class="type">int</span>*)f,(<span class="type">int</span>*)f+(<span class="number">26</span>*<span class="number">26</span>*<span class="number">200</span>),<span class="number">0.0</span>);<span class="type">int</span> step = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;j++) f[i][j][step]=<span class="number">1.0</span>;</span><br><span class="line">        <span class="keyword">while</span>(step!=k)&#123;</span><br><span class="line">            step++;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">auto</span> d:dir)&#123;</span><br><span class="line">                        <span class="type">int</span> prevrow = i+d[<span class="number">0</span>];</span><br><span class="line">                        <span class="type">int</span> prevcol = j+d[<span class="number">1</span>];</span><br><span class="line">                        <span class="keyword">if</span>(prevrow&lt;<span class="number">0</span> || prevcol&lt;<span class="number">0</span> || prevrow&gt;=n|| prevcol&gt;=n)<span class="keyword">continue</span>;</span><br><span class="line">                        f[i][j][step] +=f[prevrow][prevcol][step<span class="number">-1</span>]/<span class="number">8.0</span>;<span class="comment">//到达该位置的前一位置的所有概率和除以当前的选择概率。</span></span><br><span class="line">                    &#125; </span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f[row][col][k];</span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">knightProbability</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> k, <span class="type">int</span> row, <span class="type">int</span> column)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//bfs(n,k,row,column);</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dp</span>(n,k,row,column);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
        <category>力扣</category>
        <category>每日一题</category>
        <category>dp</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>cpp中的const</title>
    <url>/posts/4bf79020/</url>
    <content><![CDATA[<h2 id="cpp中的const更像是编译阶段的define"><a class="markdownIt-Anchor" href="#cpp中的const更像是编译阶段的define"></a> cpp中的<code>const</code>更像是编译阶段的<code>#define</code></h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> m = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> n = m;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在C语言中，编译器会先在m的内存中取出数据赋值给n；</p>
<p>在cpp中，编译器直接将10赋值给n，没有读取内存的操作。</p>
</blockquote>
<p><code>#define</code>是在预处理阶段替换，常量是在编译阶段替换。提高了程序执行的效率，缺点是不能反映内存变化。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> n =<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span>* p = (<span class="type">int</span>*)&amp;n;</span><br><span class="line">(*p) = <span class="number">100</span>;</span><br><span class="line">cout&lt;&lt;n&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;(*p)&lt;&lt;endl;</span><br><span class="line"><span class="comment">//输出为10 100</span></span><br></pre></td></tr></table></figure>
<p>将代码放到<code>.c</code>文件中，以C语言的方式编译，运行结果为<code>99</code>。再将代码放到<code>.cpp</code>文件中，以C<ins>的方式编译，运行结果就变成了<code>10</code>。这种差异正是由于C和C</ins>对 const 的处理方式不同造成的。</p>
<h2 id="cpp中全局const变量可见范围是当前文件"><a class="markdownIt-Anchor" href="#cpp中全局const变量可见范围是当前文件"></a> cpp中全局const变量可见范围是当前文件</h2>
<p>c语言中：<mark>全局变量的作用域是当前文件，但是在其他文件中也是可见的，使用<code>extern</code>声明后就可以使用</mark></p>
<p>cpp语言中：<mark>const变量的作用域是当前文件，在其他文件中不可见</mark></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="comment">//const int n = 10;</span></span><br><span class="line"><span class="comment">//int n = 10;</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">func</span><span class="params">()</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    func();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;main: %d\n&quot;</span>, n);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> n; </span><br><span class="line"><span class="type">void</span> <span class="title function_">func</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;module: %d\n&quot;</span>, n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>若为<code>int n=10;</code>无论cpp还是c语言均编译通过</p>
<p>若为<code>const int n=10;</code>，cpp编译失败（因为对其他文件不可见），c语言编译通过。</p>
</blockquote>
<h3 id="将const变量放入头文件中"><a class="markdownIt-Anchor" href="#将const变量放入头文件中"></a> 将const变量放入头文件中</h3>
<p><mark>由于 C++ 中全局 const 变量的可见范围仅限于当前源文件，所以可以将它放在头文件中，这样即使头文件被包含多次也不会出错</mark></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//module.h</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> n = <span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//module.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;module.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;module: %d\n&quot;</span>, n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//main.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;module.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">func</span>();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;main: %d\n&quot;</span>, n);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$ </span><span class="language-bash">g++ main.cpp module.cpp -o main &amp;&amp; main</span></span><br><span class="line"></span><br><span class="line">module: 10</span><br><span class="line">main: 10</span><br></pre></td></tr></table></figure>
<p>C和C<ins>中全局 const 变量的作用域相同，都是当前文件，不同的是它们的可见范围：C语言中 const 全局变量的可见范围是整个程序，在其他文件中使用 extern 声明后就可以使用；而C</ins>中 const 全局变量的可见范围仅限于当前文件，在其他文件中不可见，所以它可以定义在头文件中，多次引入后也不会出错。</p>
]]></content>
      <categories>
        <category>cpp</category>
        <category>cpp语法</category>
      </categories>
      <tags>
        <tag>cpp语法</tag>
      </tags>
  </entry>
  <entry>
    <title>cpp中指定默认参数的位置</title>
    <url>/posts/27cf2ee3/</url>
    <content><![CDATA[<p>wu</p>
]]></content>
      <categories>
        <category>cpp</category>
        <category>cpp语法</category>
      </categories>
      <tags>
        <tag>cpp语法</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树基础详解</title>
    <url>/posts/9dbf1a05/</url>
    <content><![CDATA[<p>删除树中的节点时，删除过程将按照后序遍历的顺序进行。 也就是说，当你删除一个节点时，你将首先删除它的左节点和它的右边的节点，然后再删除节点本身。另外，后序在数学表达中被广泛使用。 编写程序来解析后缀表示法更为容易。</p>
<p><img data-src="http://hz-picbed-xxh.oss-cn-hangzhou.aliyuncs.com/img-bed/mathematical_expression.png" alt="img" /></p>
<p>可以使用中序遍历轻松找出原始表达式。 但是程序处理这个表达式时并不容易，因为你必须检查操作的优先级。</p>
<p>如果你想对这棵树进行后序遍历，使用栈来处理表达式会变得更加容易。 每遇到一个操作符，就可以从栈中弹出栈顶的两个元素，计算并将结果返回到栈中。</p>
<h2 id="遍历"><a class="markdownIt-Anchor" href="#遍历"></a> 遍历</h2>
<h3 id="x序遍历"><a class="markdownIt-Anchor" href="#x序遍历"></a> X序遍历</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">preorder</span><span class="params">(TreeNode* cur,vector&lt;<span class="type">int</span>&gt;&amp; res)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(cur==<span class="literal">nullptr</span>)<span class="keyword">return</span>;</span><br><span class="line">    res.<span class="built_in">push_back</span>(cur-&gt;val); <span class="comment">//不同位置表示不同序的遍历</span></span><br><span class="line">    <span class="built_in">preorder</span>(cur-&gt;left,res);</span><br><span class="line">    <span class="built_in">preorder</span>(cur-&gt;right,res);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="层次遍历"><a class="markdownIt-Anchor" href="#层次遍历"></a> 层次遍历</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">levelOrder</span>(TreeNode* root) &#123;</span><br><span class="line">    vector&lt;TreeNode*&gt;q; vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;res; q.<span class="built_in">push_back</span>(root); <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(cnt&lt;q.<span class="built_in">size</span>())&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt;tmp;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=cnt;i&lt;q.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(q[i]!=<span class="literal">nullptr</span>)tmp.<span class="built_in">push_back</span>(q[i]-&gt;val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(tmp.<span class="built_in">size</span>())res.<span class="built_in">push_back</span>(tmp);</span><br><span class="line">        <span class="type">int</span> bound = q.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(cnt;cnt&lt;bound;cnt++)<span class="keyword">if</span>(q[cnt]!=<span class="literal">nullptr</span>)q.<span class="built_in">push_back</span>(q[cnt]-&gt;left),q.<span class="built_in">push_back</span>(q[cnt]-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="自顶向下"><a class="markdownIt-Anchor" href="#自顶向下"></a> 自顶向下</h3>
<p>“自顶向下” 意味着在每个递归层级，我们将首先访问节点来计算一些值，并在递归调用函数时将这些值传递到子节点。 所以 “自顶向下” 的解决方案可以被认为是一种前序遍历。 具体来说，递归函数 top_down(root, params) 的原理是这样的：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> specific value <span class="keyword">for</span> null node</span><br><span class="line">update the answer <span class="keyword">if</span> needed                      <span class="comment">// answer &lt;-- params</span></span><br><span class="line">left_ans = <span class="built_in">top_down</span>(root.left, left_params)		<span class="comment">// left_params &lt;-- root.val, params</span></span><br><span class="line">right_ans = <span class="built_in">top_down</span>(root.right, right_params)	<span class="comment">// right_params &lt;-- root.val, params</span></span><br><span class="line"><span class="keyword">return</span> the answer <span class="keyword">if</span> needed                      <span class="comment">// answer &lt;-- left_ans, right_ans</span></span><br></pre></td></tr></table></figure>
<h3 id="自底向上"><a class="markdownIt-Anchor" href="#自底向上"></a> 自底向上</h3>
<p>“自底向上” 是另一种递归方法。 在每个递归层次上，我们首先对所有子节点递归地调用函数，然后根据返回值和根节点本身的值得到答案。 这个过程可以看作是后序遍历的一种。 通常， “自底向上” 的递归函数 bottom_up(root) 为如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> specific value <span class="keyword">for</span> null node</span><br><span class="line">left_ans = <span class="built_in">bottom_up</span>(root.left)			<span class="comment">// call function recursively for left child</span></span><br><span class="line">right_ans = <span class="built_in">bottom_up</span>(root.right)		<span class="comment">// call function recursively for right child</span></span><br><span class="line"><span class="keyword">return</span> answers                           <span class="comment">// answer &lt;-- left_ans, right_ans, root.val</span></span><br></pre></td></tr></table></figure>
<h4 id="求树的最大深度"><a class="markdownIt-Anchor" href="#求树的最大深度"></a> 求树的最大深度</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> answer=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">topDown</span><span class="params">(TreeNode* cur,<span class="type">int</span> level)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(cur==<span class="literal">nullptr</span>)<span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">topDown</span>(cur-&gt;left,level+<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">topDown</span>(cur-&gt;right,level+<span class="number">1</span>);</span><br><span class="line">    answer = <span class="built_in">max</span>(answer,level);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bottomUp</span><span class="params">(TreeNode* cur)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(cur==<span class="literal">nullptr</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>(<span class="built_in">bottomUp</span>(cur-&gt;left),<span class="built_in">bottomUp</span>(cur-&gt;right))+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
        <category>基础算法</category>
        <category>二叉树</category>
      </categories>
      <tags>
        <tag>基础算法</tag>
        <tag>encryptalg</tag>
      </tags>
  </entry>
  <entry>
    <title>二分算法详解</title>
    <url>/posts/99d9a14f/</url>
    <content><![CDATA[<h3 id="常规二分写法"><a class="markdownIt-Anchor" href="#常规二分写法"></a> 常规二分写法</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(l&lt;=r)&#123;</span><br><span class="line">    <span class="type">int</span> mid = l+ (r-l&gt;&gt;<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(mid = target) <span class="keyword">return</span> mid;</span><br><span class="line">    <span class="keyword">if</span>(mid&lt;target)l = mid+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> r = mid<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br></pre></td></tr></table></figure>
<p>每次搜索的区间是[l,r]，因此l和r均不包含mid</p>
<h3 id="查找target的右边界"><a class="markdownIt-Anchor" href="#查找target的右边界"></a> 查找&lt;=target的右边界</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line">    <span class="type">int</span> mid = l + (r-l&gt;&gt;<span class="number">1</span>)+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(mid&lt;=target) l = mid;</span><br><span class="line">    <span class="keyword">else</span> r = mid<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> l;</span><br></pre></td></tr></table></figure>
<ol>
<li>收缩区间，查找右边界指在&lt;=target的区间中取最大的一个，即&gt;target的区间舍去，<code>r = mid-1</code>，每次搜索的区间是(left,right]</li>
<li>因为<code>mid = l+(r-l&gt;&gt;1)</code>总是落在(l+r)/2的右侧，<code>l=mid</code>可以保证<code>l</code>始终在左区间的右边界上</li>
<li>当终止条件<code>l==r</code>时，r右边的区域为&gt;target，l为&lt;=target的区域的右边界。</li>
</ol>
<h4 id="一个其他版本的查找右侧边界代码"><a class="markdownIt-Anchor" href="#一个其他版本的查找右侧边界代码"></a> 一个其他版本的查找右侧边界代码</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line">    <span class="type">int</span> mid = l+ (r-l&gt;&gt;<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(mid&gt;target) r = mid;</span><br><span class="line">    <span class="keyword">else</span> l = mid+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> l<span class="number">-1</span>;</span><br></pre></td></tr></table></figure>
<p>其实就是<mark>查找 &gt;target的左边界</mark>  版本，返回left-1即<mark>为&lt;=tareget的右边界</mark></p>
<h3 id="查找target的左边界"><a class="markdownIt-Anchor" href="#查找target的左边界"></a> 查找&gt;=target的左边界</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line">    <span class="type">int</span> mid = l+(r-l)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(mid&gt;=target)r = mid;</span><br><span class="line">    <span class="keyword">else</span> l = mid+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> l;</span><br></pre></td></tr></table></figure>
<ol>
<li>收缩区间，查找左边界指在&gt;=target的区间中取最小的一个，即&lt;target的区间舍去，<code>l = mid+1</code>，每次搜索的区间是[left,right)</li>
<li>因为mid = l+(r-l&gt;&gt;1)总是落在(l+r)/2的左侧，<code>r = mid</code>可以保证<code>r</code>始终落在右区间的左边界上</li>
<li>当终止条件<code>l==r</code>时，l左侧的部分全部为&lt;target，r为&lt;=target的区域的右边界</li>
</ol>
<h3 id="题目"><a class="markdownIt-Anchor" href="#题目"></a> 题目</h3>
<h4 id="搜索旋转排序数组"><a class="markdownIt-Anchor" href="#搜索旋转排序数组"></a> <a href="https://leetcode-cn.com/problems/search-in-rotated-sorted-array/">搜索旋转排序数组</a></h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">search</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> l  = <span class="number">0</span>,r = nums.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;=r)&#123;</span><br><span class="line">            <span class="type">int</span> mid = l+(r-l&gt;&gt;<span class="number">1</span>);</span><br><span class="line">            <span class="type">int</span> num = nums[mid],numl = nums[l],numr = nums[r];</span><br><span class="line">            <span class="keyword">if</span>(num==target)<span class="keyword">return</span> mid;</span><br><span class="line">            <span class="keyword">if</span>(numl&lt;=num)&#123; <span class="comment">//左边有序</span></span><br><span class="line">                <span class="keyword">if</span>(target&lt;num &amp;&amp; target&gt;=numl)r = mid<span class="number">-1</span>; <span class="comment">//在左边</span></span><br><span class="line">                <span class="keyword">else</span> l = mid+<span class="number">1</span>; <span class="comment">//在右边</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123; <span class="comment">//右边有序</span></span><br><span class="line">                <span class="keyword">if</span>(target&gt;num &amp;&amp; target&lt;=numr ) l = mid+<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> r = mid<span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="寻找峰值"><a class="markdownIt-Anchor" href="#寻找峰值"></a> <a href="https://leetcode-cn.com/problems/find-peak-element/">寻找峰值</a></h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findPeakElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> l = <span class="number">0</span>,r = nums.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line">            <span class="type">int</span> mid = l + (r-l&gt;&gt;<span class="number">1</span>);</span><br><span class="line">            <span class="type">int</span> prev,next;</span><br><span class="line">            <span class="keyword">if</span>(mid<span class="number">-1</span>&gt;=<span class="number">0</span>)prev = nums[mid<span class="number">-1</span>];<span class="keyword">else</span> prev = INT_MIN;</span><br><span class="line">            <span class="keyword">if</span>(mid+<span class="number">1</span>&lt;=nums.<span class="built_in">size</span>()<span class="number">-1</span>)next = nums[mid+<span class="number">1</span>];<span class="keyword">else</span> next = INT_MIN;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid]&gt;prev&amp;&amp;nums[mid]&gt;next)<span class="keyword">return</span> mid;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid]&gt;=prev) l = mid+<span class="number">1</span>; <span class="keyword">else</span> r = mid<span class="number">-1</span>; <span class="comment">//等号给INT_MIN 上坡必有顶</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="在排序数组中查找元素的第一个和最后一个位置"><a class="markdownIt-Anchor" href="#在排序数组中查找元素的第一个和最后一个位置"></a> <a href="https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/">在排序数组中查找元素的第一个和最后一个位置</a></h4>
<p>lower_bound(start,end,target) 返回&gt;=target的第一个位置地址</p>
<p>upper_bound(start,end,target) 返回&gt;target的第一个位置地址</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">searchRange</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//第一种方法使用双二分法，注意边界</span></span><br><span class="line">        <span class="type">int</span> l = <span class="number">0</span>, r = nums.<span class="built_in">size</span>()<span class="number">-1</span>;<span class="type">int</span> left=<span class="number">-1</span>,right = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;r)&#123; <span class="comment">//&gt;=target的左边界</span></span><br><span class="line">            <span class="type">int</span> mid = l+(r-l&gt;&gt;<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span>(nums[mid]&gt;=target)r = mid;<span class="keyword">else</span> l = mid+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(nums.<span class="built_in">size</span>()&gt;<span class="number">0</span>) <span class="keyword">if</span>( nums[l]!=target)left = <span class="number">-1</span>;<span class="keyword">else</span> left=l;</span><br><span class="line">        l =<span class="number">0</span>;r = nums.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;r)&#123;<span class="comment">//&lt;=target的右边界</span></span><br><span class="line">            <span class="type">int</span> mid = l+(r-l&gt;&gt;<span class="number">1</span>)+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid]&lt;=target)l = mid;<span class="keyword">else</span> r = mid<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(nums.<span class="built_in">size</span>()&gt;<span class="number">0</span> )<span class="keyword">if</span>(nums[l]!=target)right = <span class="number">-1</span>;<span class="keyword">else</span> right=l;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt;res; res.<span class="built_in">push_back</span>(left);res.<span class="built_in">push_back</span>(right);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//第二种方法使用STL，注意边界</span></span><br><span class="line">        left = <span class="built_in">lower_bound</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>(),target)-nums.<span class="built_in">begin</span>();</span><br><span class="line">        right = <span class="built_in">upper_bound</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>(),target)-nums.<span class="built_in">begin</span>()<span class="number">-1</span>;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt;res2;</span><br><span class="line">        <span class="keyword">if</span>(nums.<span class="built_in">size</span>()&gt;<span class="number">0</span> &amp;&amp; left&gt;=<span class="number">0</span> &amp;&amp;left &lt;nums.<span class="built_in">size</span>() &amp;&amp; nums[left]==target)res2.<span class="built_in">push_back</span>(left);<span class="keyword">else</span> res2.<span class="built_in">push_back</span>(<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">if</span>(nums.<span class="built_in">size</span>()&gt;<span class="number">0</span> &amp;&amp; right &gt;=<span class="number">0</span> &amp;&amp; right &lt; nums.<span class="built_in">size</span>() &amp;&amp;nums[right]==target)res2.<span class="built_in">push_back</span>(right);<span class="keyword">else</span> res2.<span class="built_in">push_back</span>(<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">return</span> res2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="找到-k-个最接近的元素"><a class="markdownIt-Anchor" href="#找到-k-个最接近的元素"></a> <a href="https://leetcode-cn.com/problems/find-k-closest-elements/">找到 K 个最接近的元素</a></h4>
<h4 id="方法一二分查找双指针"><a class="markdownIt-Anchor" href="#方法一二分查找双指针"></a> 方法一：二分查找+双指针</h4>
<p>首先找到&lt;=target的右边界，确定pos之后</p>
<p>令left=pos-k,right=pos+k，则我们需要的数字必定在这里面。分成三类讨论</p>
<ol>
<li>left&lt;0 left++</li>
<li>right&gt;=arr.size() right–;</li>
<li>在数组范围内，判断x与arr[left]和arr[right]的距离，left近就right–否则left++</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">findClosestElements</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr, <span class="type">int</span> k, <span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> l = <span class="number">0</span>,r = arr.<span class="built_in">size</span>()<span class="number">-1</span>;<span class="type">int</span> pos;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;r)&#123;<span class="comment">//&lt;=target 的右边界</span></span><br><span class="line">            <span class="type">int</span> mid = l+(r-l&gt;&gt;<span class="number">1</span>)+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(arr[mid]&lt;=x)l=mid;<span class="keyword">else</span> r=mid<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        pos = l;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt;res;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> left = pos-k,right=pos+k;</span><br><span class="line">        <span class="keyword">while</span>(right-left+<span class="number">1</span>&gt;k)&#123;</span><br><span class="line">            <span class="keyword">if</span>(left&lt;<span class="number">0</span>)&#123;left++;<span class="keyword">continue</span>;&#125;</span><br><span class="line">            <span class="keyword">if</span>(right&gt;=arr.<span class="built_in">size</span>())&#123;right--;<span class="keyword">continue</span>;&#125;</span><br><span class="line">            <span class="keyword">if</span>(arr[right]-x&gt;=x-arr[left])right--;<span class="keyword">else</span> left++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=left;i&lt;=right;i++)res.<span class="built_in">push_back</span>(arr[i]);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="方法二排序"><a class="markdownIt-Anchor" href="#方法二排序"></a> 方法二：排序</h4>
<p>将所有的数字和x的差值进行排序，取前k个。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//static int target;</span></span><br><span class="line">    <span class="comment">//static bool cmp(int &amp; a,int &amp; b)&#123;</span></span><br><span class="line">        <span class="comment">//if(abs(a-target)==abs(b-target))return a&lt;b;else return abs(a-target)&lt;abs(b-target);</span></span><br><span class="line">    <span class="comment">//&#125;</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">findClosestElements</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr, <span class="type">int</span> k, <span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(arr.<span class="built_in">begin</span>(),arr.<span class="built_in">end</span>(),[&amp;x](<span class="type">int</span> &amp;a,<span class="type">int</span> &amp;b)-&gt; <span class="type">bool</span>&#123;<span class="keyword">if</span>(<span class="built_in">abs</span>(a-x)==<span class="built_in">abs</span>(b-x))<span class="keyword">return</span> a&lt;b; <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">abs</span>(a-x)&lt;<span class="built_in">abs</span>(b-x);&#125;);     <span class="comment">//函数式编程，省去了引用static变量和初始化的过程</span></span><br><span class="line">        <span class="comment">//this-&gt;target = x;</span></span><br><span class="line">        <span class="comment">//sort(arr.begin(),arr.end(),cmp);</span></span><br><span class="line">        vector&lt;<span class="type">int</span>&gt;res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;k;i++)res.<span class="built_in">emplace_back</span>(arr[i]);</span><br><span class="line">        <span class="built_in">sort</span>(res.<span class="built_in">begin</span>(),res.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//int Solution::target = 0; //类型 所在类：：静态变量名 = 初始化值。</span></span><br></pre></td></tr></table></figure>
<h3 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h3>
<p><a href="https://www.cnblogs.com/kyoner/p/11080078.html">https://www.cnblogs.com/kyoner/p/11080078.html</a></p>
<p>《蓝书》P26</p>
]]></content>
      <categories>
        <category>算法</category>
        <category>基础算法</category>
        <category>二分</category>
      </categories>
      <tags>
        <tag>基础算法</tag>
        <tag>encryptalg</tag>
      </tags>
  </entry>
  <entry>
    <title>前缀和、差分与树状数组、线段树基础</title>
    <url>/posts/8f4b279/</url>
    <content><![CDATA[<p>ref：</p>
<p><a href="https://blog.csdn.net/bestsort/article/details/80796531">https://blog.csdn.net/bestsort/article/details/80796531</a></p>
<p><a href="https://www.luogu.com.cn/problem/solution/P3374">https://www.luogu.com.cn/problem/solution/P3374</a></p>
<h3 id="树状数组解决的问题"><a class="markdownIt-Anchor" href="#树状数组解决的问题"></a> 树状数组解决的问题</h3>
<ol>
<li>单点修改，求区间和</li>
<li>区间修改，求区间和</li>
</ol>
<h3 id="前缀和数组"><a class="markdownIt-Anchor" href="#前缀和数组"></a> 前缀和数组</h3>
<p>可以快速求出<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">[</mo><mi>l</mi><mo separator="true">,</mo><mi>r</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[l,r]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mclose">]</span></span></span></span> 范围内的和<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mi>u</mi><mi>m</mi><mo>=</mo><mi>s</mi><mi>u</mi><mi>m</mi><mi>a</mi><mi>r</mi><mi>r</mi><mo stretchy="false">[</mo><mi>r</mi><mo stretchy="false">]</mo><mo>−</mo><mi>s</mi><mi>u</mi><mi>m</mi><mi>a</mi><mi>r</mi><mi>r</mi><mo stretchy="false">[</mo><mi>l</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">sum = sumarr[r]-sumarr[l-1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span></p>
<p>缺点：无法支持单点修改和区间修改，因为每修改一次需要对后续所有的数组元素重新计算。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=nums.<span class="built_in">size</span>();i++)dp[i] = dp[i<span class="number">-1</span>]+nums[i<span class="number">-1</span>];</span><br><span class="line">cout&lt;&lt;dp[r]-dp[l<span class="number">-1</span>]&lt;&lt;endl;</span><br></pre></td></tr></table></figure>
<h4 id="二维矩阵-子矩阵的和"><a class="markdownIt-Anchor" href="#二维矩阵-子矩阵的和"></a> 二维矩阵-子矩阵的和</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,m,q;cin&gt;&gt;n&gt;&gt;m&gt;&gt;q;</span><br><span class="line">    <span class="built_in">fill</span>(f[<span class="number">0</span>],f[<span class="number">0</span>]+<span class="number">1010</span>*<span class="number">1010</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;j++)&#123;</span><br><span class="line">            <span class="type">int</span> num;cin&gt;&gt;num;</span><br><span class="line">            f[i][j] = num+f[i<span class="number">-1</span>][j]+f[i][j<span class="number">-1</span>]-f[i<span class="number">-1</span>][j<span class="number">-1</span>]; cout&lt;&lt;f[i][j]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(q--)&#123;</span><br><span class="line">        <span class="type">int</span> a,b,c,d;cin&gt;&gt;a&gt;&gt;b&gt;&gt;c&gt;&gt;d;</span><br><span class="line">        cout&lt;&lt;f[c][d]-f[a<span class="number">-1</span>][d]-f[c][b<span class="number">-1</span>]+f[a<span class="number">-1</span>][b<span class="number">-1</span>]&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="差分数组"><a class="markdownIt-Anchor" href="#差分数组"></a> 差分数组</h3>
<p>差分为前缀和的逆运算，将当前数组看成前缀和数组，差分数组为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mi>d</mi><mi>j</mi><mi>a</mi><mi>r</mi><mi>r</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo>=</mo><mi>s</mi><mi>u</mi><mi>m</mi><mi>a</mi><mi>r</mi><mi>r</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo>−</mo><mi>s</mi><mi>u</mi><mi>m</mi><mi>a</mi><mi>r</mi><mi>r</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">adjarr[i] = sumarr[i]-sumarr[i-1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault">d</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span>支持单点修改和区间修改，以及最后的一次查询。</p>
<p>缺点：无法支持动态查询</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    <span class="type">int</span> n,m;cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;<span class="built_in">sum</span>(n+<span class="number">1</span>),<span class="built_in">adj</span>(n+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)cin&gt;&gt;sum[i];</span><br><span class="line">    <span class="built_in">adjacent_difference</span>(sum.<span class="built_in">begin</span>(),sum.<span class="built_in">end</span>(),adj.<span class="built_in">begin</span>());<span class="comment">//构造差分数组</span></span><br><span class="line">    <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">        <span class="type">int</span> l,r,c;cin&gt;&gt;l&gt;&gt;r&gt;&gt;c;</span><br><span class="line">        adj[l<span class="number">-1</span>]+=c;adj[r]-=c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> num=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        num = num+ adj[i];</span><br><span class="line">        cout&lt;&lt;num&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="树状数组-stage1"><a class="markdownIt-Anchor" href="#树状数组-stage1"></a> 树状数组-stage1</h3>
<h4 id="lowbit函数"><a class="markdownIt-Anchor" href="#lowbit函数"></a> lowbit函数</h4>
<p>返回x的二进制最低位的1组成的整数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">lowbit</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;<span class="keyword">return</span> x&amp;(-x);&#125;<span class="comment">// 6 = 110 -&gt; 10 = 2</span></span><br></pre></td></tr></table></figure>
<p>树状数组其实就是二叉树化的前缀和数组。每个数组元素<code>x</code>对<code>x+lowbit(x)</code>有贡献，因此每个<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span>控制<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">[</mo><mi>x</mi><mo>−</mo><mi>l</mi><mi>o</mi><mi>w</mi><mi>b</mi><mi>i</mi><mi>t</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>+</mo><mn>1</mn><mo separator="true">,</mo><mi>x</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[x-lowbit(x)+1,x]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord mathdefault">b</span><span class="mord mathdefault">i</span><span class="mord mathdefault">t</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">x</span><span class="mclose">]</span></span></span></span>,易知当<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mo>+</mo><mi>l</mi><mi>o</mi><mi>w</mi><mi>b</mi><mi>i</mi><mi>t</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">x+lowbit(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord mathdefault">b</span><span class="mord mathdefault">i</span><span class="mord mathdefault">t</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span></span></span></span>时类似二叉树的向其父节点追溯，而<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mo>−</mo><mi>l</mi><mi>o</mi><mi>w</mi><mi>b</mi><mi>i</mi><mi>t</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">x-lowbit(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord mathdefault">b</span><span class="mord mathdefault">i</span><span class="mord mathdefault">t</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span></span></span></span>时类似寻找其孩子。</p>
<p><img data-src="http://hz-picbed-xxh.oss-cn-hangzhou.aliyuncs.com/img-bed/20200717113256650.png" alt="img" /></p>
<p><img data-src="http://hz-picbed-xxh.oss-cn-hangzhou.aliyuncs.com/img-bed/20200717113236761.png" alt="img" /></p>
<h4 id="单点更新"><a class="markdownIt-Anchor" href="#单点更新"></a> 单点更新</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">lowadd</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; bit,<span class="type">int</span> pos,<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(pos&lt;bit.<span class="built_in">size</span>())&#123;</span><br><span class="line">        bit[pos]+=k;</span><br><span class="line">        pos+=<span class="built_in">lowbit</span>(pos);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="区间求和"><a class="markdownIt-Anchor" href="#区间求和"></a> 区间求和</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">lowsum</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp; bit,<span class="type">int</span> pos)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(pos&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        sum+=bit[pos];</span><br><span class="line">        pos-=<span class="built_in">lowbit</span>(pos);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
        <category>基础算法</category>
      </categories>
      <tags>
        <tag>基础算法</tag>
      </tags>
  </entry>
  <entry>
    <title>常用stl算法总结</title>
    <url>/posts/603c8f61/</url>
    <content><![CDATA[<h2 id="容器"><a class="markdownIt-Anchor" href="#容器"></a> 容器</h2>
<h3 id="vector"><a class="markdownIt-Anchor" href="#vector"></a> vector</h3>
<h4 id="基本操作"><a class="markdownIt-Anchor" href="#基本操作"></a> 基本操作</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">push_back</span><span class="params">()</span></span>;<span class="function"><span class="type">void</span>  <span class="title">emplace_back</span><span class="params">()</span></span>; <span class="comment">//尾端插入</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pop_back</span><span class="params">()</span></span>; <span class="comment">//尾端弹出</span></span><br><span class="line"><span class="function">iterator <span class="title">front</span><span class="params">()</span></span>; <span class="function">iterator <span class="title">back</span><span class="params">()</span></span>;<span class="comment">//返回首尾迭代器</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span> <span class="comment">//清空</span></span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="comment">//判空</span></span></span><br><span class="line"><span class="function">iterator <span class="title">erase</span><span class="params">(itereator loc)</span></span>;<span class="comment">//删除loc所指的元素，返回下一元素的迭代器</span></span><br><span class="line"><span class="function">iterator <span class="title">erase</span><span class="params">(iterator start,iterator end)</span></span>;删除[start,end)之间的元素，返回end元素的迭代器</span><br><span class="line"><span class="function">iterator <span class="title">insert</span><span class="params">(iterator loc,val)</span></span>;<span class="comment">//在loc位置插入一个value元素，并且返回其迭代器，原loc及以后的元素后移</span></span><br><span class="line"><span class="comment">//vector&lt;int&gt;::iterator it=q.insert(q.begin()+2,num);</span></span><br></pre></td></tr></table></figure>
<h4 id="一维初始化"><a class="markdownIt-Anchor" href="#一维初始化"></a> 一维初始化</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;T&gt; v1 <span class="comment">//空的vector，执行默认初始化</span></span><br><span class="line"><span class="function">vector&lt;T&gt; <span class="title">v2</span><span class="params">(v1)</span> <span class="comment">//v2包含有v1所有元素的副本</span></span></span><br><span class="line"><span class="function">vector&lt;T&gt; <span class="title">v2</span><span class="params">(v1.begin(),v1.end())</span><span class="comment">//包含指定范围的数据</span></span></span><br><span class="line"><span class="function">vector&lt;T&gt; v2</span>=v1 <span class="comment">//等价于上条语句</span></span><br><span class="line"><span class="function">vector&lt;T&gt; <span class="title">v3</span><span class="params">(n,val)</span> <span class="comment">//包含了n个重复元素，每个元素的值都是val</span></span></span><br><span class="line"><span class="function">vector&lt;T&gt; <span class="title">v4</span><span class="params">(n)</span> <span class="comment">//包含n个默认初始化的对象 </span></span></span><br><span class="line"><span class="function">vector&lt;T&gt; v4</span>&#123;a,b,c...&#125; <span class="comment">//包含了初始值个数的元素，并被初始化</span></span><br><span class="line">vector&lt;T&gt; v5=&#123;a,b,c...&#125; <span class="comment">//等价于上条语句</span></span><br></pre></td></tr></table></figure>
<h4 id="二维数组初始化"><a class="markdownIt-Anchor" href="#二维数组初始化"></a> 二维数组初始化</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">vec</span>(row, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; (col,<span class="number">1</span>));</span><br></pre></td></tr></table></figure>
<h3 id="list"><a class="markdownIt-Anchor" href="#list"></a> List</h3>
<h4 id="初始化"><a class="markdownIt-Anchor" href="#初始化"></a> 初始化</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">list&lt;<span class="type">int</span>&gt;<span class="built_in">a</span>(<span class="number">10</span>,<span class="number">1</span>)<span class="comment">//10大小初始值1</span></span><br><span class="line">list&lt;<span class="type">int</span>&gt;<span class="built_in">a</span>(n,n+<span class="number">5</span>)<span class="comment">//使用数组初始化</span></span><br></pre></td></tr></table></figure>
<h4 id="基本操作-2"><a class="markdownIt-Anchor" href="#基本操作-2"></a> 基本操作</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">list.<span class="built_in">resize</span>()<span class="comment">//改变大小</span></span><br><span class="line">list.<span class="built_in">push_front</span>();</span><br><span class="line">list.<span class="built_in">push_back</span>()</span><br><span class="line">list.<span class="built_in">insert</span>(&amp;it,val);</span><br><span class="line">list.<span class="built_in">insert</span>(&amp;it,<span class="type">int</span> n,val)<span class="comment">//&amp;it位置插入n个val</span></span><br><span class="line">list.<span class="built_in">insert</span>(&amp;it,begin,last)<span class="comment">//&amp;it位置插入begin~end</span></span><br><span class="line">list.<span class="built_in">pop_front</span>()</span><br><span class="line">list.<span class="built_in">pop_back</span>()</span><br><span class="line">list.<span class="built_in">erase</span>(&amp;it)</span><br><span class="line">list.<span class="built_in">erase</span>(begin,end)</span><br><span class="line">list.<span class="built_in">clear</span>()<span class="comment">//清空</span></span><br><span class="line"></span><br><span class="line">list.<span class="built_in">assign</span>(<span class="type">int</span> nSize,val)<span class="comment">//类似数组初始化</span></span><br><span class="line"><span class="built_in">swap</span>(list&amp;,list&amp;)<span class="comment">//交换</span></span><br><span class="line">list.<span class="built_in">merge</span>();<span class="comment">//合并，默认升序</span></span><br><span class="line">list.<span class="built_in">splice</span>(&amp;it,list&amp;) <span class="comment">//&amp;it位置接入list</span></span><br><span class="line">list.<span class="built_in">unique</span>()<span class="comment">//去重</span></span><br><span class="line">list.<span class="built_in">sort</span>()</span><br><span class="line">list.<span class="built_in">remove_if</span>()<span class="comment">//条件去重</span></span><br><span class="line">list.<span class="built_in">reverse</span>()</span><br></pre></td></tr></table></figure>
<h3 id="stack"><a class="markdownIt-Anchor" href="#stack"></a> stack</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span>	栈为空返回<span class="literal">true</span>,否则返回<span class="literal">false</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">()</span>	删除栈顶元素，即出栈</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">const</span> TYPE &amp;val)</span>	将新元素val进栈，使其成为栈顶元素</span></span><br><span class="line"><span class="function"><span class="title">top</span><span class="params">()</span> 查看当前栈顶元素</span></span><br><span class="line"><span class="function"><span class="title">size</span><span class="params">()</span> 返回元素数目</span></span><br></pre></td></tr></table></figure>
<h3 id="queue"><a class="markdownIt-Anchor" href="#queue"></a> queue</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span>	队列为空返回<span class="literal">true</span>,否则返回<span class="literal">false</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">()</span>	删除队列头元素，即出栈</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">const</span> TYPE &amp;val)</span>	将新元素val进队尾</span></span><br><span class="line"><span class="function"><span class="title">top</span><span class="params">()</span> 查看当前栈顶元素</span></span><br><span class="line"><span class="function"><span class="title">size</span><span class="params">()</span> 返回元素数目</span></span><br></pre></td></tr></table></figure>
<h3 id="deque"><a class="markdownIt-Anchor" href="#deque"></a> deque</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">assign</span>()	设置双向队列的值</span><br><span class="line"><span class="built_in">at</span>()	返回指定的元素</span><br><span class="line"><span class="built_in">back</span>()	返回最后一个元素</span><br><span class="line"><span class="built_in">begin</span>()	返回指向第一个元素的迭代器</span><br><span class="line"><span class="built_in">clear</span>()	删除所有元素</span><br><span class="line"><span class="built_in">empty</span>()	返回真如果双向队列为空</span><br><span class="line"><span class="built_in">end</span>()	返回指向尾部的迭代器</span><br><span class="line"><span class="built_in">erase</span>()	删除一个元素</span><br><span class="line"><span class="built_in">front</span>()	返回第一个元素</span><br><span class="line"><span class="built_in">get_allocator</span>()	返回双向队列的配置器</span><br><span class="line"><span class="built_in">insert</span>()	插入一个元素到双向队列中</span><br><span class="line"><span class="built_in">max_size</span>()	返回双向队列能容纳的最大元素个数</span><br><span class="line"><span class="built_in">pop_back</span>()	删除尾部的元素</span><br><span class="line"><span class="built_in">pop_front</span>()	删除头部的元素</span><br><span class="line"><span class="built_in">push_back</span>()	在尾部加入一个元素</span><br><span class="line"><span class="built_in">push_front</span>()	在头部加入一个元素</span><br><span class="line"><span class="built_in">rbegin</span>()	返回指向尾部的逆向迭代器</span><br><span class="line"><span class="built_in">rend</span>()	返回指向头部的逆向迭代器</span><br><span class="line"><span class="built_in">resize</span>()	改变双向队列的大小</span><br><span class="line"><span class="built_in">size</span>()	返回双向队列中元素的个数</span><br><span class="line"><span class="built_in">swap</span>()	和另一个双向队列交换元素</span><br></pre></td></tr></table></figure>
<h3 id="优先队列-重定义"><a class="markdownIt-Anchor" href="#优先队列-重定义"></a> 优先队列-重定义</h3>
<ol>
<li>自定义类型重载，使用仿函数中的比较函数</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">    <span class="type">int</span> x, y;</span><br><span class="line">    <span class="built_in">Node</span>( <span class="type">int</span> a= <span class="number">0</span>, <span class="type">int</span> b= <span class="number">0</span> ):</span><br><span class="line">        <span class="built_in">x</span>(a), <span class="built_in">y</span>(b) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>&gt;( Node a, Node b )&#123;<span class="comment">//返回true，a的优先级大于b</span></span><br><span class="line">    <span class="comment">//x大的排在队前部；x相同时，y大的排在队前部</span></span><br><span class="line">    <span class="keyword">if</span>( a.x== b.x ) <span class="keyword">return</span> a.y&gt; b.y;</span><br><span class="line">    <span class="keyword">return</span> a.x&gt; b.x; </span><br><span class="line">&#125;</span><br><span class="line">priority_queue&lt;Node,vector&lt;Node&gt;,greater&lt;Node&gt; &gt; q;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ol start="2">
<li>自定义函数对象()</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">cmp</span>&#123;</span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(NODE n1,NODE n2)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> n1.val&gt;n2.val; <span class="comment">//小根堆 </span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">priority_queue&lt;NODE,vector&lt;NODE&gt;,cmp&gt;q;</span><br></pre></td></tr></table></figure>
<h3 id="set"><a class="markdownIt-Anchor" href="#set"></a> Set</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">begin</span>()：返回指向第一个元素的迭代器</span><br><span class="line"><span class="built_in">clear</span>()：清除所有元素</span><br><span class="line"><span class="built_in">count</span>()：返回某个值元素的个数</span><br><span class="line"><span class="built_in">empty</span>()：如果集合为空，返回<span class="function"><span class="literal">true</span></span></span><br><span class="line"><span class="function"><span class="title">end</span><span class="params">()</span>：返回指向最后一个元素的迭代器</span></span><br><span class="line"><span class="function"><span class="title">equal_range</span><span class="params">()</span>：返回集合中与给定值相等的上下限的两个迭代器</span></span><br><span class="line"><span class="function"><span class="title">erase</span><span class="params">()</span>：删除集合中的元素</span></span><br><span class="line"><span class="function"><span class="title">find</span><span class="params">()</span>：返回一个指向被查找到元素的迭代器</span></span><br><span class="line"><span class="function"><span class="title">get_allocator</span><span class="params">()</span>：返回集合的分配器</span></span><br><span class="line"><span class="function"><span class="title">insert</span><span class="params">()</span>：在集合中插入元素</span></span><br><span class="line"><span class="function"><span class="title">lower_bound</span><span class="params">()</span>：返回指向大于（或等于）某值的第一个元素的迭代器</span></span><br><span class="line"><span class="function"><span class="title">key_comp</span><span class="params">()</span>：返回一个用于元素间值比较的函数</span></span><br><span class="line"><span class="function"><span class="title">max_size</span><span class="params">()</span>：返回集合能容纳的元素的最大限值</span></span><br><span class="line"><span class="function"><span class="title">rbegin</span><span class="params">()</span>：返回指向集合中最后一个元素的反向迭代器</span></span><br><span class="line"><span class="function"><span class="title">rend</span><span class="params">()</span>：返回指向集合中第一个元素的反向迭代器</span></span><br><span class="line"><span class="function"><span class="title">size</span><span class="params">()</span>：集合中元素的数目</span></span><br><span class="line"><span class="function"><span class="title">swap</span><span class="params">()</span>：交换两个集合变量</span></span><br><span class="line"><span class="function"><span class="title">upper_bound</span><span class="params">()</span>：返回大于某个值元素的迭代器</span></span><br><span class="line"><span class="function"><span class="title">value_comp</span><span class="params">()</span>：返回一个用于比较元素间的值的函数</span></span><br></pre></td></tr></table></figure>
<h3 id="map"><a class="markdownIt-Anchor" href="#map"></a> Map</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">map.<span class="built_in">size</span>()/<span class="built_in">clear</span>()/<span class="built_in">empty</span>()</span><br><span class="line"><span class="function">iterator <span class="title">lower_bound</span><span class="params">(key)</span><span class="comment">//返回指向键值&gt;=key的第一个元素upper_bound 键值&gt;key</span></span></span><br><span class="line"><span class="function">map.<span class="title">key_comp</span><span class="params">()</span><span class="comment">//返回比较key大小</span></span></span><br><span class="line"><span class="function">map.<span class="title">value_comp</span><span class="params">()</span><span class="comment">//返回比较value大小</span></span></span><br><span class="line"><span class="function">itearator <span class="title">find</span><span class="params">(key)</span><span class="comment">//返回键值为key的迭代器，未找到则返回end()</span></span></span><br><span class="line"><span class="function">pair&lt;itaratoe,<span class="type">bool</span>&gt; <span class="title">insert</span><span class="params">(pair&lt;key,value&gt;)</span>插入键值对，返回pair&lt;迭代器，成功与否&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="stl内置算法"><a class="markdownIt-Anchor" href="#stl内置算法"></a> STL内置算法</h2>
<h3 id="fill"><a class="markdownIt-Anchor" href="#fill"></a> fill</h3>
<h4 id="给一维数组赋值"><a class="markdownIt-Anchor" href="#给一维数组赋值"></a> 给一维数组赋值</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> f[MAXN];</span><br><span class="line"><span class="built_in">fill</span>(f,f+MAXN,num);</span><br></pre></td></tr></table></figure>
<h4 id="给二维数组赋值"><a class="markdownIt-Anchor" href="#给二维数组赋值"></a> 给二维数组赋值</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> f[MAXN][MAXN];</span><br><span class="line"><span class="built_in">fill</span>(f[<span class="number">0</span>],f[<span class="number">0</span>]+MAXN*MAXN,num);</span><br></pre></td></tr></table></figure>
<h3 id=""><a class="markdownIt-Anchor" href="#"></a> </h3>
]]></content>
      <categories>
        <category>算法</category>
        <category>基础算法</category>
        <category>stl</category>
      </categories>
      <tags>
        <tag>stl</tag>
      </tags>
  </entry>
  <entry>
    <title>并查集模板</title>
    <url>/posts/83a4cde7/</url>
    <content><![CDATA[<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">UF</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> fa[<span class="number">65</span>],rank[<span class="number">65</span>];</span><br><span class="line">    <span class="built_in">UF</span>(<span class="type">int</span> n)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            fa[i]=i;</span><br><span class="line">            rank[i]=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x==fa[x]?x:(fa[x]=<span class="built_in">find</span>(fa[x]));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">uni</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> x=<span class="built_in">find</span>(i),y=<span class="built_in">find</span>(j);</span><br><span class="line">        <span class="keyword">if</span>(rank[x]&lt;=rank[y])fa[x]=y;</span><br><span class="line">        <span class="keyword">else</span> fa[y]=x;</span><br><span class="line">        <span class="keyword">if</span>(rank[x]==rank[y]&amp;&amp;x!=y)rank[y]++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
        <category>基础算法</category>
      </categories>
      <tags>
        <tag>基础算法</tag>
      </tags>
  </entry>
  <entry>
    <title>离散化</title>
    <url>/posts/515818b4/</url>
    <content><![CDATA[<h3 id="acwing802-区间和"><a class="markdownIt-Anchor" href="#acwing802-区间和"></a> Acwing802 区间和</h3>
<p><a href="https://www.acwing.com/solution/content/6055/">https://www.acwing.com/solution/content/6055/</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">findpos</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; src,<span class="type">int</span> pos)</span></span>&#123;<span class="comment">//离散化映射</span></span><br><span class="line">    <span class="type">int</span> l=<span class="number">0</span>,r=src.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line">        <span class="type">int</span> mid = l+(r-l&gt;&gt;<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(src[mid]&gt;=pos)r= mid;</span><br><span class="line">        <span class="keyword">else</span> l = mid+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r+<span class="number">1</span>; <span class="comment">//从1开始</span></span><br><span class="line">&#125;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;::<span class="function">iterator <span class="title">my_unique</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp;src)</span></span>&#123; <span class="comment">//手动去重，返回迭代器指针</span></span><br><span class="line">    <span class="type">int</span> j=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;src.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!i  || src[i]!=src[i<span class="number">-1</span>]) src[j++]=src[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> src.<span class="built_in">begin</span>()+j;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="type">int</span> n,m;cin&gt;&gt;n&gt;&gt;m;  <span class="keyword">constexpr</span> <span class="type">int</span> size = <span class="number">300010</span>;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;pos;vector&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt;add;vector&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt;query;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;<span class="built_in">nums</span>(,<span class="number">0</span>),<span class="built_in">sums</span>(size,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="type">int</span> x,c;cin&gt;&gt;x&gt;&gt;c;</span><br><span class="line">        pos.<span class="built_in">push_back</span>(x);</span><br><span class="line">        add.<span class="built_in">push_back</span>(&#123;x,c&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">        <span class="type">int</span> l,r;cin&gt;&gt;l&gt;&gt;r;</span><br><span class="line">        pos.<span class="built_in">push_back</span>(l);pos.<span class="built_in">push_back</span>(r);</span><br><span class="line">        query.<span class="built_in">push_back</span>(&#123;l,r&#125;);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//排序+去重</span></span><br><span class="line">    <span class="built_in">sort</span>(pos.<span class="built_in">begin</span>(),pos.<span class="built_in">end</span>(),<span class="built_in">less</span>&lt;<span class="type">int</span>&gt;());</span><br><span class="line">    pos.<span class="built_in">erase</span>(<span class="built_in">unique</span>(pos.<span class="built_in">begin</span>(),pos.<span class="built_in">end</span>()),pos.<span class="built_in">end</span>());</span><br><span class="line"><span class="comment">//离散化</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i:add)&#123;</span><br><span class="line">        <span class="type">int</span> newpos = <span class="built_in">findpos</span>(pos,i.first);</span><br><span class="line">        nums[newpos]+=i.second;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//处理离散化后的前缀和</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=nums.<span class="built_in">size</span>();i++) <span class="comment">//注意从1开始</span></span><br><span class="line">        sums[i] = sums[i<span class="number">-1</span>]+nums[i];</span><br><span class="line"><span class="comment">//处理查询</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i:query)&#123;</span><br><span class="line">        <span class="type">int</span> l=<span class="built_in">findpos</span>(pos,i.first),r = <span class="built_in">findpos</span>(pos,i.second);</span><br><span class="line">        cout&lt;&lt;sums[r]-sums[l<span class="number">-1</span>]&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
        <category>基础算法</category>
      </categories>
      <tags>
        <tag>基础算法</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql学习</title>
    <url>/posts/f45dd5a4/</url>
    <content><![CDATA[<h2 id="ddl"><a class="markdownIt-Anchor" href="#ddl"></a> DDL</h2>
<h3 id="数据库操作"><a class="markdownIt-Anchor" href="#数据库操作"></a> 数据库操作</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#查看所有的数据库</span><br><span class="line">show databases;</span><br><span class="line">#创建数据库</span><br><span class="line">create database [if not exists] mydb1 [charset=utf8]</span><br><span class="line">#切换数据库</span><br><span class="line">use mydb1;</span><br><span class="line">#删除数据库</span><br><span class="line">drop database [if exists] mydb1;</span><br><span class="line">#修改数据库编码</span><br><span class="line">alter database mydb1 character set utf8;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="表创建-格式"><a class="markdownIt-Anchor" href="#表创建-格式"></a> 表创建-格式</h3>
<p>创建表是创建一张空表，指定这个表的名字，有几列，每一列的名字，以及存储的数据类型。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create table [if not exists] 表名(</span><br><span class="line">	字段名1 类型 [(宽度)] [约束条件] [commet &#x27;字段说明&#x27;],</span><br><span class="line">	字段名2 类型 [(宽度)] [约束条件] [commet &#x27;字段说明&#x27;]</span><br><span class="line">)[表的一些设置];</span><br></pre></td></tr></table></figure>
<h3 id="数据类型-数字类型"><a class="markdownIt-Anchor" href="#数据类型-数字类型"></a> 数据类型-数字类型</h3>
<p>数据类型是指在创建表的时候为表中字段指定数据类型，只有数据符合类型要求才能存储。分为：数值类型、日期和时间类型、字符串类型</p>
<h4 id="数值类型"><a class="markdownIt-Anchor" href="#数值类型"></a> 数值类型</h4>
<table>
<thead>
<tr>
<th>类型</th>
<th>大小</th>
<th>范围</th>
</tr>
</thead>
<tbody>
<tr>
<td>TINYINT</td>
<td>1B</td>
<td>-128~127</td>
</tr>
<tr>
<td>SMALLINT</td>
<td>2B</td>
<td>-32768~32767</td>
</tr>
<tr>
<td>INT</td>
<td>4B</td>
<td>-2<sup>31</sup>-1 ~ 2<sup>32</sup></td>
</tr>
<tr>
<td>BIGINT</td>
<td>8B</td>
<td>-2<sup>63</sup>-1 ~ 2<sup>63</sup></td>
</tr>
<tr>
<td>FLOAT</td>
<td>4B</td>
<td></td>
</tr>
<tr>
<td>DOUBLE</td>
<td>8B</td>
<td></td>
</tr>
<tr>
<td>DECIMAL</td>
<td></td>
<td>decimal(M,D)依赖于M整数位和D小数位的值</td>
</tr>
</tbody>
</table>
<h4 id="字符串类型"><a class="markdownIt-Anchor" href="#字符串类型"></a> 字符串类型</h4>
<table>
<thead>
<tr>
<th>类型</th>
<th>大小</th>
<th>用途</th>
</tr>
</thead>
<tbody>
<tr>
<td>CHAR</td>
<td>0-255B</td>
<td>定长字符串</td>
</tr>
<tr>
<td>VARCHAR</td>
<td>0-65535B</td>
<td>变长字符串</td>
</tr>
<tr>
<td>TINYBLOB</td>
<td>0-255B</td>
<td>二进制字符串</td>
</tr>
<tr>
<td>TINYTEXT</td>
<td>0-255B</td>
<td>短文本字符串</td>
</tr>
<tr>
<td>MEDIUM/LONG - BLOB</td>
<td>0-65535B</td>
<td></td>
</tr>
<tr>
<td>MEDIUM/LONG - TEXT</td>
<td>0-65535B</td>
<td></td>
</tr>
</tbody>
</table>
<h4 id="日期类型"><a class="markdownIt-Anchor" href="#日期类型"></a> 日期类型</h4>
<table>
<thead>
<tr>
<th>类型</th>
<th>大小</th>
<th>范围</th>
<th>格式</th>
<th>用途</th>
</tr>
</thead>
<tbody>
<tr>
<td>DATE</td>
<td>3B</td>
<td></td>
<td>YYYY-MM-DD</td>
<td>日期值</td>
</tr>
<tr>
<td>TIME</td>
<td>3B</td>
<td></td>
<td>HH:MM:SS</td>
<td>时间值</td>
</tr>
<tr>
<td>YEAR</td>
<td>1B</td>
<td></td>
<td>YYYY</td>
<td></td>
</tr>
<tr>
<td>DATETIME</td>
<td>8B</td>
<td></td>
<td>YYYY-MM-DD HH:MM:SS</td>
<td>混合</td>
</tr>
<tr>
<td>TIMESTAMP</td>
<td>4B</td>
<td></td>
<td>YYYYMMDD HHMMSS</td>
<td>混合</td>
</tr>
</tbody>
</table>
]]></content>
      <categories>
        <category>面试</category>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>面试-基础算法</title>
    <url>/posts/627b00bf/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">
  <script id="hbeData" type="hbeData" data-hmacdigest="a14919f93400bf8502a2d266a3baab8eb91006e79700374db730d4326ecd3fce">ce77eb60cb392a7d1958e79566e02905423f78e38ab83261c3422aca5caecafe166d1a51bdb1622d72a1bacd2b4432527db979feb41015af2afe3ce1c2093fd73296c72a221bfe13253be96b3f3b9e4000066f12a5fc310fbf33c3c9aa8568f0ac61ccf1483996c85a825116a79f5a04a0743b62f4286c9c9aaad62d2dc224de31787795607b8531312f96e441843dafd7eb06de466ebc3f4e95c7cce07170f2b728aba877790501b23de57085b93a22575c2dcc369df76d7c076412e5f850fd91068bfad857612612a06e8a6b04aff8482bc297bec5d64e5ef7489b30aa4e16be239dc98b2b8adccdfc84a0a050ed4af25c82a9a6751b41cd711ee0f533a9a5e942e8725f55af5f2c5704bb9f630c52d8dfae6cdc1b4306c047a90677cf119362d8b75fcb4403e6cc403355229221bd9738323ff75f5d826d5b7d338a2f1ef70795e7e32b29ce95156b8bced5612d6856565e8b8bee2b8c878a6c1942356f941c70593c6daf0c9aa2a49a161e915226728729e22b4cf7674c58b4597f42c9eae3e527733f13f4fbd0040406e32e1555b44f33cddf1f60d5d5fb867628acdc260909bd6e5787cb3a2fc5f93d582595202595bc11ed6e64ff294daa9baeba910a3fddd8b2e55113796d3ee0456d6810a4cb09a0e462aec282708ce2bde1c67912a8c17d844f57cce3c36f3e1a01fc5c636a55e0134b4b4bc247d761c2942bb416af1f769e7b85b98cdc1ee561fd67fe9453b14d89b1c1bef4d0cd0ed6654461044afde27d2582ca361d785103d2838b70dedb38a8b5196e78f8deb0692d8ca73b497639e46d369877e1a52fdce46e3a3ec7c62e9a165b620392411a798883989052c7e1ad392f63016e2dd4f0d3d8b00b6c259998a44b5df21ce749986b6bff9dbdef7fa58bf50f6f394c6228017b9df0678f6478537642844a526e44735e5ca9b3a3ef7c73fa6c8e0c1a5016303122fb57f279601a2dcb9f84fb5c0e9bc3f454391e5d10d5a9f4ebc5f07845ce0bb730c2eb99afdb106b30067975a7275aba221bc0ea555cf49be25441b808f537a5beb784fdd90b41df6cc1f67039eeb6d46ec0e13329e0601148dc78829df097c65879b2018b1e34c30604bb3267cfbc5518aef39eaae6c5daad894ef8f7f9dac6f488e1f36bfd54f06e83a9dc1c2b457b3fe99c0508f0bce16e5410d352d55e9914f66e603f1d49b142c0efc61fc7892abb9099324e3d7e96fec6e290d4c68befaff348bbe0fc2661971574aa0fe61421cebad4ae722f2c75c4d0869b7f93811b3ece55d5911ded6d86ff38ffbf9099ccd49d2ef4ded8eda536d183e7d3cc8af4f7392e49c29b289350d5fea3cf44f559e2ba6f04bf2fb1eb2c3bda16e1c676eb49c51ce87d6c0b9947a980e893490b0ee9a99486d5f0a769fe102ca99cff017b353567c81d326332c77b6b4f90c51c8f1318d4a796e38168bbc29f342d8edc7b0d8ce5ca1d4f4b43abb1033de4b2c3b6e2af2c3f639043ef37300e6aeaffe26034a67b5e0a171936a2f061d3828243f2ebb2f49557e1d09cf5532200cb547497d22066f17ec2218fb15c6b8ff16c100dab388965425bda354d62d3136b6a818a85f6cbe2d15f606aa38f684212238b63915d90dda8b4080125cb295320454f0e74bcd8ccbef5afefad20b5dce67178ec59d2b84d84d61bf1c3028682d103d9814c0d6e38bbbb473e399276945d47c6430ea196b4fed09139bd68b7d655caba94bb214710129516950a2aac042e00a492a74b91eea9a5a3dcca5fce8a2d335b7bb5cfe9ec835ff811dc9068909bd6a58c34c0c6212709d7b6e327b615eb4b64776fb6a97d47d4dced5e00a3762787f3ab5b001805e153d42afe7635e26ae2a034cfcfe1d5d3a69ab04a9cf8a32abb6559fe02af17d6a6735d2dd512a8979155a5b4ae6ccd09c0299a2b71e586f4476a35f182d9bb04a5a32f469e24ba25f12efcd209416d8e6b97b8ee4bc7a111343dbc30e9b23a9cf2b04527221b67313c9b00595b8b0efb803059855caee48d386721e8c262f86268d1f3676d5009b26907c345e2609fcd2749ee311acaea4509eb7846ced9586eb8fc0bc150877a616cd5840ae3f3ea9c0301e156328626439b750c0a84a5a76bbd887aec489668c4dda1d807c17ec7bb49c1cca79327ff11d6d0e964f402dee8430224fae8861327ba4de89ed2579ac18318e6788043d1dd598c5335406cb94a4bc5e53a8f3926a58630f36c0f0578e5448fe19a5952fe87e3fd183d4f3a9e3b4ec92460072bff204807c4aec10ff3fd66b502b6e48d5ede71853e178c4d7a4756ea16728cdb26879172fc2303df42789c7316d7b13e907ffe497454dcca1c350a00fc357a3a5cdffc50ff86c1e92ed1ee783f1492fdae68b960d355de31eb093ca4c0083caaaa26bb35f4b1682a494976e2ca9dcee73bab3b1c8153d19d8fb22980dcdb9d481466ae8185cccbf53c661d40586107d1b915c0e64d123744c04525efea74678244ac9b4b2e5f3e0930fa2dd1801975d4a03b99b86464ab4f3c1c64f7b7615ee6b3f1af3592ed68d07dfa0376c4e373ab7116e2a133b3dca323217e3b077424897f3afd0e16e3d3639537ec6e61dfdc462643cea007b5e107f652247024626bdd9620175f3b0aec2bd6d79ddda02541ce8ecc9eeb850d33cf91ad7ad55ce0cfc756a6513271fe431c5951063f7a7fcb96a70262df1ef624c25cbec592e6a6b5d2a86733c44d7b86b3851a886152a2c973f27c3cb34bb525024e8758b9d39df193578774302b377c47c901a10899ae89db74714bb42ae4ac15edb6ce75d5f8b0d5debab91d4d31ce0e9d531b7c7677243e0a7b7b54197891dfebab1fbac8ee9cd274e9a234307e227e4d1b2f6f754dbcceb89c6ec9e94409c0fae31cd6ba4098856b88d32319e87a40f9cc072e6bd0a58ec818ee217ed9f88bfc2bfb8e6b6731dc4e7cf5334b88d1f4660a24301a8f3d0e0d960e7f037c42fba34292a9fd5d80cce8c8104268d475f36d6bc7fc7bcc632ef0032076baba5171f77b77f03f0ba1a8f8e852a37c173b39c6b35aa3d89d61b895c0c3f56725467e48a94c51d107e64ee79e4b12d7bd0313125d74835f273a82272d8a31ac8a734737ee569052f6656dc7052b9a9afa828cf1c738a1c51e6e3690bc76216c7e6d2ad5fd0ee3d6a50a29973ab5e51650863d7e7e6dca8387f5269e7a1c4b4780812cca24b06cd95dadf342a777635f0e4ed57565c01d30f91e54992fc0d077288970dfd5a5f24082021c25ecded7a8334f62a0d37cb120098f84bfe7e421e0ebeaf0bcafa98d0fc67ab30a5338aa2b788c0b3933e4fd460352a49efd24b95f907e4e0c61286a3d757d8f62dceb96abb35eb526bfe541703e8c6b548d8a95b0cd84d2b2fdc0c1c93c7d9327a206a4f1cb51709bb900c98c99cea95672a6405d150ab86bfe5d53885275794bc8602d0054aa7130b4e2af263e7ffae91dae94af9331aa9a6d9772e85fa1a83055e4775d5d2a4f8a5a5464a26a36dc9dd151ef200b0d6480c9c1abcccd38725cd6486b1ac01be0cfe0a462e66f2addd6e94b491fe635cb56fcd255cbcfef592d2ccb76778d10ed835ec6559b0011b594fd5daac6404b415ca5576f98cde78ab0160d77598f6769286198e575d3cb0fb8186fa23165570df11173cd402ad07ea4e7f41940cee4ea26c6fb5774fbc5fc092dcc466ee060d5150b5badb67f4bea896bccb11060dd469bf252a7c0fee4cf07adca44e2d3b6ed21f1ba36b660cb7eb9812084643f1bf37c2fcdcefab940ab295bb5dda1189e893affb8e317dadd225aadde32eaf86fa6ea7ee8fa4c76f385a013a9efbc15c69166a15ac91551ac8c552777e8dfb0e20337800b219a05225501e02c13a8d20950b94a77b269972e700146fb1d73ec580a6da2f02a3c3b400e9f04115cbd8440e5b148afc20e088011c219b16ca29b4f48daf910dfd4447bcaf1ac1569eb4e248e6b2fd1cee1640e9f600dc45d815b329b998da7fd8c17b07ea068685553863d1961e978ed8813d11c86ef19bd7dedd5521dd820226469337667f40b73b84fa5740c66237e1ee0c6ef9a9a2d9298afb8f1905bd00d1da4b6dc2d7580e4ea7ac2085ebed107d48085cb5126fd44bc5a69b4d77750166a78a11cd722a4fb06e8317941e4bae76351e3365f9ae5c62372fe01d7341d858d1c815610f1e77ad6cbfe6e9a3fa432d58739bf520f1b5281098409b8a0b7ade4b24c408c185262eacfddde7e573bfe00ddaaeb47d75fc9b8193635632b1710cacbf9887abefc859ecef2aa9788771707cd418ca78bdff4a50392803cb77af70e191e8e322041d5f2b320ec327d18cf1af1573d4e41a1f065aa3393544ea4c3c4ed04c4f71d93f8c86f1e2c83c6ca8170ab4c4c67929d59cfb4aa9824228ddc5c51ef53b2c099db3094c9ead173d01dc6bd4d20f820275734477b99fb35d1403d5f382b3f89d2cab816b5cfbb3e834f36a5a32dbe2815d517e9689ebb052ccee2f8a119e4064c98ffed182a1833442e00b7f73a78da4f1991521dbdb9e5d4b5220c9e37ff389ca11943749149679896cc8a3e28a158e5cde53ef502a95f85948e3fb989e02d93d770cf1c4742d47a380c779fae07731eb1708fba11c446ea46a07f3c3733cc68bd2aef46547ccd40988bd683a6c74ad2bbc06d000ad199d09b6f5c5bdcfdb3990435fcbcc88bd3843198507e556963ba7cb61bd0be4801bcd005b5c5715714361d968f4b2e5a3d11a2d7750545451698e2a8d353c1dc44aa11578fe1dff5bdb3dbc7af8e345ee88a1ca77c28d87ed75604e35fae526e0b0ecc724587ef6627b008de92535fffc41980d25706aff6910695ef90b56a475e4eaf0c044d7e548d324077f1ca0a24cb7caaafb06ed72d80c3f9df7613e84d489a1977bcce3608040b451be154021ef610a44617a1979023a410ad6d75eeed5bd5a34ba975d5ac011b7d3a04e8c7f48125e8ccefe0a6f9a64f90522552b174098a3c8860c3565f1155333222d17e183eadc9e1e886441e30584410f4b7f08c1ed2d08c1465e317aba47428b656a2cdce2eadb2b2dd2ef82b5ad77906932e908594fd829765e2679ef8af626d4a8a5e696db517b9a568b6e5c9506016f87c8eb264680f3d8aaa500d866f8e32131f637e6cddcf5d4e3da63091b85fc6127da11d23666cd38f0f6409c9b4c4f1be38e9da04bd197dbedd1f4a1e94a26d9ee1a72d5c6f55f945c595672cd8c8c8ed12c085bed3bdc3978611e634e1d82da1929f1ec079b905d6c0780ee5c03a66c6d2cdc3503f02f38d615bedc4757df150155d4dd56abbf6fccb033fcb3224fb377d386b43c4e083fe67e299502ad34d4cf1eefcd45a0502f1bf9d7a07e60615301a6a53918e10638e5405b64cf982ba2f4b1c7a7e5d0187cc94e8890b4f3107eeb0cd527fe9eb6f35a740f30b5bf13576c8a3cd46bbd8d27c01a6e4cf9cda303c7211a6ca02068b3c04288aa40d24eb1a4849370fc63bcb7043e0ca9189143930bb87e78226ece6641198fee4ef3db6ac3446861bf84008f2caa7d9eb7ccfde53fdb15041c7812b9d05ae580ca08a25f111283d5775a53348d95840113955f37fa55983c614dee69628e89f6fb088a143efea8caefcbfc39460f80869cf838f5742fdba3d393bf2e6d5098f4446a2834ac0d3df884a62ac5c59f0fce8315130c9dd0b341d1b07fae985855004ebdd0369a30c823b5716e5f888c99c275bd6bd166f425974ff67836bea075d449047b25fe14008f6c30983897b7d9472e6bc96d810eace447e9ca445261cb8bc69c193f95d97400fce5b7c409db678d83f109b633080e5e640666f0f9b3d830a204c2313859180e07498ee2963bfb11d5f41ab31be04e8d4f98fa4496078efd8d33a466a3797b7a3455acc91211c964549aa72277de8a9a9b5e160a4c573aa025be4932a854f688c48b66ca57eddd8af7af9bf70cf969a499d0eb30bcdece456e519eea51baa362c3de49799a51c8b8551ef0c0637788e300ca0402d754bdb7472d1d08257c8a61bc0f9105c9ac594788ec6fe4a265fa9354debccdf76a0439078944ed0e6dcca53d3fb258915bb5a57c87cd314f009794979c6104fb4eb84140e1c9cb9aeac832bf8a2ba1a66cbb3c00a0541f4b0a0180c4ec6676d99e21afb2ca634bd552cf44789a84fa4951df110fb036d664777961d057261ca9878228ee9206316d425102e78993319f98bff3a46cb5e1c1fda0ece460be970f61685ea884c148889f82d83613c9f5e6f5001d12b41138c2e95553b79b1e511fb5c8b9771f0cb125f5d727f10370e954abc0ca7b5b7825d882e291ef8f4154152371f352522417ddd87ebf38639c5e4d6dcde2a042fe38b9009175950abfd60b2f471f3c5dd9d776496e741f91434f6a541c923a273dd36a92593498a818f1500aca5ae3075f6eeff66728909b33c091057ac710295f1c165dc8435e2886c2244127adf52170dda0385f53570a392bab9d3e76012db98b0596cb87c71d9c32fdcf03e8e3c4a079fc6faf145e99338963c374a66f7117c21e7f6739c9afda3f7ef60b5fd12722e212ed3c16c5bf04630e7d1a859f430abb961066003a00302eb2666ec2f678268352137a4cf5d5cd309fee7827ee91f6adbcdd09c1ee899f05840cc204a011e0f356237bf0ce04dec91b1c9a898d932817af53f2ef2f9a4a62577dd56617264cea0e665e94ea21aafc5293279d3884642d40106d61215647acd8e83f98f0e7b2d20f4fd6e7a9b6c8988040faca1da6ffe9a5a21de06b74a446bc68cd1d77afbbda0378ab1e6a951b66af4d300daf49a79ca439ead2867472d12b4ab71da7d4f8d9e52317fce9c7f84918651dc9d0abf5c50e4c89b24d2bf389ef3a291966a4bca0f0ee25d8e5462164043b1b1a6d7974dcd3ea5206e1006a1b524fabf8f9ee67948d1d8b1e70e02d385cd42019ff2478d5ce4429b7574cd621b5e26553a8b87ecc2aea66273d0714ee1f469378836e4f7e2cf77ad06fe83201a074abf2b15b5b25eab055e82709a19755899e320b2b156c24972e227b8b723a37c61b8bfc8bc54c8966dbe355dc4a9505f521f6104ac4f750182b19d60b8ac36e50849f6da276ac2ac7ff9aa9dd33a132c1ff4793f9db2c1f99de25bfb69595be639242f8aa23b647078ac38e3a109b7bebeee3a8011e968dd7bbc06911bb5d81d96710df369f86099badde5c22b440b0007981aa38b12f715a91a6022dff72664b1b01c458620ff2d147da385280ff36cf5b43bdaffb5bbf68794f6c1344aff7dd7c6310ddc050a72340ffb92c35c6da6cf17b6d6cb09e4d03b69ce62f60e44dc6fe7078db8846a46d72c8a74ad0cb56c8dbc2f9b6038a598f25cc5f125e29bceb7f742420226f86c522f786186bc5affbb69f7e6c6c6a4778aad1aadbc8ebc900b7595ba1d76df89d3d05bbe578bcf0157cbd79c96af6448c9b1173446f08d90f061e924c1a1c5f8c1c16208a5e90d624fb5422e2368d1d095db007b5117ff668b7d502894c42eacce94de91b874fa0f4addaae4188d69525c25c2adff35d73ea6a48149954c801c430b9227175bfff800e07581350fc93482b18598def2b79b19ee6220aff500e1501862cf00d9ed4f2fbff20c481d01a7c0793660220f1aa004e372b8d139db5e770f3dec91365055e1cf966e7c6a7eeb3a88321086576311545550acfb7aa031628a008a72268d16616fe4eb057b4b367f5c2653f8a6912103b937316ece0cc234a233bf7bb487ecb916e914ed63cafcd7668bb23d64c4ec20d5916965a20f48c72fd41b01ce9d5e6c015996f2c7ecdf649ce6aeda22b75cb7f7525165ce9a68bd377c7c62c91d163d6129a76eaee15f5dd54b7955de067e14f5ce93f4b258637bf638aa6e78c62610cc391e83c8543605104e0afa35e7bafe6eacadb3852d6c986db12255ac0df220817e7266dbf926d3c965876a8657ff89922cb8bb92e6f465d8aa557634951fc655580f733e810e2fff93c5b7d8bc64be36492111fdff20d64df840a7438e0664a97e029aeed94b4fef3c7d0f32596dcf2b9fc0408ac5fa765beb06a8a100553bc98ce165cb60d6bc9fa1dc48f70e10eb5c1338ab9c27466f239e89ada5a93e56427f11370d76e2e2f6be1a3e1bb4d2731a41b40f2e0dff9534006aea89ebab3cc3f71214f2c61144c0b7db4f39b5d767cd06a4bdc5fa4f5dcf6ab16b98945c6a84f4c220fb7ba906592eee109af71b99bc8c6852b4f3aadc8e591cbdc2c85fad8b091847879125281f815cb587672056bc8bb3dc7107f00ebe0720b9773a36671f4ed9e8facc654c95fceb3f44f0a13a9ab7385a22665d0f5684e5a618e93b2079753e54ee403dd3586901dac51933f3dace13943d299d38624da7520b6779f18b80fff9e002bb5b22ba8046d17408a8e21882e07af313269852c46ea0cf671e8d583a2051d6e5541fc6a77700d72f174e093852b4380416b1e76a5f10072ce77d7264491e5ccbc024a5e8f1ae4ab961cfcb8824f870ebc8a51524b8ef6ada46fedbd761f0385badabe3920d21fa28f27d93341f5256890c38dee09bea4b873ef9fe82eb6ae0522450a9e82152401fc3031bdc04e65a38175b2a331f2a30420c53e98e651acd244d16617db8237a78795b421067a1ed87628e4da533987598a9c29ba0ae54d9aab0dea9476174f4e03263f25657f973c387897b958fc4763e07483d64504ef013ca9a480a8ccb86db7b6866b9ecae752125c12fa6f5e18a25172f02f3bc22908c42d831defbb6fa077048f0361673ff4a7db782e72d4d9c081a97c20dee2e1003f34b67be9550136ca1ac92c7aae105874cd62fa84a971423cf5ff9c70bee09c2855283e02c44a56ad0c03fb0d685ba8f3896f51edabd012c8bde4089ec115b5c1913f2f7a426aec38c94d38c3393b255ff6d979f0f959cf291ffbe8a489cefaf6a949ba8e12af64f031a4bd54aa9e81d68388da4a199a22efa9627b85a4ef8a72b8ec651aec3d42e3daa3f5b17ba5bd71d50471bb28e34749126790b162a53802b17c60cad3d407b3ed9d521ebfe5e06f83bc15eae2a529acae2e56511cc53a0bb863ed6a1c95b4d8d2c1c01aff724ab5896fe06d48bd2b3e21c7890aba54fe996df123982bd718a34b5e66cf89f059df5f15ad481e79f14819156c9dd7a42a40332138ad651f49fbb86c5fd7d769e26ddc55876678812228bf7f0596695f51d2271d3a536dc2b2da9cca6dfb9f40ff47858b93c59b40b55fc4729742c01fab73f3e22e9dd9174e4b57d2031718fa72e71c34f651b97d0e865867b255dad46b46f9f7bb9e4bdde2efc225bbe986cc65bc888b2425d819d43e652016a1c88ced59f0cd8787896dc658310b408940fdd356d60ecf55b8ba6c837cb2096c16c52da0b9dd50baf885a03bff29c7de28934c854b4e670d1e09865f8b270089121d4dde362fa45f82bd1867ef8e65d022090c07c452f4dec1dd75fa9036bda6e6cce9f0e7761ec410dac94ac3b8ec33e9e05ecd1e904b2f2f08ce236f4867c144aca7e77fcbf5054f4c61acf793f098848238726b15a45a14b3667a82b30a301f4e7e7c20c06b6308996eb2afb54f199c2d1c0038f88d08006dbefce4b63f9648ff622aca8a3082396144ee2e3dab9967a1e8e5e6ab1ba32c50cb785b2ad033186c7bb5f303f1164facf7ad953fd468e49a78d7c869be271beb3a8b1e183798aece89d23483d8a1e74f08f25c402be7a7d5ea56aa5fbd38cbca4cedc4f6b288a9dc3d055be03b723f5cdbf3e75ddb4ca9a9a5912f694583c998f19ecc47d737091e046e4a50c3ffd2f963c57dada80030718a3d20ae1b43f60d6e4c2dab865db6a81e627266a7b0d24c38e15bb35ecaa58867dc16ec37ede93d09fed8cbe2a6655b74d78b42b41d5675c5a5f01679c8ee0a1e9b52229ee9914dea84cf6b61667b925f2abcfe42aeb749a9a4e4733ef2499a1f2abcf463e4e3fb1a41b375159f65a718b262e4cf8a48bea7d50cf2618b4d88d45b0fbda173c32691e01b3f3d4ec3f5a8c7a5aba226657cb8876aa9e14fe8e7436285e43c0c60af10fe9da9aaa172253156892669031c24668fe2839bde2c2f3664907fd58d00a28a77914d90de0df3cb4216e22b54de9dc8c9932b7fa8d07b848cc0615c3dd180d803fbfad6db0edb1a0fa26ee6090f26fbad116d2847de5b9bdb49b424d039daa01386fad898f1ed1aeab12a62cfbebe8a2a465e6aa1d9cb6ce5887bf26caa004400da55356871d8067657c693290934f99f4172814fde8ea3a0192b0b982ef55cce46a70bc975a37274f8f95ceb34b3e8e754659776cbd6b3fa3ad8766cb34d368f6257580adfe0d8fcc051652acd27b9c0845c4c564e29f606c58b183ad8633e1b68c9b69fe7ab9d42fcd12e23474e50f9a20f998765ddf4f969dccfff503cd90c7262d1436e270a8e00ef6f96f852f53e5e9122947c03fc1a03afc7ce8123c99d8585cbd0480cc596c046b724160823d46d5b7abff930c71801974aa23ef67f6138f063930a4a42699b6d0320ad0d34f411198fc91457b2ea0fcae9df0ccd6ddb502515491170c3520a70f9f68c9c6bf553f1cb1486b457ffc8807003014b7b09aef8d7dc208475df89f899c71848c56514d61284801e1c47a32af525a46f165291a820b6962131c929a98be08a84cee6fcbc0feacdbae16fa7f9cb0a761b7095d85b3562197d28ab7790064db00d50414e9749a6c37e3a759b8b8b255c130645de37513ddcaa1e194ba3e79377dbfc283febcc0f566775c0d866020b0a93e26d203a2637bcf0f089013ef369605a423c5794bdd972a08748dc041689a72c93e6e6a3e56eb18fcb2992ad0d95eebec5c6d3153e75afb5f3927289e7596c19f6b221e7c6eed142a206010b6f2804b3465404434f93032ee22e6f47d018f065ee2dbf3628dd314f30dc44b7d9fbe80a3763c8fb0635992f9a37aec190ac8b342742f06e922ffee97a87fa91a3dc1467e579351e98f737b58a67a46a8100eda376d445c92de1859f68c7ab97e75911cac6b7f8a0b63d77feb606e1b737a3f19e2f551db59f4187119a15392563279b4694512dce603c79948004fd1e34b10c72b5318a7a33c17540ebccb760517cbe50fade384cc338d8f3480544fb7f6065a50d74299318f57f6144c37442924b7a3ea6b86cb4f544b645223a8bd322ffa5063171b0293cc8f752ff07319f26a7fb06b47b57066edde72816e0348df2aac0a18e74693a3220993754db4f8cf8df7fade55e35d0abed942896f93c9ecc4cc86103b50f16726118394feaf9cd4d65e3926f892893e40baa4a8c602c28643c5538df51895e7d50fec8bbbc3d7c36e8b095fef57239945d71c019f236d873e57e745b6d58724d4e6033da717dbcce6118faadf80ca1c3e5220ae18419573917171f18fc6354bd5b74ff5162cba59dd05b56be3e0f04ef6dd7e2064da95b2302f073618c5197dba1652f002cb653c63bfbeb77e3f0df2cda4fc0f257271efe25c3ec2a028870f23745052b9ce622b0537d473e0f29ecd5c7325bc9e26a36ccbf1bb8b8ee61756cf0268f037cb85dbed1039d66dfe71336102707dd29ce461873aea13b78e2452de6c38c0d4eb5f8d5c817e1c30e5ba83d8346a26d3c229b70e0f1bd670dd3061e193a2b56a18a52dbe8aaa59f467c813453e813c46b43c085e56704b9d05c00a88b43e469787b32e39067d288e3b16dbeccbdbefdd1c3fac268b0158a849c59f5a470ded84170c0777293a28073a8cfeaa5c33fb69afabe292886404cd0d2024f207b0bb574a1f6f37895ae98a6917d6b625f03f8d6e7e755778c8fa57a1002b480fa5c6a4c0f92c569bbc0d81067fa6641158cf0a1875984782caeb8f1fdd14449a45925c10d1fe8c14b1136f31b79526365b5df619d3299ece7b480c7b99a2338728549301c857280ee0050784f24d35ceffca75a079c3682e2632b950e90df232019941ab7c1dc63bb26af3528d2c7ae033025aacf72b91ca46eee260180da59189eba440a7a1844f34d5fcc95549422aadaa99b4a5b3d93fe2a15ec5b808476cb12e283ba1c20e156f5f460e14fb49c5bb568c0ea679cb7bbb854e61d97e63cd2448a4b6e188b389daa1000003c5ba9d0360202982b723d217f3dc3e28d143ae17e83465ab2ba9243ae3c0128a07cbce213b8740ad78da17c78111bdd6e514d967e2c9f5a03a3d81ceb80930ff408aa0e81b2f7c1cf0c572c1a9736187059381c166c5e32743beaf8244b921d0577b9847c461beba1646a05958fbdfb0a4019afa52042e16eeee2e17d4ef13167898a255671eb75876226501fef8e6f92c21095c1f0af49aa9a9c9c4198ecbb7affe6997f3e4ccf57c0a13f5e2b91d8d83fde5fd990f0e6adf5d7cf7bf484f5b43c76d128adc8f8300cfd54c49943b081697e247f2fd200e10a862aa4110843c71f367defcd486ecb39582f2ae9f6cf22d97218e0ad9de3fbe6f8497a65e7baa9b11df624659621893ef4b89599931478ae0b2b54d7ccca641f94a215bd3e4f406e12a57e3c87f1672172b6c018329ee0055290148002f79dae816e1dec7fe20e158aaedfbe35c36c857d95fcc778fa3929fd9e7c4a38a5303d6b7838f91306401e8f63566c2bbbd2e9842eb4c61f36dd5746d3e1a18058284a5650b8c115f2401e47705763ea2ced0f2d3af5e969bd186fefe4d810e2978065545ea39a6f5a7554fcdee47bff583059928b825dc3c7755fef2e8c6a954565854dfcbfce7d81f5a3b5fa18c8dfb86949e1d04401fe6ba415a7ed8795f509da563b286d2e3220577d964db3893613c4697b84fa52291102f7f731824e73bbbdfeb0d8428f0653814537f396c46c933ee299008e644ceae08e6996004e6ab8a43f38d4751d3ce4698981f5b0912bf3de373e1771dbd7dd0c5dd9b0255466f02620b9db22d1f87c9da3fe9c434e2523d948fc4292c54f8c4b93911d781a8329458b8c2cb255d8b2a88f652ea27ade17404dfd1fb4a7f17bc4c9d1ee07c79a951a0a83feea4f6151415b4adc3d6be470dd5866f670839a529602a38754652a4cbe0d278b027046a204a8792406332ee0e3236f9c6c670ca57eba22528fb9b93a0552ae165ed00e3aad43ffd609d4798526c9efd84408b7f1c9e74b0131d08b1266e4b14803c53e603a0cfa2a8e66664614f46ea0a8d528b28e9f7dd41e556327c9d82b4ac9e98f4731c56a37a9d0a35d92570bb7127f4e1f7339b5508e7675e505e5b1b47e298b2a0a1acffb24b2085409c975f880f16b27371740434e92ca49a1e34588d87ec5c424d7a3bed5159895a46fdbcd90f1f92087b52722e666dffac336477139eeae0519061f564629e2ca901530f6e2f55a6a84f2067e3ac0981c66327c74071dcab3ece931a0b6d31a551606b10e1d4d06dbbd2ba8f741f49bee4b71bbd3570c6b39bfd42a7285a509e212283062e1e9de24c9bb12a95f3e6533557c1241db55f53aab42c3575b9956a4512508f810764363b1fbaced652321257386e6cd827506771a1e3b4cc22412a2fa8af3f1e7de9490b93fa684a4d4c68634b46eac0a46fa1b439c519da686e9dd7932ea795a61707ceffc76cc9aedf0be709e653f278fcd01f8e6238ea9de685b4fb142e796a530536a2fbb7c3bdd9da76fa194d281dc8a0334e3d803bd0f3b1ceb63b6a0910571857cc2eb34d9a8dc2d7ecbf5958c1140b5328d371dc9afeeeb7caf68f75e386ef18db1c7f2c165d5af5fe93c9b56d700e3414243c78ff6286ad8a3f38e85dbc406e3a976320dded940cae87e522d12578bd08b1daa8bcd351fa39364e33ccf5982365d7e7b02053ecaed7d3d979d49356e274a4ef6bc7074f66a6fb33cfb0eac7fe7caf31956c699dafb9d22307e6759690fe9338e612113413b768487832af0a66122df460831444450aef458e7b6e2dcb36ce30b44557f2f72608b06e5c5260fcc7a82924d9cefcbd41d4ddf7e287c79eb122816705e823c02fa85658910b37a05b379decc57b6c4708ad4de852a64ead2c5308b3419433f3a5fc70762a2396b21cab8dbeb29e8162ab2d97e138a8f99978407f1070e723b0256919492184ee1e29c4c724cc5de075d43160ecf0ddbe7c1b19cfa84e0d37e20ee6a6692b4431fe1eadf58f04c1b67ab1a4940c4738fd9a9df479b653b63d84adcae5891d20172511877cca514ea011d339fdd923ad967af8a4a4124d33cc9f1b8a8f0b006d4c74e7e76006f87922daae41e58ad9f4facbe1170dc20337411093f931d7a7791957ba933b2e37e5f5c3f599684643b5043b6db6f30102c35f3a1cda23d6f758a977d9870af04d850c19e6c99d96755e8b901de657f600823ad34978362b9be04a599d3f489e6d488be8d7c376287857685bcdbd31943a718b6ae0ef354f82fc6dabb008b7d970949b0e710f7e561f59a25bbf39b7e442f3a4bf00fbd01210cb9271e0168cd8fbaf3a718397ef38eda2eb6a0b7d3ae3c8183f56f9deff060f28b8fcf6ff9761ced0654672901fdffa14731e694a42f6ef33e5127406f466206388e81a6f4c12564edc5b298be4860af588dab725491aa46f6e3428b7b6d4fa4ad42c3e8cc9ccd6bd3a72dbd36f9a0036e24a553ddc50d9f9896d4970ad57c2287ce50fe5ca3f7da0c694c81980af421112158cdb6c54a5afe70d43cd0b20df2d19b502f0b2780651ddacf163f78210dc606e637f586d3027d0154a67a7ea9ca30458a4461c1fe80680e1408099c3b943ac33172e9f612f73f839b8d817f90a44cd33a30804d9c00b764efd24b4ea5f34cc8a4e5173ce39bbb7d66dc8ce255b13fb02208d754e23c413dda84b1c810ad35dd1f73562d61360de329182d329c33a63830e47a779d18a48f2cb82b4665fd1e93c4dee164daf2d2a34b5e6e456efe22b6a92abdca54e03136ab23b98f77854c13b6d0bb32853c00f3d0d322c59ca51f63cc5d94d89142a3ff3be45ac3e92955438929419274817f7079075c05a48c75ab2fb393643567f8dfb7357860bf36e0fe068671d405e5aae59d7633b5a9614d55f69d732c4939dcf9501a62222a7993b1bb403da7decbc126b39eda97f79da485f21cf8723161c8936f8153f2519f333c9b8a4a65ca0f9fb202136fe9de67f9e2abb6e60df297f8021cf63f9905fd44c2765eb5627936c87cf5ed6eba20608a2d0ccc25aae14065c57938d501c10eeb560b915117972d47fadf64b86c1b6be5a25fb6c6c2498aef91b42379e8b0697648cd16b8fe081f7ae0b6821d89d75635d268a3b20463b4eeb5892e599b05aa312457d38d0339cb8f607b98d6af0ecde137ef96dbe0fd4964581a41a4429eba49c59aac925194e84c111300c9b93b90a7c4f19361906316c420a40fdbfb3ac6ef7f8e91a4a75bd83e8efb899cb86b503aa7ac05d3ce5d15d2500982d79fbdd2196ca4d5f5a2eef4a566b508d308d804ec70c3f198f4736a4c910bd572014bc8802d1157635e899f80c7f3e75b5684dfa936f2f0b5b2e329fe7d0592221a6f8b8cc968eb9f6cfd339b1e075060d1bd6d10667214c10e0695035f5eb12ddb85077a54b69e1cbcec680d2d6366cf8e0aefa18e99987bcb3073518a419f7f28b363b30c3636efb1185571036c3fad92c2bf69ed5acec19f365118be877ef1b6c64c69e42081b824d5a7d97526ff77e8602b571e8829ad4b6e719cc1d519c2f7620fb6155af73f77c06a720f2ca3f109a25708df90135b9d131e60d2bee202cb6e2c5494074effd6b9602a360ed4e1cf3e31dc4214c076ae5f4fc6fb0aca1bdd040df59b02f0ff90249a077bf2d97ebe1c8b6f4c4207ffe8941d15305e8071e31634bf7c6aa60231eefa337b0596af9d506e76949637573fbf7e8221fb2d0bb3a6efab7add53d8b5254c6ee35ee4ada17facca2fe0cc7f517fc4d269dba88bb79e18385892ace449072de5278a805d53efc4ae1844a3887def6129e29de558797f45b23c665ff0c008969dc73c6f6f54b16dd9b390f9ce83a2a51869a6e956f51004edc9c731c85e12ab46bf4fac41ed642d7bbfc17549a155bed7af065cbea51ab3da39ef104cc84950aca145728814f7a74688b6031daf9bca7c1baaccc704e885e27cd098e2f750f1755945b9fd2e3706d230b5cbdaf32f56968840fd3b31b504be34659758299f0363ae2a2759fee94075c91e572052f0c1f5a29ce91145e3f431f4ce11fbb30bc67e1478d6640dfc7011023cebe80baa929683265dcb1a36125a487f932a2a4ccc675543f37a09611a3455d9eea635c8a5a03191c7fd89af59ee2f29a77ecf4dde1991d09d8c4155b56241eaccac698026003fbd9767fe5ce78f369ec09447ed88491ad2c03831c6ae6b1cb95e1c7b4053cbecfad59cd3d93eaf85b47e5b20fca566c42ab8f0ba8defa4f51cfc7c731e9ae17f58604193a2777196182a73e250cbec29d6f3da3cfb0ef69ed664cb8496fdcf4a088999079c9cf29a700e81d8df4530214e069d0f576e94fbaf482236d71eb17605318b897f79d3ea7b14f1f9a0a5287110bf189d2e38ce4f42546c8b3fb62c2b4e6ba7f959aa580902a2674a4f8fd7175cfda23618ef2347ecab92192a94883bf7e9543e388c780554523ada895e35618c3f88699d1290e5ef0c0290f974ce637e878f5bb79e551b946edd4ae64a3ea90a19aba4f21899328462c5b22f451cde80f10667ea9c42b5bb1244e50ea950b24e6d3339893eca2aa8ea0863341c3de4339e25105c0138060d9df14c164c470c98d4bd06e93f896d76cd474b87786786b8dc1279a71fb642eb11e76d231b2c094c4d85c43f48243eb85d1e34e9fbf6a7be7b6cc40d14fb0a3e48e1ebdbe6d9b6af34e67b1bf602844009afeaf1aa66eb172cd22f027cd5508b8ff93e91d4e97ae7189dbaae43215788646036fca4d1e8325dddc55e9c1da342f07a7eb33a3bc695d65a7ddd83889b1b33c6ba4f2dae71554bba12f54a3f179b634434290fc5102bdbee332a3e77c5f31b8fe97cfccfd052a11c619de155b0a90fa210e7dc25b26f0b46649cd7c4e8e7734d79b5816c2e37dc7fc5a96262f8241f7140b0ffc41568b16e5f37cb74f2fadbbbb84317ede6d6944c99e6911edf4d75d2abefa49dc6c9a99796ce6b62dbd60d1521fd9ad8de27be64a9097409fecb6acab3db4827f57b4cd294414b3812d3250e0e0165a33e3ccf52707ee832544da9f2073b389514f7ae3a22b52349a946daad2755283b8097df1ce9b2136b0361db48a62b50428ae2214efdb74985ca690227ff7ec03889411627a8527f246e5c2276e8c3daeab7d5deaabd592136a1829196b4b30c1e180ef40d57e3d438d387f3e4b76fbfb3689a759c0ea268fcae1814108762b0f4ba8c1d7d49f5f570255e1368903893e8caf938b9227e39bcf0f64077db3df3f25dc4917b6e7a8fd140af3a79dd1a508b726b8861624649acb28ac42aa489da7c4ab16b05d47eed85b9e229a0787832e44863a281dfca6937ae115bf53e5e7d2ddce89571af9262c05fd36ec30fc31e53dfecdaee0dae2c326115f0bce32e7422b89bc0bab8d2025165dff27e4b45c70aa4053d57c0082724f4d56de5440455c717d7707ea2cc6f6f45fe6fe9852266756b9fa8d7a10bfd085fcf94e46a78495190a655f7dc0e88a4324e1379e168421d59bf7837ca963a4de5a37f8b0a60788aa8585c6b67bf44c51b0f0aecd2473c01e1694d976c14b692f74038439a26194c92782873db53eac5dbdca1d45941fd6066d4c439012dd699c098b7648b2aaf047418f50ed5f75ca8e42c549e918bfe5b35c8ea00f30ed308df79b62ab9d76fd7a299357f4990a29bdc7ca5c4d1f8ef57f3a682f9cf81004058496ec42387a9cd11bef57f010b843d4e1dc9e83e0abcbaddea2747e11a097a60dd976215f9d022058c36903d5b2c99e28d8d104aeeda2c0b139b0ac9b1bf68b234443d0abfdce7e460fb16778d6f7aef57beae4290f0e83d656a2fdeb3161486a13d80c1e78889e6ef29d0188518635bad3b807194f866dc5683b8ef37c7a7efb608d91c2b6fb2a07bca13c9600d8dd59d6bb78ea7b2a6c2abd18a05b6e74d29eda5e8bed5d1934deeb3538475495634712ce18a7beb6b0ed7713f882580a397f2e2e9c1ba4416d29b5be2e74c8aee7bbfee312474a1908151f5cf0aa7fb5cbd15190078e3a8f8f44aa53a7590c48e80bb59d42f13e435a3ba08e036fff8ea869248b6d1c37cc9bea2f932d657cea3dce5ca0fff7ac536465966d2a9974c4c39588cf69116ed7b90e9bce5b785f7dbb6801c22c7ddabb9ab85cb5e7d41161adaeb366cb45fd0ced21ca8627deea025b2921adac4dbf3d6597ea9da13c06e93796434cbe4d3988363a26e21f3cd2fd61352f7b816dac25936775f8ff300632cbce8ab3dfa4c66ee1c30dde47c9300a4c108ba98b487f96284cab8a2da99cb26411508528dd97fe7647ca4bdd29aaa6555975412b59e1373be41deca8c90507f5c168c18a7d92f09c2e29a4da48b8e22f1875655231df4aece38c1dbc3cea4d0a8078a4d3c11334c7646dad6de4a6da718b214368294d887aa1cd6e75a92bdd243f5adc4b7029943f24aaefa44533cc2b985a878b071247ee62e5d6dfc10506372284aa2a4ceeb171990d568840859b8a44658db8818f4ab32646cdde07a3c137640b20a831159fa054814e2612783ca4a77d87e996fe347243af5f50792f758001920d2b6da82168738a418c9d3cdd7fdee51aef8df663eb5665ee5aff8831df380268cf5a4d565efbe2dd37ed55777d465ae985a5c498e530aa41c92dba79dbde173ece192858863e811a6c1adce8ed728999de3b7939cd91544bbc256a3e61b35240c9e1c5394e9e07f3e83ff929c29644061f9c24d79e765b3aa181b190c1913ea6f49d7682284e596aecc9753b3b6e96174b9792f4650fd7463960832601b4ae38383bb61ea6a4ced7257674b79f22693dfd2b9f5b0f6f87d03c7c52ab1d401408d936092ec3edf0e4630c6eefc7403aa062d340ecac9be4b45ecb8bce6f6f7010d9b39f6fb039baf202ab9a7d476ea067c7e82e6e5170a38af40f7592248fa57557f91d81aa666de968c95b089fba24943bb019c17b9c89a860d0621ef4714b85d3f78bb34ee5f2da052d54f8ce43f2c0082eeb95a0f15a8b71707ccac103123d553400b7284cc5ab49d5b0a4985ea53063e251d9c5eae2ad55d9d4ff2f9b306065fab09a087175514485bdff0e586bd54910bba4782707a1b122c54f36c360b22cfc585c4bc9877ba524d47d0da888cb7667eb03c21e91b3845280b0c5beebcc6bd5e8e42895de2920493103416e56d331c3b725f93d5578bffcb63f58f7195384cc01e4cb38fadebd116c6b04169e72de2700f4aa16b59e7e4ab469c7ba471782ccc41de81155c2d97acd4e9470f04e33b2729ea672440401cc91353e01d873f0e336c7b7b2d148ffd5efb680745d81c819821d8359b9647419c927a19052e85b85514c82789c4ee4aaffb3f947e26d6b7fcf0ed8b7d505604fd0845904c6afa6090b732137b1eaa82e3dc744aeac94fc246388794ed89b839e9f5ff6ac93a863738999de122117f9c9d1519f176db4408747e88456c9fccc0aab81b771ec2f83139a8acfa90ac752affe813894d6d9865a0aab0c5eb73082e11fb7387b258c99a8c3cdaa75e545103f3ea788a174e7b89258169b6c0f3ceaf43187107d43abdef36ed56aa677055d0e81194dbf414999480accb71dd7493257e587cf80f208bcae1e9ab9403f050919e8cf1e24be1657c9ed18a7505581aa4737e27972fd8eaf25624d91decf09ec717578d621cc72faa794748f5b83efe166c3eccda48a98563fb1d1be05f4495df12ce25afdf9d2dc48461691d8155e691aeab7f070e278ea5e121c616e42f36b1ef332ce7e4c5052cd502902b4f564924516bef93845cf2ae00845d467ebaa9097e01ba93b27abd64def112aceed788dae216c90263e9ca4b99275fc5121ee57863d03bb2364a5b15c9fff45b2fc41387f2dd89d8032b6b6878dcf21d57efa5f6e3b1862ef29c241284913a5c46b2ec33d6ae94f567b021a0e6b71976967e84e6776d716df8dedf167</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-blink">
      <input class="hbe hbe-input-field hbe-input-field-blink" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-blink" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-blink" data-content="您好, 这里需要密码.">您好, 这里需要密码.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>面试</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>encryptalg</tag>
        <tag>面试算法</tag>
      </tags>
  </entry>
  <entry>
    <title>socket网络编程</title>
    <url>/posts/827e1516/</url>
    <content><![CDATA[<h3 id="socket分类"><a class="markdownIt-Anchor" href="#socket分类"></a> socket分类</h3>
<ol>
<li>
<p>流socket：基于TCP协议，有序可靠双向字节流</p>
</li>
<li>
<p>数据包socket：基于UDP协议，不需要维持连接对长度有限制</p>
</li>
</ol>
<p>QQ曾经使用UDP，现在使用TCP</p>
<h3 id="简单的socket通信流程"><a class="markdownIt-Anchor" href="#简单的socket通信流程"></a> 简单的socket通信流程</h3>
<p><img data-src="http://hz-picbed-xxh.oss-cn-hangzhou.aliyuncs.com/img-bed/image-20220309130634043.png" alt="image-20220309130634043" /></p>
<h4 id="perror函数"><a class="markdownIt-Anchor" href="#perror函数"></a> perror函数：</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">perror</span><span class="params">(<span class="string">&quot;string&quot;</span>)</span></span>; 打印出string + 上一个函数运行失败返回的错误信息。 </span><br></pre></td></tr></table></figure>
<h4 id="socket函数"><a class="markdownIt-Anchor" href="#socket函数"></a> socket函数</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">socket</span><span class="params">(<span class="type">int</span> af,<span class="type">int</span> type,<span class="type">int</span> protocol)</span></span>;</span><br><span class="line"><span class="comment">//af:address family，如AF_INET</span></span><br><span class="line"><span class="comment">//type:连接类型，通常是SOCK_STREAM或SOCK_DGRAM</span></span><br><span class="line"><span class="comment">//protocol:协议类型，通常是IPPROTO_TCP或IPPROTO_UDP</span></span><br></pre></td></tr></table></figure>
<h3 id="第一步创建一个服务端socket"><a class="markdownIt-Anchor" href="#第一步创建一个服务端socket"></a> 第一步：创建一个服务端socket</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> listenfd;</span><br><span class="line"><span class="keyword">if</span>((listen = <span class="built_in">socket</span>(AF_INET, SOCKET_STREAM, <span class="number">0</span>))==<span class="number">-1</span>)&#123; <span class="built_in">perror</span>(<span class="string">&quot;socket&quot;</span>);<span class="keyword">return</span> <span class="number">-1</span>;&#125;</span><br></pre></td></tr></table></figure>
<p>此时listenfd的文件描述符为3，因为linux下进程的0,1,2文件描述符分别分配给了stdin,stdout,stderr，若是gdb模式下，则从7开始计数。<mark>一个进程能打开的最大文件描述符数量是1024个</mark></p>
<h3 id="第二步将通信的地址和端口绑定到socket上"><a class="markdownIt-Anchor" href="#第二步将通信的地址和端口绑定到socket上"></a> 第二步：将通信的地址和端口绑定到socket上</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">bind</span><span class="params">(<span class="type">int</span> socket,sockaddr * address,uint addrlen)</span></span>;</span><br><span class="line"><span class="comment">// socket:之前创建的socket</span></span><br><span class="line"><span class="comment">// sockaddr:一个用来存放Ip地址和端口号的结构体</span></span><br><span class="line"><span class="comment">// addrlen:上述结构体的长度</span></span><br><span class="line"><span class="comment">// 返回值：为-1表示失败，若端口被占用，会从新绑定一个随机端口（仍返回失败）</span></span><br><span class="line"><span class="comment">// 地址绑定为0表示绑定本机所有IP</span></span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$ </span><span class="language-bash"><span class="built_in">ulimit</span> -a</span></span><br><span class="line"><span class="meta">#</span><span class="language-bash">查看单个进程打开的文件描述符数量</span></span><br><span class="line"><span class="meta">$ </span><span class="language-bash"><span class="built_in">ulimit</span> -HSn 2000</span></span><br><span class="line"><span class="meta">#</span><span class="language-bash">临时修改文件描述符的限制 H硬资源 S软资源限制</span></span><br></pre></td></tr></table></figure>
<h3 id="主机字节序与网络字节序"><a class="markdownIt-Anchor" href="#主机字节序与网络字节序"></a> 主机字节序与网络字节序</h3>
<p>小端字节序：低位字节存储在低地址</p>
<p>大端字节序：低位字节存储在高地址</p>
<p><mark>x86、arm采用小端模式，power pc mips unix采用大端模式</mark></p>
<p>网络字节序：与具体的cpu类型、操作系统无关，采用大端方式排序</p>
<p>主机字节序：由cpu决定，与操作系统无关</p>
<p>转换函数：htons,htonl,ntohs,ntohl 进行16位和32位的转换</p>
<h3 id="结构体"><a class="markdownIt-Anchor" href="#结构体"></a> 结构体</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">sockaddr</span>&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> sa_family; <span class="comment">//地址类型 AF_XXX</span></span><br><span class="line">    <span class="type">char</span> sa_data[<span class="number">14</span>]; <span class="comment">//14字节的端口和地址</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">sockaddr_in</span>&#123;</span><br><span class="line">    <span class="type">short</span> <span class="type">int</span> sin_family; <span class="comment">//地址类型</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> <span class="type">int</span> sin_port; <span class="comment">//16位端口号</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">in_addr</span> sin_addr; <span class="comment">//32位ip4地址</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> sin_zero[<span class="number">8</span>]; <span class="comment">//为了保持与struct sockaddr 一样的长度，强制转换</span></span><br><span class="line">&#125;；</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">in_addr</span>&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> s_addr; <span class="comment">//32位ip4地址</span></span><br><span class="line">&#125;；</span><br></pre></td></tr></table></figure>
<h4 id="第2步把服务端用于通信的地址和端口绑定到socket上"><a class="markdownIt-Anchor" href="#第2步把服务端用于通信的地址和端口绑定到socket上"></a> 第2步：把服务端用于通信的地址和端口绑定到socket上。</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> servaddr;    <span class="comment">// 服务端地址信息的数据结构。</span></span><br><span class="line"><span class="built_in">memset</span>(&amp;servaddr,<span class="number">0</span>,<span class="built_in">sizeof</span>(servaddr));</span><br><span class="line">servaddr.sin_family = AF_INET;  <span class="comment">// 协议族，在socket编程中只能是AF_INET。</span></span><br><span class="line">servaddr.sin_addr.s_addr = <span class="built_in">htonl</span>(INADDR_ANY);          <span class="comment">// 任意ip地址。</span></span><br><span class="line">  <span class="comment">//servaddr.sin_addr.s_addr = inet_addr(&quot;192.168.190.134&quot;); // 指定ip地址。</span></span><br><span class="line">servaddr.sin_port = <span class="built_in">htons</span>(<span class="built_in">atoi</span>(argv[<span class="number">1</span>]));  <span class="comment">// 指定通信端口。</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">bind</span>(listenfd,(<span class="keyword">struct</span> sockaddr *)&amp;servaddr,<span class="built_in">sizeof</span>(servaddr)) != <span class="number">0</span> )</span><br><span class="line">  &#123; <span class="built_in">perror</span>(<span class="string">&quot;bind&quot;</span>); <span class="built_in">close</span>(listenfd); <span class="keyword">return</span> <span class="number">-1</span>; &#125;</span><br></pre></td></tr></table></figure>
<h4 id="bind函数"><a class="markdownIt-Anchor" href="#bind函数"></a> bind函数</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">bind</span><span class="params">(<span class="type">int</span> socket,sockaddr * address,uint addrlen)</span></span>;</span><br><span class="line"><span class="comment">// socket:之前创建的socket</span></span><br><span class="line"><span class="comment">// sockaddr:一个用来存放Ip地址和端口号的结构体</span></span><br><span class="line"><span class="comment">// addrlen:上述结构体的长度</span></span><br><span class="line"><span class="comment">// 返回值：为-1表示失败，若端口被占用，会从新绑定一个随机端口（仍返回失败）</span></span><br><span class="line"><span class="comment">// 地址绑定为0表示绑定本机所有IP</span></span><br></pre></td></tr></table></figure>
<p>非root权限只能绑定1024及以上的端口</p>
<h4 id="inet_addr"><a class="markdownIt-Anchor" href="#inet_addr"></a> inet_addr</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">inet_aton</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *cp,<span class="keyword">struct</span> in_addr *inp)</span></span>;</span><br><span class="line"><span class="comment">//将一个字符创ip转换为32位的网络字节序，成功返回非0，失败返回0</span></span><br><span class="line"><span class="function"><span class="type">char</span> *<span class="title">inet_ntoa</span><span class="params">(<span class="keyword">struct</span> in_addr in)</span></span>;</span><br><span class="line"><span class="comment">//将网络字节序ip转换成字符串ip</span></span><br><span class="line"><span class="function"><span class="type">in_addr_t</span> <span class="title">inet_addr</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *cp)</span></span>; <span class="comment">//功能和inet_aton类似</span></span><br></pre></td></tr></table></figure>
<h4 id="gethostbyname"><a class="markdownIt-Anchor" href="#gethostbyname"></a> gethostbyname</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">hostent</span>&#123;</span><br><span class="line">    <span class="type">char</span> *h_name; <span class="comment">//主机</span></span><br><span class="line">    <span class="type">char</span> ** h_aliases; <span class="comment">//主机所有别名构成的字符创数组，同一ip可绑定多个域名</span></span><br><span class="line">    <span class="type">int</span> h_addrtype; <span class="comment">//主机ip地址的类型，例如IPV4(AF_INET)还是IPV6</span></span><br><span class="line">    <span class="type">int</span> h_length; <span class="comment">//主机ip地址长度</span></span><br><span class="line">    <span class="type">char</span> **h_addr_list; <span class="comment">//主机的ip地址，以网络字节序存储</span></span><br><span class="line">&#125;；</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> h_addr h_addr_list[0] <span class="comment">//兼容性考虑</span></span></span><br><span class="line">    <span class="comment">//利用字符串格式的域名获得IP网络字节序地址</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">hostent</span> *<span class="built_in">gethostbyname</span>(<span class="type">const</span> <span class="type">char</span> *name);</span><br></pre></td></tr></table></figure>
<h3 id="客户端的绑定socket"><a class="markdownIt-Anchor" href="#客户端的绑定socket"></a> 客户端的绑定socket</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">hostent</span>* h;</span><br><span class="line">  <span class="keyword">if</span> ( (h = <span class="built_in">gethostbyname</span>(argv[<span class="number">1</span>])) == <span class="number">0</span> )   <span class="comment">// 指定服务端的ip地址。可以从域名翻译</span></span><br><span class="line">  &#123; <span class="built_in">printf</span>(<span class="string">&quot;gethostbyname failed.\n&quot;</span>); <span class="built_in">close</span>(sockfd); <span class="keyword">return</span> <span class="number">-1</span>; &#125;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> servaddr;</span><br><span class="line">  <span class="built_in">memset</span>(&amp;servaddr,<span class="number">0</span>,<span class="built_in">sizeof</span>(servaddr));</span><br><span class="line">  servaddr.sin_family = AF_INET;</span><br><span class="line">  servaddr.sin_port = <span class="built_in">htons</span>(<span class="built_in">atoi</span>(argv[<span class="number">2</span>])); <span class="comment">// 指定服务端的通信端口。</span></span><br><span class="line">  <span class="built_in">memcpy</span>(&amp;servaddr.sin_addr,h-&gt;h_addr,h-&gt;h_length);</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">connect</span>(sockfd, (<span class="keyword">struct</span> sockaddr *)&amp;servaddr,<span class="built_in">sizeof</span>(servaddr)) != <span class="number">0</span>)  <span class="comment">// 向服务端发起连接清求。</span></span><br><span class="line">  &#123; <span class="built_in">perror</span>(<span class="string">&quot;connect&quot;</span>); <span class="built_in">close</span>(sockfd); <span class="keyword">return</span> <span class="number">-1</span>; &#125;</span><br></pre></td></tr></table></figure>
<h4 id="设置服务端socket的so_reuseaddr属性"><a class="markdownIt-Anchor" href="#设置服务端socket的so_reuseaddr属性"></a> 设置服务端socket的SO_REUSEADDR属性</h4>
<p>服务端程序的端口释放后可能会处于time_wait状态，需要待两分钟(linux下)后才能使用,<code>SO_REUSEADDR</code>可以立刻再次被使用。</p>
<p><a href="https://www.cnblogs.com/hateislove214/archive/2010/11/05/1869886.html">https://www.cnblogs.com/hateislove214/archive/2010/11/05/1869886.html</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> opt = <span class="number">1</span>; <span class="type">unsigned</span> <span class="type">int</span> len = <span class="built_in">sizeof</span>(opt);</span><br><span class="line"><span class="built_in">setsockopt</span>(listenfd,SOL_SOCKET, SO_REUSEADDR,&amp;opt,len);</span><br></pre></td></tr></table></figure>
<h3 id="第三步-监听socket"><a class="markdownIt-Anchor" href="#第三步-监听socket"></a> 第三步 监听socket</h3>
<p>在此处client和server已经established。大于backlog数量的连接将维持在SYN_RECV阶段.</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$ </span><span class="language-bash"><span class="built_in">cat</span> /proc/sys/net/ipv4/tcp_max_syn_backlog</span> </span><br></pre></td></tr></table></figure>
<p>syn队列最大值为128（centos），接受的ESTABLISHED的数量是backlog+1,包含当前正在通信的连接。</p>
<p>Linux使用两个队列实现，一个SYN队列（或半连接队列）和一个accept队列（或完整的连接队列）。 处于SYN RECEIVED状态的连接被添加到SYN队列，并且当它们的状态改变为ESTABLISHED时，即当接收到3次握手中的ACK分组时，将它们移动到accept队列。 显而易见，accept系统调用只是简单地从完成队列中取出连接。 在这种情况下，listen syscall的backlog参数表示完成队列的大小。</p>
<p><img data-src="http://hz-picbed-xxh.oss-cn-hangzhou.aliyuncs.com/img-bed/image-20220309232131451.png" alt="TCP三次握手" /></p>
<h4 id="listen函数"><a class="markdownIt-Anchor" href="#listen函数"></a> listen函数</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">listen</span><span class="params">(<span class="type">int</span> socketfd,<span class="type">int</span> backlog)</span></span>;【仅TCP】【服务器】</span><br><span class="line"><span class="comment">// 将一个socketfd设置为监听状态,专门用来监听的socket叫做master socket</span></span><br><span class="line"><span class="comment">// backlog:最大接收连接数</span></span><br><span class="line"><span class="comment">// 返回值：失败返回-1，成功返回0</span></span><br></pre></td></tr></table></figure>
<h4 id="connect函数"><a class="markdownIt-Anchor" href="#connect函数"></a> connect函数</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">connect</span><span class="params">(<span class="type">int</span> socket,sockaddr * addr,<span class="type">int</span> addrlen)</span></span>;【仅TCP】【客户端】</span><br><span class="line"><span class="comment">// 使用当前socket连接一个地址（与服务器建立正式连接），此函数会触发服务器端的accept、select函数</span></span><br><span class="line"><span class="comment">// 注意：服务端接收的socket值和客户端socket值不一样</span></span><br><span class="line"><span class="comment">// addr:一般是服务器地址</span></span><br></pre></td></tr></table></figure>
<h4 id="linux相关命令"><a class="markdownIt-Anchor" href="#linux相关命令"></a> linux相关命令</h4>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$ </span><span class="language-bash">netstat</span></span><br><span class="line">-a 显示所有选项</span><br><span class="line">-t 显示tcp</span><br><span class="line">-u 显示udp</span><br><span class="line">-l 显示listen状态</span><br><span class="line">-p 显示pid</span><br><span class="line">-r 显示路由表 </span><br><span class="line">-n 拒绝显示别名，尽量显示数字</span><br><span class="line"><span class="meta">$ </span><span class="language-bash">awk</span></span><br><span class="line">-F &#x27;:&#x27; 以:为分隔符，默认是空白</span><br><span class="line">&#x27;&#123;print $0&#125;&#x27; 打印所有的行</span><br><span class="line">&#x27;&#123;a+=$1&#125;&#x27; 将$1的数字加到a变量上</span><br><span class="line"><span class="meta">$</span><span class="language-bash">sed</span> </span><br><span class="line">-e 表示下一个是命令</span><br><span class="line">a:追加  向匹配行后面插入内容</span><br><span class="line">c:更改  更改匹配行的内容</span><br><span class="line">i:插入  向匹配行前插入内容</span><br><span class="line">d:删除  删除匹配的内容</span><br><span class="line">s:替换  替换掉匹配的内容</span><br><span class="line">&#x27;2ahello&#x27; 在第三行后添加hello</span><br></pre></td></tr></table></figure>
<h4 id="绑定监听端口"><a class="markdownIt-Anchor" href="#绑定监听端口"></a> 绑定监听端口</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">listen</span>(listenfd,<span class="number">5</span>) != <span class="number">0</span> ) &#123; <span class="built_in">perror</span>(<span class="string">&quot;listen&quot;</span>); <span class="built_in">close</span>(listenfd); <span class="keyword">return</span> <span class="number">-1</span>; &#125;</span><br></pre></td></tr></table></figure>
<h3 id="第四步-接受客户端的请求"><a class="markdownIt-Anchor" href="#第四步-接受客户端的请求"></a> 第四步 接受客户端的请求</h3>
<h4 id="accept函数"><a class="markdownIt-Anchor" href="#accept函数"></a> accept函数</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">accept</span><span class="params">(<span class="type">int</span> socket,sockaddr * fromaddr,<span class="type">int</span> * addrlen)</span></span>;【阻塞】【仅TCP】【服务器】</span><br><span class="line"><span class="comment">// 接收一个客户机的连接，返回一个socket，来自客户机的socket叫connected socket</span></span><br><span class="line"><span class="comment">// socket:用来监听的socket（master socket）</span></span><br><span class="line"><span class="comment">// fromaddr:客户机的地址信息</span></span><br><span class="line"><span class="comment">// addrlen:地址结构体的长度（输入输出参数）</span></span><br><span class="line"><span class="comment">// 返回值：返回一个新的socket，这个socket专门用来与此客户机通讯（connected socket）</span></span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>  clientfd;                  <span class="comment">// 客户端的socket。</span></span><br><span class="line"><span class="type">int</span>  socklen=<span class="built_in">sizeof</span>(<span class="keyword">struct</span> sockaddr_in); <span class="comment">// struct sockaddr_in的大小</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> clientaddr;  <span class="comment">// 客户端的地址信息。</span></span><br><span class="line">clientfd=<span class="built_in">accept</span>(listenfd,(<span class="keyword">struct</span> sockaddr *)&amp;clientaddr,(<span class="type">socklen_t</span>*)&amp;socklen);</span><br></pre></td></tr></table></figure>
<h3 id="多进程搭建"><a class="markdownIt-Anchor" href="#多进程搭建"></a> 多进程搭建</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(True)&#123;</span><br><span class="line">    <span class="keyword">if</span>((clientfd = <span class="built_in">accept</span>())&gt;<span class="number">0</span>)&#123;&#125; <span class="comment">//此处阻塞</span></span><br><span class="line">    <span class="keyword">if</span>(fork()&gt;<span class="number">0</span>) <span class="keyword">continue</span> ；<span class="comment">//一次fork返回两次，父进程返回子进程id，子进程返回0</span></span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//子进程</span></span><br><span class="line">        <span class="comment">//子进程关闭listenfd 父进程关闭clientfd</span></span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);<span class="comment">//退出子进程</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="避免产生僵尸进程"><a class="markdownIt-Anchor" href="#避免产生僵尸进程"></a> 避免产生僵尸进程</h4>
<p><a href="https://www.cnblogs.com/yuxingfirst/p/3165407.html">linux僵尸进程产生的原因以及如何避免产生僵尸进程</a></p>
<p>如果子进程先于父进程退出， 同时父进程又没有调用wait/waitpid，则该子进程将成为僵尸进程。通过ps命令，我们可以看到该进程的状态为Z(表示僵死)</p>
<ol>
<li>使用忽略信号</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">signal</span>(SIGCHLD, SIG_IGN);<span class="comment">//屏蔽子进程退出的信号，避免产生僵尸进程</span></span><br></pre></td></tr></table></figure>
<ol start="2">
<li>使用wait()函数</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">sig_chld</span><span class="params">( <span class="type">int</span> signo )</span> </span>&#123;</span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line">    <span class="type">int</span> stat;</span><br><span class="line">    pid = <span class="built_in">wait</span>(&amp;stat);    </span><br><span class="line">    <span class="built_in">printf</span>( <span class="string">&quot;child %d exit\n&quot;</span>, pid );</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">signal</span>(SIGCHLD,  &amp;sig_chld);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>
<p>多进程c/s中使用waitpid()</p>
<p>我们假设有一个client/server的程序，对于每一个连接过来的client，server都启动一个新的进程去处理来自这个client的请求。然后我们有一个client进程，在这个进程内，发起了多个到server的请求（假设5个），则server会fork 5个子进程来读取client输入并处理（同时，当客户端关闭套接字的时候，每个子进程都退出）；当我们终止这个client进程的时候 ，内核将自动关闭所有由这个client进程打开的套接字，那么由这个client进程发起的5个连接基本在同一时刻终止。这就引发了5个FIN，每个连接一个。server端接受到这5个FIN的时候，5个子进程基本在同一时刻终止。这就又导致差不多在同一时刻递交5个SIGCHLD信号给父进程，建立信号处理函数并在其中调用wait并不足以防止出现僵尸进程，其原因在于：所有5个信号都在信号处理函数执行之前产生，而信号处理函数只执行一次，因为Unix信号一般是不排队的(我的这篇博客中有提到http://www.cnblogs.com/yuxingfirst/p/3160697.html)。 更为严重的是，本问题是不确定的，依赖于客户FIN到达服务器主机的时机，信号处理函数执行的次数并不确定。</p>
<p>正确的解决办法是调用waitpid而不是wait，这个办法的方法为：信号处理函数中，在一个循环内调用waitpid，以获取所有已终止子进程的状态。我们必须指定WNOHANG选项，他告知waitpid在有尚未终止的子进程在运行时不要阻塞。（我们不能在循环内调用wait，因为没有办法防止wait在尚有未终止的子进程在运行时阻塞，wait将会阻塞到现有的子进程中第一个终止为止）</p>
</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func_waitpid</span><span class="params">(<span class="type">int</span> signo)</span> </span>&#123;</span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line">    <span class="type">int</span> stat;</span><br><span class="line">    <span class="keyword">while</span>( (pid = <span class="built_in">waitpid</span>(<span class="number">-1</span>, &amp;stat, WNOHANG)) &gt; <span class="number">0</span> ) &#123;</span><br><span class="line">        <span class="built_in">printf</span>( <span class="string">&quot;child %d exit\n&quot;</span>, pid );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">sigfunc* <span class="title">signal</span><span class="params">( <span class="type">int</span> signo, sigfunc *func )</span> </span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sigaction</span> act, oact;</span><br><span class="line">    act.sa_handler = func;</span><br><span class="line">    <span class="built_in">sigemptyset</span>(&amp;act.sa_mask);</span><br><span class="line">    act.sa_flags = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> ( signo == SIGALRM ) &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span>            SA_INTERRUPT</span></span><br><span class="line">        act.sa_flags |= SA_INTERRUPT;    <span class="comment">/* SunOS 4.x */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span>           SA_RESTART</span></span><br><span class="line">        act.sa_flags |= SA_RESTART;    <span class="comment">/* SVR4, 4.4BSD */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( <span class="built_in">sigaction</span>(signo, &amp;act, &amp;oact) &lt; <span class="number">0</span> ) &#123;</span><br><span class="line">        <span class="keyword">return</span> SIG_ERR;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> oact.sa_handler;</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">signal</span>(SIGCHLD, &amp;func_waitpid);    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="waitpid函数"><a class="markdownIt-Anchor" href="#waitpid函数"></a> waitpid()函数</h4>
<p><a href="https://blog.csdn.net/yiyi__baby/article/details/45539993">https://blog.csdn.net/yiyi__baby/article/details/45539993</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">pid_t</span> <span class="title">waitpid</span><span class="params">(<span class="type">pid_t</span> pid,<span class="type">int</span> *status,<span class="type">int</span> options)</span></span></span><br></pre></td></tr></table></figure>
<h5 id="pid"><a class="markdownIt-Anchor" href="#pid"></a> pid：</h5>
<ol>
<li>pid&gt;0时，只<strong>等待进程ID等于pid的子进程</strong>，不管其它已经有多少子进程运行结束退出了，只要指定的子进程还没有结束，waitpid就会一直等下去。</li>
<li><strong>pid=-1时，等待任何一个子进程退出，没有任何限制，此时waitpid和wait的作用一模一样。</strong></li>
<li>pid=0时，等待同一个进程组中的任何子进程，如果子进程已经加入了别的进程组，waitpid不会对它做任何理睬。</li>
<li><strong>pid&lt; -1时，等待一个指定进程组中的任何子进程，这个进程组的ID等于pid的绝对值。</strong></li>
</ol>
<h5 id="options"><a class="markdownIt-Anchor" href="#options"></a> options：</h5>
<p><strong>如果使用了WNOHANG(wait no hung)参数调用waitpid，即使没有子进程退出，它也会立即返回，不会像wait那样永远等下去。</strong><mark>即不会阻塞信号，linux信号不排队</mark></p>
<h5 id="返回值"><a class="markdownIt-Anchor" href="#返回值"></a> 返回值</h5>
<ol>
<li>当正常返回的时候，waitpid返回收集到的子进程的进程ID；</li>
<li><strong>如果设置了选项WNOHANG，而调用中waitpid发现没有已退出的子进程可收集，则返回0；</strong></li>
<li>如果调用中出错，则返回-1，这时errno会被设置成相应的值以指示错误所在；</li>
</ol>
<h3 id="多线程和多进程"><a class="markdownIt-Anchor" href="#多线程和多进程"></a> 多线程和多进程</h3>
<p>区别只是在于clone参数不同。线程创建时，父子俩共享虚拟地址空间、文件系统资源、文件描述符和信号处理函数及信号。创建子进程，则是注册一个SIGCHLD信号，当子进程终止时，会向父进程发送一个SIGCHLD信号，即父进程wait函数收到的那个。</p>
<p>即pthread_create对应fork，pthread_join对应wait。</p>
<h3 id="io复用"><a class="markdownIt-Anchor" href="#io复用"></a> IO复用</h3>
<p>多进程/线程为每个socket分配一个进程/线程</p>
<p>select、poll、epoll，单个进程/线程管理多个socket</p>
<h4 id="select的流程"><a class="markdownIt-Anchor" href="#select的流程"></a> select的流程</h4>
<p><img data-src="http://hz-picbed-xxh.oss-cn-hangzhou.aliyuncs.com/img-bed/image-20220310161722370.png" alt="image-20220310161722370" /></p>
<h4 id="select模型服务程序的流程"><a class="markdownIt-Anchor" href="#select模型服务程序的流程"></a> select模型服务程序的流程</h4>
<p><img data-src="http://hz-picbed-xxh.oss-cn-hangzhou.aliyuncs.com/img-bed/image-20220310162615636.png" alt="image-20220310162615636" /></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">setsockopt</span>(sock,SOL_SOCKET,SO_REUSEADDR,<span class="number">1</span>,len);</span><br><span class="line"><span class="built_in">setsockopt</span>(sock,SOL_SOCKET,SO_KEEPALIVE,<span class="number">1</span>,len);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> listensock;</span><br><span class="line">fd_set readfdset; <span class="comment">//创建集合</span></span><br><span class="line"><span class="type">int</span> maxfd;<span class="comment">//readfdset中socket的最大值</span></span><br><span class="line"><span class="built_in">FD_ZERO</span>(&amp;readfdset);<span class="comment">//初始化结构体，添加监听端口</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">FD_SET</span>(listensock, &amp;readfdset);</span><br><span class="line">maxfd = listensock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    fd_set tmpfdset = readfdset; <span class="comment">//调用时select函数时会改变内容，需要保存,下面查询使用</span></span><br><span class="line">    <span class="type">int</span> infds = <span class="built_in">select</span>(maxfd+<span class="number">1</span>,&amp;tmpfdset,<span class="literal">NULL</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//检测事件发生</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> eventfd = <span class="number">0</span>; eventfd&lt;=maxfd;eventfd++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">FD_ISSET</span>(eventfd,&amp;tmpfdset)&lt;=<span class="number">0</span>)<span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>(eventfd==listensock)&#123;</span><br><span class="line">            <span class="comment">//accept</span></span><br><span class="line">            <span class="built_in">FD_SET</span>(clientsock,&amp;rea dfdset);maxfd = <span class="built_in">max</span>(maxfd,clientsock);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>select是一个1024位的bitmap位图</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">select</span><span class="params">(<span class="type">int</span> maxfdp1, fd_set *readset, fd_set *writeset, fd_set *exceptset,<span class="keyword">struct</span> timeval *timeout)</span></span>;</span><br><span class="line">timeout: <span class="literal">NULL</span>为阻塞函数 ，<span class="number">0</span>为非阻塞函数</span><br><span class="line">成功返回发生事件的个数</span><br><span class="line">FD_CLR <span class="comment">//清除位</span></span><br><span class="line">FD_ISSET</span><br><span class="line">FD_SET  <span class="comment">//加入集合</span></span><br><span class="line">FD_ZERO <span class="comment">//初始化</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>epoll在默认情况下是ET边缘触发模式，select poll是在LT水平触发模式下的</p>
<p>什么是边缘触发和水平触发？<br />
水平触发： LT<br />
只要缓冲区有数据，就一直报告</p>
<p>边缘触发： ET<br />
数据一次处理不完，下一次改变状态才报告</p>
</blockquote>
<p><mark>pselect可以屏蔽信号</mark></p>
<h3 id="select的缺点"><a class="markdownIt-Anchor" href="#select的缺点"></a> select的缺点</h3>
<ol>
<li>支持的文件描述符数量太小了，默认是1024，且数量越大，效率越低。</li>
<li>每次调用select都要把fdset从用户态拷贝到内核</li>
<li>遍历fdset的效率很低</li>
</ol>
<h3 id="poll模型"><a class="markdownIt-Anchor" href="#poll模型"></a> poll模型</h3>
<ol>
<li>使用数组</li>
<li>同样整体复制于用户态和内核态之间</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">poll</span><span class="params">(<span class="keyword">struct</span> pollfd *fds, <span class="type">nfds_t</span> nfds, <span class="type">int</span> timeout)</span></span></span><br><span class="line"><span class="function"><span class="keyword">struct</span> pollfd</span>&#123;</span><br><span class="line">    <span class="type">int</span> fd;</span><br><span class="line">    <span class="type">short</span> events;<span class="comment">//events：表示要告诉操作系统需要监测fd的事件（输入、输出、错误），每一个事件有多个取值</span></span><br><span class="line">    <span class="type">short</span> revents;<span class="comment">//revents：revents 域是文件描述符的操作结果事件，内核在调用返回时设置这个域。events 域中请求的任何事件都可能在 revents 域中返回。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="epoll"><a class="markdownIt-Anchor" href="#epoll"></a> epoll</h3>
<ol>
<li>
<p>创建epoll句柄，本身就是一个fd</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">epoll_create</span><span class="params">(<span class="type">int</span> size)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>注册需要监视fd和事件</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">epoll_ctl</span><span class="params">(<span class="type">int</span> epfd, <span class="type">int</span> op, <span class="type">int</span> fd,<span class="keyword">struct</span> epoll_event *event)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>等待事件发生</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">epoll_wait</span><span class="params">(<span class="type">int</span> epfd,<span class="keyword">struct</span> epoll_event *events, <span class="type">int</span> maxevents, timeout)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="流程"><a class="markdownIt-Anchor" href="#流程"></a> 流程</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> epollfd = <span class="built_in">epoll_create</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//添加监听描述符事件</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">epoll_event</span> ev;</span><br><span class="line">ev.data.fd = listensock;</span><br><span class="line">ev.events = EPOLLIN;</span><br><span class="line"><span class="built_in">epoll_ctl</span>(epollfd,EPOLL_CTL_ADD,listensock,&amp;ev);</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>cpp</category>
      </categories>
      <tags>
        <tag>socket</tag>
      </tags>
  </entry>
</search>
